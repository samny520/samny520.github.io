
<!DOCTYPE html>
<html lang="zh-Hans" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>CodeQL library for Java - 像清水一般清澈透明</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="SummerSec CodeQl,"> 
    <meta name="description" content="CodeQL library for Java¶When you’re analyzing a Java program, you can make use of the large collect,"> 
    <meta name="author" content="SummerSec"> 
    <link rel="alternative" href="atom.xml" title="像清水一般清澈透明" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

    
<link rel="stylesheet" href="/css/diaspora.css">

    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
<meta name="generator" content="Hexo 4.1.1"></head>

<body class="loading">
    <span id="config-title" style="display:none">像清水一般清澈透明</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="icon-home image-icon" href="javascript:;" data-url="https://summersec.github.io"></a>
    <div title="播放/暂停" class="icon-play"></div>
    <h3 class="subtitle">CodeQL library for Java</h3>
    <div class="social">
        <!--<div class="like-icon">-->
            <!--<a href="javascript:;" class="likeThis active"><span class="icon-like"></span><span class="count">76</span></a>-->
        <!--</div>-->
        <div>
            <div class="share">
                <a title="获取二维码" class="icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">CodeQL library for Java</h1>
        <div class="stuff">
            <span>三月 24, 2021</span>
            

        </div>
        <div class="content markdown">
            <h1 id="CodeQL-library-for-Java¶"><a href="#CodeQL-library-for-Java¶" class="headerlink" title="CodeQL library for Java¶"></a>CodeQL library for Java<a href="https://codeql.github.com/docs/codeql-language-guides/codeql-library-for-java/#codeql-library-for-java" target="_blank" rel="noopener">¶</a></h1><p>When you’re analyzing a Java program, you can make use of the large collection of classes in the CodeQL library for Java.</p>
<blockquote>
<p>当你在分析一个Java程序时，你可以利用Java的CodeQL库中的大量类的集合。</p>
</blockquote>
<h2 id="About-the-CodeQL-library-for-Java"><a href="#About-the-CodeQL-library-for-Java" class="headerlink" title="About the CodeQL library for Java"></a>About the CodeQL library for Java</h2><p>There is an extensive library for analyzing CodeQL databases extracted from Java projects. The classes in this library present the data from a database in an object-oriented form and provide abstractions and predicates to help you with common analysis tasks.</p>
<blockquote>
<p>有一个广泛的库用于分析从Java项目中提取的CodeQL数据库。该库中的类以面向对象的形式呈现数据库中的数据，并提供抽象和谓词来帮助你完成常见的分析任务。</p>
</blockquote>
<p>The library is implemented as a set of QL modules, that is, files with the extension <code>.qll</code>. The module <code>java.qll</code> imports all the core Java library modules, so you can include the complete library by beginning your query with:</p>
<blockquote>
<p>该库以一组QL模块的形式实现，也就是扩展名为.qll的文件。java.qll模块导入了所有的核心Java库模块，所以你可以通过以以下方式开始查询来包含完整的库。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br></pre></td></tr></table></figure>

<p>The rest of this article briefly summarizes the most important classes and predicates provided by this library.</p>
<blockquote>
<p>本文其余部分简要总结了这个库提供的最重要的类和谓词。</p>
</blockquote>
<blockquote>
<p>Note</p>
<p>The example queries in this article illustrate the types of results returned by different library classes. The results themselves are not interesting but can be used as the basis for developing a more complex query. The other articles in this section of the help show how you can take a simple query and fine-tune it to find precisely the results you’re interested in.</p>
<p>本文的示例查询说明了不同库类返回的结果类型。这些结果本身并不有趣，但可以作为开发更复杂查询的基础。本节帮助中的其他文章展示了如何将一个简单的查询进行微调，以精确地找到你感兴趣的结果。</p>
</blockquote>
<h2 id="Summary-of-the-library-classes"><a href="#Summary-of-the-library-classes" class="headerlink" title="Summary of the library classes"></a>Summary of the library classes</h2><p>The most important classes in the standard Java library can be grouped into five main categories:</p>
<blockquote>
<p>标准Java库中最重要的类可以分为五大类。</p>
</blockquote>
<ol>
<li><p>Classes for representing program elements (such as classes and methods)</p>
<blockquote>
<p>代表程序元素的类（如类和方法）。</p>
</blockquote>
</li>
<li><p>Classes for representing AST nodes (such as statements and expressions)</p>
<blockquote>
<p>用于表示AST节点（如语句和表达式）的类。</p>
</blockquote>
</li>
<li><p>Classes for representing metadata (such as annotations and comments)</p>
<blockquote>
<p>用于表示元数据（如注释和评论）的类。</p>
</blockquote>
</li>
<li><p>Classes for computing metrics (such as cyclomatic complexity and coupling)</p>
<blockquote>
<p>计算度量的类（如循环复杂度和耦合度</p>
</blockquote>
</li>
<li><p>Classes for navigating the program’s call graph</p>
<blockquote>
<p>用于导航程序的调用图的类。</p>
</blockquote>
</li>
</ol>
<p>We will discuss each of these in turn, briefly describing the most important classes for each category.</p>
<blockquote>
<p>我们将依次讨论这些内容，简要介绍每一类最重要的类别。</p>
</blockquote>
<h2 id="Program-elements"><a href="#Program-elements" class="headerlink" title="Program elements"></a>Program elements</h2><p>These classes represent named program elements: packages (<code>Package</code>), compilation units (<code>CompilationUnit</code>), types (<code>Type</code>), methods (<code>Method</code>), constructors (<code>Constructor</code>), and variables (<code>Variable</code>).</p>
<blockquote>
<p>这些类表示命名的程序元素：包（Package）、编译单元（CompilationUnit）、类型（Type）、方法（Method）、构造器（Constructor）和变量（Variable）。</p>
</blockquote>
<p>Their common superclass is <code>Element</code>, which provides general member predicates for determining the name of a program element and checking whether two elements are nested inside each other.</p>
<blockquote>
<p>它们共同的超类是Element，它提供了一般的成员谓词，用于确定程序元素的名称和检查两个元素内部是否相互嵌套。</p>
</blockquote>
<p>It’s often convenient to refer to an element that might either be a method or a constructor; the class <code>Callable</code>, which is a common superclass of <code>Method</code> and <code>Constructor</code>, can be used for this purpose.</p>
<blockquote>
<p>通常，引用一个可能是方法或构造函数的元素是很方便的；类Callable是Method和Constructor的共同超类，可以用于这个目的。</p>
</blockquote>
<h3 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h3><p>Class <code>Type</code> has a number of subclasses for representing different kinds of types:</p>
<blockquote>
<p>类Type有许多子类，用于表示不同种类的类型:</p>
</blockquote>
<ul>
<li><p><code>PrimitiveType</code> represents a <a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html" target="_blank" rel="noopener">primitive type</a>, that is, one of <code>boolean</code>, <code>byte</code>, <code>char</code>, <code>double</code>, <code>float</code>, <code>int</code>, <code>long</code>, <code>short</code>; QL also classifies <code>void</code> and <code>&lt;nulltype&gt;</code> (the type of the <code>null</code> literal) as primitive types.</p>
<blockquote>
<p>PrimitiveType表示一个基元类型，即布尔、字节、char、double、float、int、long、short中的一种；QL还将void和<nulltype>（null文字的类型）归为基本类型。    </nulltype></p>
</blockquote>
</li>
<li><pre><code>  RefType
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    represents a reference (that is, non-primitive) type; it in turn has several subclasses:</span><br><span class="line"></span><br><span class="line">    &gt;  代表一个引用（即非基本）类型；它又有几个子类：</span><br><span class="line"></span><br><span class="line">    * &#96;Class&#96; represents a Java class. Class代表一个Java类。</span><br><span class="line">    * &#96;Interface&#96; represents a Java interface.  Interface代表一个Java接口。</span><br><span class="line">    * &#96;EnumType&#96; represents a Java &#96;enum&#96; type.  EnumType代表一个Java枚举类型。</span><br><span class="line">    * &#96;Array&#96; represents a Java array type. Array代表一个Java数组类型。</span><br><span class="line"></span><br><span class="line">For example, the following query finds all variables of type &#96;int&#96; in the program:</span><br><span class="line"></span><br><span class="line">&gt; 例如，下面的查询可以找到程序中所有类型为int的变量:</span><br></pre></td></tr></table></figure>
import java
</code></pre></li>
</ul>
<p>from Variable v, PrimitiveType pt<br>where pt = v.getType() and<br>    pt.hasName(“int”)<br>select v</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">➤ [See this in the query console on LGTM.com](https:&#x2F;&#x2F;lgtm.com&#x2F;query&#x2F;860076406167044435&#x2F;). You’re likely to get many results when you run this query because most projects contain many variables of type &#96;int&#96;.</span><br><span class="line"></span><br><span class="line">&gt;  在LGTM.com的查询控制台中可以看到。运行此查询时，很可能会得到许多结果，因为大多数项目都包含许多类型为int的变量。</span><br><span class="line"></span><br><span class="line">![image-20210319172755510](https:&#x2F;&#x2F;gitee.com&#x2F;samny&#x2F;images&#x2F;raw&#x2F;master&#x2F;55u27er55ec&#x2F;55u27er55ec.png)</span><br><span class="line"></span><br><span class="line">Reference types are also categorized according to their declaration scope:</span><br><span class="line"></span><br><span class="line">&gt; 引用类型也根据其声明范围进行分类:</span><br><span class="line"></span><br><span class="line">* &#96;TopLevelType&#96; represents a reference type declared at the top-level of a compilation unit.</span><br><span class="line"></span><br><span class="line">    &gt; TopLevelType表示在编译单元的顶层声明的引用类型。</span><br><span class="line"></span><br><span class="line">* &#96;NestedType&#96; is a type declared inside another type.</span><br><span class="line"></span><br><span class="line">    &gt; NestedType是在另一个类型里面声明的类型。</span><br><span class="line"></span><br><span class="line">For instance, this query finds all top-level types whose name is not the same as that of their compilation unit:</span><br><span class="line"></span><br><span class="line">&gt; 例如，这个查询可以找到所有名称与其编译单元名称不同的顶层类型:</span><br></pre></td></tr></table></figure>
<p>import java</p>
<p>from TopLevelType tl<br>where tl.getName() != tl.getCompilationUnit().getName()<br>select tl</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">➤ [See this in the query console on LGTM.com](https:&#x2F;&#x2F;lgtm.com&#x2F;query&#x2F;4340983612585284460&#x2F;). This pattern is seen in many projects. When we ran it on the LGTM.com demo projects, most of the projects had at least one instance of this problem in the source code. There were many more instances in the files referenced by the source code.</span><br><span class="line"></span><br><span class="line">&gt; ➤ 在LGTM.com的查询控制台中可以看到。这种模式在很多项目中都能看到。当我们在LGTM.com演示项目上运行时，大多数项目的源代码中至少有一个这种问题的实例。在源代码引用的文件中，还有很多实例。</span><br><span class="line"></span><br><span class="line">![image-20210319172840606](https:&#x2F;&#x2F;gitee.com&#x2F;samny&#x2F;images&#x2F;raw&#x2F;master&#x2F;40u28er40ec&#x2F;40u28er40ec.png)</span><br><span class="line"></span><br><span class="line">Several more specialized classes are available as well:</span><br><span class="line"></span><br><span class="line">&gt; 有几个更专业的类。</span><br><span class="line"></span><br><span class="line">* &#96;TopLevelClass&#96; represents a class declared at the top-level of a compilation unit.</span><br><span class="line"></span><br><span class="line">    &gt; TopLevelClass表示在编译单元的顶层声明的类。</span><br><span class="line"></span><br><span class="line">* &#96;NestedClass&#96;represents a class declared inside another type , such as:</span><br><span class="line"></span><br><span class="line">    &gt; NestedClass代表一个在另一个类型里面声明的类，如:</span><br><span class="line"></span><br><span class="line">    * A &#96;LocalClass&#96;, which is [a class declared inside a method or constructor](https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;tutorial&#x2F;java&#x2F;javaOO&#x2F;localclasses.html).</span><br><span class="line"></span><br><span class="line">        &gt; LocalClass是一个在方法或构造函数里面声明的类。</span><br><span class="line"></span><br><span class="line">    * An &#96;AnonymousClass&#96;, which is an [anonymous class](https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;tutorial&#x2F;java&#x2F;javaOO&#x2F;anonymousclasses.html).</span><br><span class="line"></span><br><span class="line">        &gt; AnonymousClass是一个匿名类。</span><br><span class="line"></span><br><span class="line">Finally, the library also has a number of singleton classes that wrap frequently used Java standard library classes: &#96;TypeObject&#96;, &#96;TypeCloneable&#96;, &#96;TypeRuntime&#96;, &#96;TypeSerializable&#96;, &#96;TypeString&#96;, &#96;TypeSystem&#96; and &#96;TypeClass&#96;. Each CodeQL class represents the standard Java class suggested by its name.</span><br><span class="line"></span><br><span class="line">&gt; 最后，该库还有一些单子类，这些单子类包裹了常用的Java标准库类。TypeObject、TypeCloneable、TypeRuntime、TypeSerializable、TypeString、TypeSystem和TypeClass。每一个CodeQL类都代表了其名称所建议的标准Java类。</span><br><span class="line"></span><br><span class="line">As an example, we can write a query that finds all nested classes that directly extend &#96;Object&#96;:</span><br><span class="line"></span><br><span class="line">&gt; 作为一个例子，我们可以写一个查询，找到所有直接扩展Object的嵌套类:</span><br></pre></td></tr></table></figure>
<p>import java</p>
<p>from NestedClass nc<br>where nc.getASupertype() instanceof TypeObject<br>select nc</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">➤ [See this in the query console on LGTM.com](https:&#x2F;&#x2F;lgtm.com&#x2F;query&#x2F;8482509736206423238&#x2F;). You’re likely to get many results when you run this query because many projects include nested classes that extend &#96;Object&#96; directly.</span><br><span class="line"></span><br><span class="line">&gt; ➤ 在LGTM.com的查询控制台中可以看到。运行此查询时，可能会得到许多结果，因为许多项目都包含直接扩展 Object 的嵌套类。 </span><br><span class="line"></span><br><span class="line">![image-20210320173224433](https:&#x2F;&#x2F;gitee.com&#x2F;samny&#x2F;images&#x2F;raw&#x2F;master&#x2F;24u32er24ec&#x2F;24u32er24ec.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### Generics</span><br><span class="line"></span><br><span class="line">There are also several subclasses of &#96;Type&#96; for dealing with generic types.</span><br><span class="line"></span><br><span class="line">&gt; Type还有几个子类用于处理通用类型。</span><br><span class="line"></span><br><span class="line">A &#96;GenericType&#96; is either a &#96;GenericInterface&#96; or a &#96;GenericClass&#96;. It represents a generic type declaration such as interface &#96;java.util.Map&#96; from the Java standard library:</span><br><span class="line"></span><br><span class="line">&gt; 一个GenericType是一个GenericInterface或一个GenericClass。它代表一个通用类型声明，如Java标准库中的java.util.Map接口:</span><br></pre></td></tr></table></figure>
<p>package java.util.;</p>
<p>public interface Map&lt;K, V&gt; {<br>    int size();</p>
<pre><code>// ...</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Type parameters, such as &#96;K&#96; and &#96;V&#96; in this example, are represented by class &#96;TypeVariable&#96;.</span><br><span class="line"></span><br><span class="line">&gt; 类型参数，如本例中的K和V，由类TypeVariable表示。</span><br><span class="line"></span><br><span class="line">A parameterized instance of a generic type provides a concrete type to instantiate the type parameter with, as in &#96;Map&lt;String, File&gt;&#96;. Such a type is represented by a &#96;ParameterizedType&#96;, which is distinct from the &#96;GenericType&#96; representing the generic type it was instantiated from. To go from a &#96;ParameterizedType&#96; to its corresponding &#96;GenericType&#96;, you can use predicate &#96;getSourceDeclaration&#96;.</span><br><span class="line"></span><br><span class="line">&gt; 一个通用类型的参数化实例提供了一个具体的类型来实例化类型参数，如Map&lt;String, File&gt;。这样的类型由ParameterizedType表示，它与代表它被实例化的通用类型的GenericType不同。要从一个ParameterizedType到它对应的GenericType，可以使用谓词getSourceDeclaration。</span><br><span class="line"></span><br><span class="line">For instance, we could use the following query to find all parameterized instances of &#96;java.util.Map&#96;:</span><br><span class="line"></span><br><span class="line">&gt; 例如，我们可以使用下面的查询来查找 java.util.Map.的所有参数化实例:</span><br></pre></td></tr></table></figure>
<p>import java</p>
<p>from GenericInterface map, ParameterizedType pt<br>where map.hasQualifiedName(“java.util”, “Map”) and<br>    pt.getSourceDeclaration() = map<br>select pt</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">➤ [See this in the query console on LGTM.com](https:&#x2F;&#x2F;lgtm.com&#x2F;query&#x2F;7863873821043873550&#x2F;). None of the LGTM.com demo projects contain parameterized instances of &#96;java.util.Map&#96; in their source code, but they all have results in reference files.</span><br><span class="line"></span><br><span class="line">&gt; ➤ 在LGTM.com的查询控制台中可以看到。LGTM.com 演示项目的源代码中都不包含 java.util.Map 的参数化实例，但它们在参考文件中都有结果。</span><br><span class="line"></span><br><span class="line">![image-20210320173428831](https:&#x2F;&#x2F;gitee.com&#x2F;samny&#x2F;images&#x2F;raw&#x2F;master&#x2F;28u34er28ec&#x2F;28u34er28ec.png)</span><br><span class="line"></span><br><span class="line">In general, generic types may restrict which types a type parameter can be bound to. For instance, a type of maps from strings to numbers could be declared as follows:</span><br><span class="line"></span><br><span class="line">&gt; 一般来说，通用类型可能会限制类型参数可以绑定到哪些类型。例如，从字符串到数字的映射类型可以声明如下:</span><br></pre></td></tr></table></figure>
<p>class StringToNumMap<N extends number> implements Map&lt;String, N&gt; {<br>    // …<br>}</N></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">This means that a parameterized instance of &#96;StringToNumberMap&#96; can only instantiate type parameter &#96;N&#96; with type &#96;Number&#96; or one of its subtypes but not, for example, with &#96;File&#96;. We say that N is a bounded type parameter, with &#96;Number&#96; as its upper bound. In QL, a type variable can be queried for its type bound using predicate &#96;getATypeBound&#96;. The type bounds themselves are represented by class &#96;TypeBound&#96;, which has a member predicate &#96;getType&#96; to retrieve the type the variable is bounded by.</span><br><span class="line"></span><br><span class="line">&gt; 这意味着StringToNumberMap的参数化实例只能用Number类型或它的一个子类型实例化类型参数N，而不能用例如File类型实例化类型参数N。我们说N是一个有界的类型参数，Number是它的上界。在QL中，可以使用谓词getATypeBound查询一个类型变量的类型边界。类型约束本身由类TypeBound表示，它有一个成员谓词getType来检索变量被约束的类型。</span><br><span class="line"></span><br><span class="line">As an example, the following query finds all type variables with type bound &#96;Number&#96;:</span><br><span class="line"></span><br><span class="line">&gt; 作为一个例子，下面的查询可以找到所有类型绑定Number的类型变量:</span><br></pre></td></tr></table></figure>
<p>import java</p>
<p>from TypeVariable tv, TypeBound tb<br>where tb = tv.getATypeBound() and<br>    tb.getType().hasQualifiedName(“java.lang”, “Number”)<br>select tv</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">➤ [See this in the query console on LGTM.com](https:&#x2F;&#x2F;lgtm.com&#x2F;query&#x2F;6740696080876162817&#x2F;). When we ran it on the LGTM.com demo projects, the *neo4j&#x2F;neo4j*, *hibernate&#x2F;hibernate-orm* and *apache&#x2F;hadoop* projects all contained examples of this pattern.</span><br><span class="line"></span><br><span class="line">&gt; ➤ 在LGTM.com的查询控制台中可以看到。当我们在LGTM.com的演示项目上运行时，neo4j&#x2F;neo4j、hibernate&#x2F;hibernate-orm和apache&#x2F;hadoop项目都包含了这种模式的例子。</span><br><span class="line"></span><br><span class="line">For dealing with legacy code that is unaware of generics, every generic type has a “raw” version without any type parameters. In the CodeQL libraries, raw types are represented using class &#96;RawType&#96;, which has the expected subclasses &#96;RawClass&#96; and &#96;RawInterface&#96;. Again, there is a predicate &#96;getSourceDeclaration&#96; for obtaining the corresponding generic type. As an example, we can find variables of (raw) type &#96;Map&#96;:</span><br><span class="line"></span><br><span class="line">&gt; 对于处理不了解泛型的遗留代码，每个泛型都有一个没有任何类型参数的 &quot;原始 &quot;版本。在CodeQL库中，原始类型用类RawType表示，它有预期的子类RawClass和RawInterface。同样，有一个谓词getSourceDeclaration用于获取相应的通用类型。作为一个例子，我们可以找到（原始）类型Map的变量:</span><br></pre></td></tr></table></figure>
<p>import java</p>
<p>from Variable v, RawType rt<br>where rt = v.getType() and<br>    rt.getSourceDeclaration().hasQualifiedName(“java.util”, “Map”)<br>select v</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">➤ [See this in the query console on LGTM.com](https:&#x2F;&#x2F;lgtm.com&#x2F;query&#x2F;4032913402499547882&#x2F;). Many projects have variables of raw type &#96;Map&#96;.</span><br><span class="line"></span><br><span class="line">&gt; ➤ 在LGTM.com的查询控制台中可以看到。许多项目都有原始类型Map的变量。</span><br><span class="line"></span><br><span class="line">For example, in the following code snippet this query would find &#96;m1&#96;, but not &#96;m2&#96;:</span><br><span class="line"></span><br><span class="line">&gt; 例如，在下面的代码片段中，这个查询将找到 m1，但找不到 m2:</span><br></pre></td></tr></table></figure>
<p>Map m1 = new HashMap();<br>Map&lt;String, String&gt; m2 = new HashMap&lt;String, String&gt;();</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Finally, variables can be declared to be of a [wildcard type](https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;tutorial&#x2F;java&#x2F;generics&#x2F;wildcards.html):</span><br><span class="line"></span><br><span class="line">&gt; 最后，变量可以被声明为通配符类型:</span><br></pre></td></tr></table></figure>
<p>Map&lt;? extends Number, ? super Float&gt; m;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">The wildcards &#96;? extends Number&#96; and &#96;? super Float&#96; are represented by class &#96;WildcardTypeAccess&#96;. Like type parameters, wildcards may have type bounds. Unlike type parameters, wildcards can have upper bounds (as in &#96;? extends Number&#96;), and also lower bounds (as in &#96;? super Float&#96;). Class &#96;WildcardTypeAccess&#96; provides member predicates &#96;getUpperBound&#96; and &#96;getLowerBound&#96; to retrieve the upper and lower bounds, respectively.</span><br><span class="line"></span><br><span class="line">&gt; 通配符? extends Number和? super Float由类WildcardTypeAccess表示。和类型参数一样，通配符可以有类型边界。与类型参数不同的是，通配符可以有上界（如?extends Number），也可以有下界（如?super Float）。类WildcardTypeAccess提供了成员谓词getUpperBound和getLowerBound来分别检索上界和下界。</span><br><span class="line"></span><br><span class="line">For dealing with generic methods, there are classes &#96;GenericMethod&#96;, &#96;ParameterizedMethod&#96; and &#96;RawMethod&#96;, which are entirely analogous to the like-named classes for representing generic types.</span><br><span class="line"></span><br><span class="line">&gt; 对于处理通用方法，有GenericMethod、ParameterizedMethod和RawMethod等类，它们完全类似于表示通用类型的同名类。</span><br><span class="line"></span><br><span class="line">For more information on working with types, see the [Types in Java](https:&#x2F;&#x2F;codeql.github.com&#x2F;docs&#x2F;codeql-language-guides&#x2F;types-in-java&#x2F;).</span><br><span class="line"></span><br><span class="line">&gt; 有关使用类型的更多信息，请参阅Java中的类型。</span><br><span class="line"></span><br><span class="line">### Variables</span><br><span class="line"></span><br><span class="line">Class &#96;Variable&#96; represents a variable [in the Java sense](https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;tutorial&#x2F;java&#x2F;nutsandbolts&#x2F;variables.html), which is either a member field of a class (whether static or not), or a local variable, or a parameter. Consequently, there are three subclasses catering to these special cases:</span><br><span class="line"></span><br><span class="line">&gt; 类变量表示Java意义上的变量，它既可以是一个类的成员字段（不管是静态的还是非静态的），也可以是一个局部变量，或者是一个参数。因此，有三个子类迎合了这些特殊情况:</span><br><span class="line"></span><br><span class="line">* &#96;Field&#96; represents a Java field. Field代表一个Java字段。</span><br><span class="line">* &#96;LocalVariableDecl&#96; represents a local variable.  LocalVariableDecl代表一个局部变量。</span><br><span class="line">* &#96;Parameter&#96; represents a parameter of a method or constructor. Parameter代表一个方法或构造函数的参数。</span><br><span class="line"></span><br><span class="line">## Abstract syntax tree</span><br><span class="line"></span><br><span class="line">Classes in this category represent abstract syntax tree (AST) nodes, that is, statements (class &#96;Stmt&#96;) and expressions (class &#96;Expr&#96;). For a full list of expression and statement types available in the standard QL library, see “[Abstract syntax tree classes for working with Java programs](https:&#x2F;&#x2F;codeql.github.com&#x2F;docs&#x2F;codeql-language-guides&#x2F;abstract-syntax-tree-classes-for-working-with-java-programs&#x2F;).”</span><br><span class="line"></span><br><span class="line">&gt; 这一类的类代表抽象语法树（AST）节点，即语句（类Stmt）和表达式（类Expr）。关于标准QL库中可用的表达式和语句类型的完整列表，请参见 &quot;用于处理Java程序的抽象语法树类&quot;。</span><br><span class="line"></span><br><span class="line">Both &#96;Expr&#96; and &#96;Stmt&#96; provide member predicates for exploring the abstract syntax tree of a program:</span><br><span class="line"></span><br><span class="line">&gt; Expr和Stmt都提供了用于探索程序的抽象语法树的成员谓词。</span><br><span class="line"></span><br><span class="line">* &#96;Expr.getAChildExpr&#96; returns a sub-expression of a given expression. </span><br><span class="line"></span><br><span class="line">    &gt; Expr.getAChildExpr返回一个给定表达式的子表达式。</span><br><span class="line"></span><br><span class="line">* &#96;Stmt.getAChild&#96; returns a statement or expression that is nested directly inside a given statement.</span><br><span class="line"></span><br><span class="line">    &gt; Stmt.getAChild返回一个直接嵌套在给定语句中的语句或表达式。</span><br><span class="line"></span><br><span class="line">* &#96;Expr.getParent&#96; and &#96;Stmt.getParent&#96; return the parent node of an AST node.</span><br><span class="line"></span><br><span class="line">    &gt; Expr.getParent和Stmt.getParent返回一个AST节点的父节点。</span><br><span class="line"></span><br><span class="line">For example, the following query finds all expressions whose parents are &#96;return&#96; statements:</span><br><span class="line"></span><br><span class="line">&gt; 例如，下面的查询可以找到所有父母是返回语句的表达式:</span><br></pre></td></tr></table></figure>
<p>import java</p>
<p>from Expr e<br>where e.getParent() instanceof ReturnStmt<br>select e</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">➤ [See this in the query console on LGTM.com](https:&#x2F;&#x2F;lgtm.com&#x2F;query&#x2F;1947757851560375919&#x2F;). Many projects have examples of &#96;return&#96; statements with child expressions.</span><br><span class="line"></span><br><span class="line">&gt; ➤ 在LGTM.com的查询控制台中可以看到。很多项目都有返回语句与子表达式的例子。</span><br><span class="line"></span><br><span class="line">Therefore, if the program contains a return statement &#96;return x + y;&#96;, this query will return &#96;x + y&#96;.</span><br><span class="line"></span><br><span class="line">&gt; 因此，如果程序中包含一个返回语句return x + y;，这个查询将返回x + y。</span><br><span class="line"></span><br><span class="line">As another example, the following query finds statements whose parent is an &#96;if&#96; statement:</span><br><span class="line"></span><br><span class="line">&gt; 作为另一个例子，下面的查询可以找到父语句是if语句的语句:</span><br></pre></td></tr></table></figure>
<p>import java</p>
<p>from Stmt s<br>where s.getParent() instanceof IfStmt<br>select s</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">➤ [See this in the query console on LGTM.com](https:&#x2F;&#x2F;lgtm.com&#x2F;query&#x2F;1989464153689219612&#x2F;). Many projects have examples of &#96;if&#96; statements with child statements.</span><br><span class="line"></span><br><span class="line">&gt; ➤ 在LGTM.com的查询控制台中可以看到。很多项目都有if语句与子语句的例子。</span><br><span class="line"></span><br><span class="line">This query will find both &#96;then&#96; branches and &#96;else&#96; branches of all &#96;if&#96; statements in the program.</span><br><span class="line"></span><br><span class="line">&gt; 这个查询可以找到程序中所有if语句的then分支和 else分支。</span><br><span class="line"></span><br><span class="line">Finally, here is a query that finds method bodies:</span><br><span class="line"></span><br><span class="line">&gt; 最后，这里是一个查找方法体的查询:</span><br></pre></td></tr></table></figure>
<p>import java</p>
<p>from Stmt s<br>where s.getParent() instanceof Method<br>select s</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">➤ [See this in the query console on LGTM.com](https:&#x2F;&#x2F;lgtm.com&#x2F;query&#x2F;1016821702972128245&#x2F;). Most projects have many method bodies.</span><br><span class="line"></span><br><span class="line">&gt; ➤ 在LGTM.com的查询控制台中可以看到。大多数项目都有许多方法体。</span><br><span class="line"></span><br><span class="line">As these examples show, the parent node of an expression is not always an expression: it may also be a statement, for example, an &#96;IfStmt&#96;. Similarly, the parent node of a statement is not always a statement: it may also be a method or a constructor. To capture this, the QL Java library provides two abstract class &#96;ExprParent&#96; and &#96;StmtParent&#96;, the former representing any node that may be the parent node of an expression, and the latter any node that may be the parent node of a statement.</span><br><span class="line"></span><br><span class="line">&gt; 正如这些示例所示，一个表达式的父节点并不总是一个表达式：它也可能是一个语句，例如，一个 IfStmt。同样，一个语句的父节点也不总是一个语句：它也可能是一个方法或构造函数。为了抓住这一点，QL Java库提供了两个抽象类ExprParent和StmtParent，前者代表任何可能是表达式的父节点，后者代表任何可能是语句的父节点。</span><br><span class="line"></span><br><span class="line">For more information on working with AST classes, see the [article on overflow-prone comparisons in Java](https:&#x2F;&#x2F;codeql.github.com&#x2F;docs&#x2F;codeql-language-guides&#x2F;overflow-prone-comparisons-in-java&#x2F;).</span><br><span class="line"></span><br><span class="line">&gt; 有关使用AST类的更多信息，请参见 [article on overflow-prone comparisons in Java](https:&#x2F;&#x2F;codeql.github.com&#x2F;docs&#x2F;codeql-language-guides&#x2F;overflow-prone-comparisons-in-java&#x2F;).。</span><br><span class="line"></span><br><span class="line">## Metadata</span><br><span class="line"></span><br><span class="line">Java programs have several kinds of metadata, in addition to the program code proper. In particular, there are [annotations](https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;tutorial&#x2F;java&#x2F;annotations&#x2F;) and [Javadoc](https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Javadoc) comments. Since this metadata is interesting both for enhancing code analysis and as an analysis subject in its own right, the QL library defines classes for accessing it.</span><br><span class="line"></span><br><span class="line">&gt; Java程序除了程序代码本身外，还有几种元数据。特别是有注释和Javadoc注释。由于这些元数据对于增强代码分析和作为分析对象本身都很有趣，QL库定义了用于访问这些元数据的类。</span><br><span class="line"></span><br><span class="line">For annotations, class &#96;Annotatable&#96; is a superclass of all program elements that can be annotated. This includes packages, reference types, fields, methods, constructors, and local variable declarations. For every such element, its predicate &#96;getAnAnnotation&#96; allows you to retrieve any annotations the element may have. For example, the following query finds all annotations on constructors:</span><br><span class="line"></span><br><span class="line">&gt; 对于注释，类Annotatable是所有可以注释的程序元素的超类。这包括包、引用类型、字段、方法、构造器和局部变量声明。对于每一个这样的元素，它的谓词getAnAnnotation允许你检索该元素可能拥有的任何注释。例如，下面的查询可以找到所有关于构造函数的注解:</span><br></pre></td></tr></table></figure>
<p>import java</p>
<p>from Constructor c<br>select c.getAnAnnotation()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">➤ [See this in the query console on LGTM.com](https:&#x2F;&#x2F;lgtm.com&#x2F;query&#x2F;3206112561297137365&#x2F;). The LGTM.com demo projects all use annotations, you can see examples where they are used to suppress warnings and mark code as deprecated.</span><br><span class="line"></span><br><span class="line">&gt; ➤ 在 LGTM.com 的查询控制台中可以看到。LGTM.com 演示项目都使用了注解，您可以看到使用注解来抑制警告和将代码标记为废弃的例子。</span><br><span class="line"></span><br><span class="line">These annotations are represented by class &#96;Annotation&#96;. An annotation is simply an expression whose type is an &#96;AnnotationType&#96;. For example, you can amend this query so that it only reports deprecated constructors:</span><br><span class="line"></span><br><span class="line">&gt; 这些注解由类Annotation表示。注释是一个简单的表达式，其类型是AnnotationType。例如，你可以修改这个查询，使它只报告废弃的构造函数:</span><br></pre></td></tr></table></figure>
<p>import java</p>
<p>from Constructor c, Annotation ann, AnnotationType anntp<br>where ann = c.getAnAnnotation() and<br>    anntp = ann.getType() and<br>    anntp.hasQualifiedName(“java.lang”, “Deprecated”)<br>select ann</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">➤ [See this in the query console on LGTM.com](https:&#x2F;&#x2F;lgtm.com&#x2F;query&#x2F;5393027107459215059&#x2F;). Only constructors with the &#96;@Deprecated&#96; annotation are reported this time.</span><br><span class="line"></span><br><span class="line">&gt; ➤ 在LGTM.com的查询控制台中可以看到。这次只报告带有 @Deprecated 注解的构造函数。</span><br><span class="line"></span><br><span class="line">For more information on working with annotations, see the [article on annotations](https:&#x2F;&#x2F;codeql.github.com&#x2F;docs&#x2F;codeql-language-guides&#x2F;annotations-in-java&#x2F;).</span><br><span class="line"></span><br><span class="line">&gt; 有关使用注解的更多信息，请参阅关于注解的文章。</span><br><span class="line"></span><br><span class="line">For Javadoc, class &#96;Element&#96; has a member predicate &#96;getDoc&#96; that returns a delegate &#96;Documentable&#96; object, which can then be queried for its attached Javadoc comments. For example, the following query finds Javadoc comments on private fields:</span><br><span class="line"></span><br><span class="line">&gt; 对于Javadoc来说，类Element有一个成员谓词getDoc，它可以返回一个委派的Documentable对象，然后可以查询其附加的Javadoc注释。例如，下面的查询可以找到私有字段的Javadoc注释:</span><br></pre></td></tr></table></figure>
<p>import java</p>
<p>from Field f, Javadoc jdoc<br>where f.isPrivate() and<br>    jdoc = f.getDoc().getJavadoc()<br>select jdoc</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">➤ [See this in the query console on LGTM.com](https:&#x2F;&#x2F;lgtm.com&#x2F;query&#x2F;6022769142134600659&#x2F;). You can see this pattern in many projects.</span><br><span class="line"></span><br><span class="line">&gt; ➤ 在LGTM.com的查询控制台中可以看到。在很多项目中都可以看到这种模式。</span><br><span class="line"></span><br><span class="line">Class &#96;Javadoc&#96; represents an entire Javadoc comment as a tree of &#96;JavadocElement&#96; nodes, which can be traversed using member predicates &#96;getAChild&#96; and &#96;getParent&#96;. For instance, you could edit the query so that it finds all &#96;@author&#96; tags in Javadoc comments on private fields:</span><br><span class="line"></span><br><span class="line">&gt; 类 Javadoc 将整个 Javadoc 注释表示为 JavadocElement 节点的树，可以使用成员谓词 getAChild 和 getParent 遍历。例如，你可以编辑查询，使其找到私有字段的Javadoc注释中的所有@author标签:</span><br></pre></td></tr></table></figure>
<p>import java</p>
<p>from Field f, Javadoc jdoc, AuthorTag at<br>where f.isPrivate() and<br>    jdoc = f.getDoc().getJavadoc() and<br>    at.getParent+() = jdoc<br>select at</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">➤ [See this in the query console on LGTM.com](https:&#x2F;&#x2F;lgtm.com&#x2F;query&#x2F;2510220694395289111&#x2F;). None of the LGTM.com demo projects uses the &#96;@author&#96; tag on private fields.</span><br><span class="line"></span><br><span class="line">&gt; ➤ 在 LGTM.com 的查询控制台中可以看到。LGTM.com 演示项目中没有一个在私有字段上使用 @author 标签。</span><br><span class="line"></span><br><span class="line">&gt; Note</span><br><span class="line">&gt;</span><br><span class="line">&gt; On line 5 we used &#96;getParent+&#96; to capture tags that are nested at any depth within the Javadoc comment.</span><br><span class="line">&gt;</span><br><span class="line">&gt; 在第5行，我们使用getParent+来捕获Javadoc注释中任意深度嵌套的标签。</span><br><span class="line"></span><br><span class="line">For more information on working with Javadoc, see the [article on Javadoc](https:&#x2F;&#x2F;codeql.github.com&#x2F;docs&#x2F;codeql-language-guides&#x2F;javadoc&#x2F;).</span><br><span class="line"></span><br><span class="line">&gt; 关于使用 Javadoc 的更多信息，请看关于 Javadoc 的文章。</span><br><span class="line"></span><br><span class="line">## Metrics</span><br><span class="line"></span><br><span class="line">The standard QL Java library provides extensive support for computing metrics on Java program elements. To avoid overburdening the classes representing those elements with too many member predicates related to metric computations, these predicates are made available on delegate classes instead.</span><br><span class="line"></span><br><span class="line">&gt; 标准QL Java库为Java程序元素的度量计算提供了广泛的支持。为了避免与度量计算相关的成员谓词过多而给代表这些元素的类造成过重的负担，这些谓词被放在委托类上。</span><br><span class="line"></span><br><span class="line">Altogether, there are six such classes: &#96;MetricElement&#96;, &#96;MetricPackage&#96;, &#96;MetricRefType&#96;, &#96;MetricField&#96;, &#96;MetricCallable&#96;, and &#96;MetricStmt&#96;. The corresponding element classes each provide a member predicate &#96;getMetrics&#96; that can be used to obtain an instance of the delegate class, on which metric computations can then be performed.</span><br><span class="line"></span><br><span class="line">&gt; 一共有六个这样的类。MetricElement、MetricPackage、MetricRefType、MetricField、MetricCallable和MetricStmt。相应的元素类都提供了一个成员谓词getMetrics，可以用来获取委托类的实例，然后在这个实例上进行度量计算。</span><br><span class="line"></span><br><span class="line">For example, the following query finds methods with a [cyclomatic complexity](https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Cyclomatic_complexity) greater than 40:</span><br><span class="line"></span><br><span class="line">&gt; 例如，下面的查询可以找到循环复杂度大于40的方法:</span><br></pre></td></tr></table></figure>
<p>import java</p>
<p>from Method m, MetricCallable mc<br>where mc = m.getMetrics() and<br>    mc.getCyclomaticComplexity() &gt; 40<br>select m</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">➤ [See this in the query console on LGTM.com](https:&#x2F;&#x2F;lgtm.com&#x2F;query&#x2F;6566950741051181919&#x2F;). Most large projects include some methods with a very high cyclomatic complexity. These methods are likely to be difficult to understand and test.</span><br><span class="line"></span><br><span class="line">&gt; ➤ 在LGTM.com的查询控制台中可以看到。大多数大型项目都包括一些具有非常高循环复杂性的方法。这些方法可能难以理解和测试。</span><br><span class="line"></span><br><span class="line">## Call graph</span><br><span class="line"></span><br><span class="line">CodeQL databases generated from Java code bases include precomputed information about the program’s call graph, that is, which methods or constructors a given call may dispatch to at runtime.</span><br><span class="line"></span><br><span class="line">&gt; 由Java代码库生成的CodeQL数据库中包含了关于程序调用图的预计算信息，即一个给定的调用在运行时可能会派发给哪些方法或构造函数。</span><br><span class="line"></span><br><span class="line">The class &#96;Callable&#96;, introduced above, includes both methods and constructors. Call expressions are abstracted using class &#96;Call&#96;, which includes method calls, &#96;new&#96; expressions, and explicit constructor calls using &#96;this&#96; or &#96;super&#96;.</span><br><span class="line"></span><br><span class="line">&gt; 上文介绍的类Callable既包括方法，也包括构造器。调用表达式是用类Call抽象出来的，它包括方法调用、新表达式和使用this或super的显式构造函数调用。</span><br><span class="line"></span><br><span class="line">We can use predicate &#96;Call.getCallee&#96; to find out which method or constructor a specific call expression refers to. For example, the following query finds all calls to methods called &#96;println&#96;:</span><br><span class="line"></span><br><span class="line">&gt; 我们可以使用谓词Call.getCallee来查找一个特定的调用表达式指的是哪个方法或构造函数。例如，下面的查询可以找到所有调用println的方法:</span><br></pre></td></tr></table></figure>
<p>import java</p>
<p>from Call c, Method m<br>where m = c.getCallee() and<br>    m.hasName(“println”)<br>select c</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">➤ [See this in the query console on LGTM.com](https:&#x2F;&#x2F;lgtm.com&#x2F;query&#x2F;5861255162551917595&#x2F;). The LGTM.com demo projects all include many calls to methods of this name.</span><br><span class="line"></span><br><span class="line">&gt; ➤ 在LGTM.com的查询控制台中可以看到。LGTM.com 的演示项目都包含许多对这个名称的方法的调用。</span><br><span class="line"></span><br><span class="line">Conversely, &#96;Callable.getAReference&#96; returns a &#96;Call&#96; that refers to it. So we can find methods and constructors that are never called using this query:</span><br><span class="line"></span><br><span class="line">&gt; 反之，Callable.getAReference返回一个引用它的Call。所以我们可以使用这个查询找到从未被调用的方法和构造函数:</span><br></pre></td></tr></table></figure>
<p>import java</p>
<p>from Callable c<br>where not exists(c.getAReference())<br>select c</p>
<p>```</p>
<p>➤ <a href="https://lgtm.com/query/7261739919657747703/" target="_blank" rel="noopener">See this in the query console on LGTM.com</a>. The LGTM.com demo projects all appear to have many methods that are not called directly, but this is unlikely to be the whole story. To explore this area further, see “<a href="https://codeql.github.com/docs/codeql-language-guides/navigating-the-call-graph/" target="_blank" rel="noopener">Navigating the call graph</a>.”</p>
<blockquote>
<p>➤ 在LGTM.com的查询控制台中可以看到。LGTM.com 演示项目似乎都有许多方法没有被直接调用，但这不可能是全部。要进一步探索这个领域，请参见 “导航调用图”。</p>
</blockquote>
<p>For more information about callables and calls, see the <a href="https://codeql.github.com/docs/codeql-language-guides/navigating-the-call-graph/" target="_blank" rel="noopener">article on the call graph</a>.</p>
<blockquote>
<p>关于可调用和调用的更多信息，请参见关于调用图的文章。</p>
</blockquote>
<h2 id="Further-reading"><a href="#Further-reading" class="headerlink" title="Further reading"></a>Further reading</h2><ul>
<li><p><a href="https://github.com/github/codeql/tree/main/java/ql/src" target="_blank" rel="noopener">CodeQL queries for Java</a></p>
</li>
<li><p><a href="https://github.com/github/codeql/tree/main/java/ql/examples" target="_blank" rel="noopener">Example queries for Java</a></p>
</li>
<li><p><a href="https://codeql.github.com/codeql-standard-libraries/java/" target="_blank" rel="noopener">CodeQL library reference for Java</a></p>
</li>
<li><p>“<a href="https://codeql.github.com/docs/ql-language-reference/#ql-language-reference" target="_blank" rel="noopener">QL language reference</a>”</p>
</li>
<li><p>“<a href="https://codeql.github.com/docs/codeql-overview/codeql-tools/#codeql-tools" target="_blank" rel="noopener">CodeQL tools</a>”</p>
</li>
</ul>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="true">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='https://link.hhtjim.com/163/574566207.mp3'></li>
                        
                    
                        
                            <li title='1' data-url='https://link.hhtjim.com/qq/playsong.mp3'></li>
                        
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
        data-ae='true'
        data-ci='a69212da3fc88cd39af9'
        data-cs='33d19613b15eb03266763f3a34a0d745cd545464'
        data-r='gittalk'
        data-o='summersec'
        data-a='summersec'
        data-d='true'
    >查看评论</div>


    </div>
    
        <div class='side'>
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#CodeQL-library-for-Java¶"><span class="toc-number">1.</span> <span class="toc-text">CodeQL library for Java¶</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#About-the-CodeQL-library-for-Java"><span class="toc-number">1.1.</span> <span class="toc-text">About the CodeQL library for Java</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Summary-of-the-library-classes"><span class="toc-number">1.2.</span> <span class="toc-text">Summary of the library classes</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Program-elements"><span class="toc-number">1.3.</span> <span class="toc-text">Program elements</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Types"><span class="toc-number">1.3.1.</span> <span class="toc-text">Types</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Further-reading"><span class="toc-number">1.4.</span> <span class="toc-text">Further reading</span></a></li></ol></li></ol>
        </div>
    
</div>


    </div>
</div>
<span id="busuanzi_container_page_pv">
   本文总阅读量<span id="busuanzi_value_page_pv"></span>次
</span>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>

<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/diaspora.js"></script>
<script src="/js/snow.js"></script>
<script src="/js/test.js"></script>
<script src="/js/tx.js"></script>
<script src="/js/x.js"></script>
<script src="/js/xiantiao.js"></script>
<script src="/js/baidu.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>


<!-- 在想要使用窗口小部件的地方插入该标签 -->
<iframe width="900" height="401" src="https://cybermap.kaspersky.com/cn/widget/dynamic/dark" frameborder="0">


<script type="text/javascript" src="//rf.revolvermaps.com/0/0/6.js?i=5jbaycl6wsf&amp;m=7&amp;c=e63100&amp;cr1=ffffff&amp;f=arial&amp;l=0&amp;bv=90&amp;lx=-420&amp;ly=420&amp;hi=20&amp;he=7&amp;hc=a8ddff&amp;rs=80" async="async"></script>




<!-- Google Analytics -->
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', '218065278', 'auto');
  ga('send', 'pageview');
</script>
<!-- End Google Analytics -->


</html>
